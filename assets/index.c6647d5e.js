var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude2) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude2.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude2.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const p = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p();
function noop() {
}
const identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function custom_event(type2, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type2, bubbles, false, detail);
  return e;
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t = a + (b - a) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { stylesheet } = info;
      let i = stylesheet.cssRules.length;
      while (i--)
        stylesheet.deleteRule(i);
      info.rules = {};
    });
    managed_styles.clear();
  });
}
function create_animation(node, from, fn, params2) {
  if (!from)
    return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop;
  const {
    delay = 0,
    duration = 300,
    easing = identity,
    start: start_time = now() + delay,
    end = start_time + duration,
    tick: tick2 = noop,
    css
  } = fn(node, { from, to }, params2);
  let running = true;
  let started = false;
  let name;
  function start2() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  function stop() {
    if (css)
      delete_rule(node, name);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end) {
      tick2(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p2 = now2 - start_time;
      const t = 0 + 1 * easing(p2 / duration);
      tick2(t, 1 - t);
    }
    return true;
  });
  start2();
  tick2(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a);
  }
}
function add_transform(node, a) {
  const b = node.getBoundingClientRect();
  if (a.left !== b.left || a.top !== b.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
  }
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type2, detail) => {
    const callbacks = component.$$.callbacks[type2];
    if (callbacks) {
      const event = custom_event(type2, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch$1(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params2) {
  let config = fn(node, params2);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch$1(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch$1(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config();
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn, params2) {
  let config = fn(node, params2);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch$1(node, false, "start"));
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch$1(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config)) {
    wait().then(() => {
      config = config();
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type2, callback) {
    const callbacks = this.$$.callbacks[type2] || (this.$$.callbacks[type2] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
const subscriber_queue = [];
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}
function parse(str, loose) {
  if (str instanceof RegExp)
    return { keys: false, pattern: str };
  var c, o, tmp, ext, keys = [], pattern = "", arr = str.split("/");
  arr[0] || arr.shift();
  while (tmp = arr.shift()) {
    c = tmp[0];
    if (c === "*") {
      keys.push("wild");
      pattern += "/(.*)";
    } else if (c === ":") {
      o = tmp.indexOf("?", 1);
      ext = tmp.indexOf(".", 1);
      keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
      pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
      if (!!~ext)
        pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
    } else {
      pattern += "/" + tmp;
    }
  }
  return {
    keys,
    pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
  };
}
function create_else_block$5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[2]];
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
    switch_instance.$on("routeEvent", ctx[7]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[2])]) : {};
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          switch_instance.$on("routeEvent", ctx2[7]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$f(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [{ params: ctx[1] }, ctx[2]];
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
    switch_instance.$on("routeEvent", ctx[6]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 6 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 2 && { params: ctx2[1] },
        dirty & 4 && get_spread_object(ctx2[2])
      ]) : {};
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          switch_instance.$on("routeEvent", ctx2[6]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$J(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$f, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function getLocation() {
  const hashPosition = window.location.href.indexOf("#/");
  let location = hashPosition > -1 ? window.location.href.substr(hashPosition + 1) : "/";
  const qsPosition = location.indexOf("?");
  let querystring = "";
  if (qsPosition > -1) {
    querystring = location.substr(qsPosition + 1);
    location = location.substr(0, qsPosition);
  }
  return { location, querystring };
}
const loc = readable(null, function start(set) {
  set(getLocation());
  const update2 = () => {
    set(getLocation());
  };
  window.addEventListener("hashchange", update2, false);
  return function stop() {
    window.removeEventListener("hashchange", update2, false);
  };
});
derived(loc, ($loc) => $loc.location);
derived(loc, ($loc) => $loc.querystring);
const params = writable(void 0);
async function push(location) {
  if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    throw Error("Invalid parameter location");
  }
  await tick();
  history.replaceState(__spreadProps(__spreadValues({}, history.state), {
    __svelte_spa_router_scrollX: window.scrollX,
    __svelte_spa_router_scrollY: window.scrollY
  }), void 0, void 0);
  window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
}
function instance$y($$self, $$props, $$invalidate) {
  let { routes = {} } = $$props;
  let { prefix = "" } = $$props;
  let { restoreScrollState = false } = $$props;
  class RouteItem {
    constructor(path, component2) {
      if (!component2 || typeof component2 != "function" && (typeof component2 != "object" || component2._sveltesparouter !== true)) {
        throw Error("Invalid component object");
      }
      if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
        throw Error('Invalid value for "path" argument - strings must start with / or *');
      }
      const { pattern, keys } = parse(path);
      this.path = path;
      if (typeof component2 == "object" && component2._sveltesparouter === true) {
        this.component = component2.component;
        this.conditions = component2.conditions || [];
        this.userData = component2.userData;
        this.props = component2.props || {};
      } else {
        this.component = () => Promise.resolve(component2);
        this.conditions = [];
        this.props = {};
      }
      this._pattern = pattern;
      this._keys = keys;
    }
    match(path) {
      if (prefix) {
        if (typeof prefix == "string") {
          if (path.startsWith(prefix)) {
            path = path.substr(prefix.length) || "/";
          } else {
            return null;
          }
        } else if (prefix instanceof RegExp) {
          const match = path.match(prefix);
          if (match && match[0]) {
            path = path.substr(match[0].length) || "/";
          } else {
            return null;
          }
        }
      }
      const matches2 = this._pattern.exec(path);
      if (matches2 === null) {
        return null;
      }
      if (this._keys === false) {
        return matches2;
      }
      const out = {};
      let i = 0;
      while (i < this._keys.length) {
        try {
          out[this._keys[i]] = decodeURIComponent(matches2[i + 1] || "") || null;
        } catch (e) {
          out[this._keys[i]] = null;
        }
        i++;
      }
      return out;
    }
    async checkConditions(detail) {
      for (let i = 0; i < this.conditions.length; i++) {
        if (!await this.conditions[i](detail)) {
          return false;
        }
      }
      return true;
    }
  }
  const routesList = [];
  if (routes instanceof Map) {
    routes.forEach((route, path) => {
      routesList.push(new RouteItem(path, route));
    });
  } else {
    Object.keys(routes).forEach((path) => {
      routesList.push(new RouteItem(path, routes[path]));
    });
  }
  let component = null;
  let componentParams = null;
  let props = {};
  const dispatch2 = createEventDispatcher();
  async function dispatchNextTick(name, detail) {
    await tick();
    dispatch2(name, detail);
  }
  let previousScrollState = null;
  let popStateChanged = null;
  if (restoreScrollState) {
    popStateChanged = (event) => {
      if (event.state && event.state.__svelte_spa_router_scrollY) {
        previousScrollState = event.state;
      } else {
        previousScrollState = null;
      }
    };
    window.addEventListener("popstate", popStateChanged);
    afterUpdate(() => {
      if (previousScrollState) {
        window.scrollTo(previousScrollState.__svelte_spa_router_scrollX, previousScrollState.__svelte_spa_router_scrollY);
      } else {
        window.scrollTo(0, 0);
      }
    });
  }
  let lastLoc = null;
  let componentObj = null;
  const unsubscribeLoc = loc.subscribe(async (newLoc) => {
    lastLoc = newLoc;
    let i = 0;
    while (i < routesList.length) {
      const match = routesList[i].match(newLoc.location);
      if (!match) {
        i++;
        continue;
      }
      const detail = {
        route: routesList[i].path,
        location: newLoc.location,
        querystring: newLoc.querystring,
        userData: routesList[i].userData,
        params: match && typeof match == "object" && Object.keys(match).length ? match : null
      };
      if (!await routesList[i].checkConditions(detail)) {
        $$invalidate(0, component = null);
        componentObj = null;
        dispatchNextTick("conditionsFailed", detail);
        return;
      }
      dispatchNextTick("routeLoading", Object.assign({}, detail));
      const obj = routesList[i].component;
      if (componentObj != obj) {
        if (obj.loading) {
          $$invalidate(0, component = obj.loading);
          componentObj = obj;
          $$invalidate(1, componentParams = obj.loadingParams);
          $$invalidate(2, props = {});
          dispatchNextTick("routeLoaded", Object.assign({}, detail, {
            component,
            name: component.name,
            params: componentParams
          }));
        } else {
          $$invalidate(0, component = null);
          componentObj = null;
        }
        const loaded = await obj();
        if (newLoc != lastLoc) {
          return;
        }
        $$invalidate(0, component = loaded && loaded.default || loaded);
        componentObj = obj;
      }
      if (match && typeof match == "object" && Object.keys(match).length) {
        $$invalidate(1, componentParams = match);
      } else {
        $$invalidate(1, componentParams = null);
      }
      $$invalidate(2, props = routesList[i].props);
      dispatchNextTick("routeLoaded", Object.assign({}, detail, {
        component,
        name: component.name,
        params: componentParams
      })).then(() => {
        params.set(componentParams);
      });
      return;
    }
    $$invalidate(0, component = null);
    componentObj = null;
    params.set(void 0);
  });
  onDestroy(() => {
    unsubscribeLoc();
    popStateChanged && window.removeEventListener("popstate", popStateChanged);
  });
  function routeEvent_handler(event) {
    bubble.call(this, $$self, event);
  }
  function routeEvent_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("routes" in $$props2)
      $$invalidate(3, routes = $$props2.routes);
    if ("prefix" in $$props2)
      $$invalidate(4, prefix = $$props2.prefix);
    if ("restoreScrollState" in $$props2)
      $$invalidate(5, restoreScrollState = $$props2.restoreScrollState);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    }
  };
  return [
    component,
    componentParams,
    props,
    routes,
    prefix,
    restoreScrollState,
    routeEvent_handler,
    routeEvent_handler_1
  ];
}
class Router extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$J, safe_not_equal, {
      routes: 3,
      prefix: 4,
      restoreScrollState: 5
    });
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation = function() {
  function MDCFoundation2(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }
    this.adapter = adapter;
  }
  Object.defineProperty(MDCFoundation2, "cssClasses", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "strings", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "numbers", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "defaultAdapter", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  MDCFoundation2.prototype.init = function() {
  };
  MDCFoundation2.prototype.destroy = function() {
  };
  return MDCFoundation2;
}();
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function applyPassive$1(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  var passiveSupported = false;
  try {
    var options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    var handler = function() {
    };
    globalObj.document.addEventListener("test", handler, options);
    globalObj.document.removeEventListener("test", handler, options);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}
var events = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyPassive: applyPassive$1
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function closest(element2, selector) {
  if (element2.closest) {
    return element2.closest(selector);
  }
  var el = element2;
  while (el) {
    if (matches$1(el, selector)) {
      return el;
    }
    el = el.parentElement;
  }
  return null;
}
function matches$1(element2, selector) {
  var nativeMatches = element2.matches || element2.webkitMatchesSelector || element2.msMatchesSelector;
  return nativeMatches.call(element2, selector);
}
function estimateScrollWidth(element2) {
  var htmlEl = element2;
  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }
  var clone = htmlEl.cloneNode(true);
  clone.style.setProperty("position", "absolute");
  clone.style.setProperty("transform", "translate(-9999px, -9999px)");
  document.documentElement.appendChild(clone);
  var scrollWidth = clone.scrollWidth;
  document.documentElement.removeChild(clone);
  return scrollWidth;
}
var ponyfill = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closest,
  matches: matches$1,
  estimateScrollWidth
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$a = {
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
};
var strings$8 = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
};
var numbers$5 = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
};
var supportsCssVariables_;
function supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  var CSS = windowObj.CSS;
  var supportsCssVars = supportsCssVariables_;
  if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
    return supportsCssVariables_;
  }
  var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
  if (!supportsFunctionPresent) {
    return false;
  }
  var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
  var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
  supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVars;
  }
  return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return { x: 0, y: 0 };
  }
  var x = pageOffset.x, y = pageOffset.y;
  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;
  var normalizedX;
  var normalizedY;
  if (evt.type === "touchstart") {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }
  return { x: normalizedX, y: normalizedY };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ACTIVATION_EVENT_TYPES = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
];
var POINTER_DEACTIVATION_EVENT_TYPES = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
];
var activatedTargets = [];
var MDCRippleFoundation = function(_super) {
  __extends(MDCRippleFoundation2, _super);
  function MDCRippleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
    _this.activationAnimationHasEnded = false;
    _this.activationTimer = 0;
    _this.fgDeactivationRemovalTimer = 0;
    _this.fgScale = "0";
    _this.frame = { width: 0, height: 0 };
    _this.initialSize = 0;
    _this.layoutFrame = 0;
    _this.maxRadius = 0;
    _this.unboundedCoords = { left: 0, top: 0 };
    _this.activationState = _this.defaultActivationState();
    _this.activationTimerCallback = function() {
      _this.activationAnimationHasEnded = true;
      _this.runDeactivationUXLogicIfReady();
    };
    _this.activateHandler = function(e) {
      _this.activateImpl(e);
    };
    _this.deactivateHandler = function() {
      _this.deactivateImpl();
    };
    _this.focusHandler = function() {
      _this.handleFocus();
    };
    _this.blurHandler = function() {
      _this.handleBlur();
    };
    _this.resizeHandler = function() {
      _this.layout();
    };
    return _this;
  }
  Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$a;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "strings", {
    get: function() {
      return strings$8;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "numbers", {
    get: function() {
      return numbers$5;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        browserSupportsCssVars: function() {
          return true;
        },
        computeBoundingRect: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        containsEventTarget: function() {
          return true;
        },
        deregisterDocumentInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        },
        deregisterResizeHandler: function() {
          return void 0;
        },
        getWindowPageOffset: function() {
          return { x: 0, y: 0 };
        },
        isSurfaceActive: function() {
          return true;
        },
        isSurfaceDisabled: function() {
          return true;
        },
        isUnbounded: function() {
          return true;
        },
        registerDocumentInteractionHandler: function() {
          return void 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        registerResizeHandler: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        updateCssVariable: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCRippleFoundation2.prototype.init = function() {
    var _this = this;
    var supportsPressRipple = this.supportsPressRipple();
    this.registerRootHandlers(supportsPressRipple);
    if (supportsPressRipple) {
      var _a2 = MDCRippleFoundation2.cssClasses, ROOT_1 = _a2.ROOT, UNBOUNDED_1 = _a2.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.addClass(ROOT_1);
        if (_this.adapter.isUnbounded()) {
          _this.adapter.addClass(UNBOUNDED_1);
          _this.layoutInternal();
        }
      });
    }
  };
  MDCRippleFoundation2.prototype.destroy = function() {
    var _this = this;
    if (this.supportsPressRipple()) {
      if (this.activationTimer) {
        clearTimeout(this.activationTimer);
        this.activationTimer = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
      }
      if (this.fgDeactivationRemovalTimer) {
        clearTimeout(this.fgDeactivationRemovalTimer);
        this.fgDeactivationRemovalTimer = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
      }
      var _a2 = MDCRippleFoundation2.cssClasses, ROOT_2 = _a2.ROOT, UNBOUNDED_2 = _a2.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.removeClass(ROOT_2);
        _this.adapter.removeClass(UNBOUNDED_2);
        _this.removeCssVars();
      });
    }
    this.deregisterRootHandlers();
    this.deregisterDeactivationHandlers();
  };
  MDCRippleFoundation2.prototype.activate = function(evt) {
    this.activateImpl(evt);
  };
  MDCRippleFoundation2.prototype.deactivate = function() {
    this.deactivateImpl();
  };
  MDCRippleFoundation2.prototype.layout = function() {
    var _this = this;
    if (this.layoutFrame) {
      cancelAnimationFrame(this.layoutFrame);
    }
    this.layoutFrame = requestAnimationFrame(function() {
      _this.layoutInternal();
      _this.layoutFrame = 0;
    });
  };
  MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
    var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
    if (unbounded) {
      this.adapter.addClass(UNBOUNDED);
    } else {
      this.adapter.removeClass(UNBOUNDED);
    }
  };
  MDCRippleFoundation2.prototype.handleFocus = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.handleBlur = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.supportsPressRipple = function() {
    return this.adapter.browserSupportsCssVars();
  };
  MDCRippleFoundation2.prototype.defaultActivationState = function() {
    return {
      activationEvent: void 0,
      hasDeactivationUXRun: false,
      isActivated: false,
      isProgrammatic: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false
    };
  };
  MDCRippleFoundation2.prototype.registerRootHandlers = function(supportsPressRipple) {
    var e_1, _a2;
    if (supportsPressRipple) {
      try {
        for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
          var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
          this.adapter.registerInteractionHandler(evtType, this.activateHandler);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a2 = ACTIVATION_EVENT_TYPES_1.return))
            _a2.call(ACTIVATION_EVENT_TYPES_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (this.adapter.isUnbounded()) {
        this.adapter.registerResizeHandler(this.resizeHandler);
      }
    }
    this.adapter.registerInteractionHandler("focus", this.focusHandler);
    this.adapter.registerInteractionHandler("blur", this.blurHandler);
  };
  MDCRippleFoundation2.prototype.registerDeactivationHandlers = function(evt) {
    var e_2, _a2;
    if (evt.type === "keydown") {
      this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
    } else {
      try {
        for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
          var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
          this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_1.return))
            _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  };
  MDCRippleFoundation2.prototype.deregisterRootHandlers = function() {
    var e_3, _a2;
    try {
      for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
        var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
        this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a2 = ACTIVATION_EVENT_TYPES_2.return))
          _a2.call(ACTIVATION_EVENT_TYPES_2);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    this.adapter.deregisterInteractionHandler("focus", this.focusHandler);
    this.adapter.deregisterInteractionHandler("blur", this.blurHandler);
    if (this.adapter.isUnbounded()) {
      this.adapter.deregisterResizeHandler(this.resizeHandler);
    }
  };
  MDCRippleFoundation2.prototype.deregisterDeactivationHandlers = function() {
    var e_4, _a2;
    this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
    try {
      for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
        var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
        this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_2.return))
          _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
  };
  MDCRippleFoundation2.prototype.removeCssVars = function() {
    var _this = this;
    var rippleStrings = MDCRippleFoundation2.strings;
    var keys = Object.keys(rippleStrings);
    keys.forEach(function(key) {
      if (key.indexOf("VAR_") === 0) {
        _this.adapter.updateCssVariable(rippleStrings[key], null);
      }
    });
  };
  MDCRippleFoundation2.prototype.activateImpl = function(evt) {
    var _this = this;
    if (this.adapter.isSurfaceDisabled()) {
      return;
    }
    var activationState = this.activationState;
    if (activationState.isActivated) {
      return;
    }
    var previousActivationEvent = this.previousActivationEvent;
    var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
    if (isSameInteraction) {
      return;
    }
    activationState.isActivated = true;
    activationState.isProgrammatic = evt === void 0;
    activationState.activationEvent = evt;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
    var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
      return _this.adapter.containsEventTarget(target);
    });
    if (hasActivatedChild) {
      this.resetActivationState();
      return;
    }
    if (evt !== void 0) {
      activatedTargets.push(evt.target);
      this.registerDeactivationHandlers(evt);
    }
    activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
    if (activationState.wasElementMadeActive) {
      this.animateActivation();
    }
    requestAnimationFrame(function() {
      activatedTargets = [];
      if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
        activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
        if (activationState.wasElementMadeActive) {
          _this.animateActivation();
        }
      }
      if (!activationState.wasElementMadeActive) {
        _this.activationState = _this.defaultActivationState();
      }
    });
  };
  MDCRippleFoundation2.prototype.checkElementMadeActive = function(evt) {
    return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
  };
  MDCRippleFoundation2.prototype.animateActivation = function() {
    var _this = this;
    var _a2 = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a2.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a2.VAR_FG_TRANSLATE_END;
    var _b2 = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b2.FG_DEACTIVATION, FG_ACTIVATION = _b2.FG_ACTIVATION;
    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
    this.layoutInternal();
    var translateStart = "";
    var translateEnd = "";
    if (!this.adapter.isUnbounded()) {
      var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;
      translateStart = startPoint.x + "px, " + startPoint.y + "px";
      translateEnd = endPoint.x + "px, " + endPoint.y + "px";
    }
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
    clearTimeout(this.activationTimer);
    clearTimeout(this.fgDeactivationRemovalTimer);
    this.rmBoundedActivationClasses();
    this.adapter.removeClass(FG_DEACTIVATION);
    this.adapter.computeBoundingRect();
    this.adapter.addClass(FG_ACTIVATION);
    this.activationTimer = setTimeout(function() {
      _this.activationTimerCallback();
    }, DEACTIVATION_TIMEOUT_MS);
  };
  MDCRippleFoundation2.prototype.getFgTranslationCoordinates = function() {
    var _a2 = this.activationState, activationEvent = _a2.activationEvent, wasActivatedByPointer = _a2.wasActivatedByPointer;
    var startPoint;
    if (wasActivatedByPointer) {
      startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame.width / 2,
        y: this.frame.height / 2
      };
    }
    startPoint = {
      x: startPoint.x - this.initialSize / 2,
      y: startPoint.y - this.initialSize / 2
    };
    var endPoint = {
      x: this.frame.width / 2 - this.initialSize / 2,
      y: this.frame.height / 2 - this.initialSize / 2
    };
    return { startPoint, endPoint };
  };
  MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady = function() {
    var _this = this;
    var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
    var _a2 = this.activationState, hasDeactivationUXRun = _a2.hasDeactivationUXRun, isActivated = _a2.isActivated;
    var activationHasEnded = hasDeactivationUXRun || !isActivated;
    if (activationHasEnded && this.activationAnimationHasEnded) {
      this.rmBoundedActivationClasses();
      this.adapter.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer = setTimeout(function() {
        _this.adapter.removeClass(FG_DEACTIVATION);
      }, numbers$5.FG_DEACTIVATION_MS);
    }
  };
  MDCRippleFoundation2.prototype.rmBoundedActivationClasses = function() {
    var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
    this.adapter.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded = false;
    this.adapter.computeBoundingRect();
  };
  MDCRippleFoundation2.prototype.resetActivationState = function() {
    var _this = this;
    this.previousActivationEvent = this.activationState.activationEvent;
    this.activationState = this.defaultActivationState();
    setTimeout(function() {
      return _this.previousActivationEvent = void 0;
    }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
  };
  MDCRippleFoundation2.prototype.deactivateImpl = function() {
    var _this = this;
    var activationState = this.activationState;
    if (!activationState.isActivated) {
      return;
    }
    var state = __assign({}, activationState);
    if (activationState.isProgrammatic) {
      requestAnimationFrame(function() {
        _this.animateDeactivation(state);
      });
      this.resetActivationState();
    } else {
      this.deregisterDeactivationHandlers();
      requestAnimationFrame(function() {
        _this.activationState.hasDeactivationUXRun = true;
        _this.animateDeactivation(state);
        _this.resetActivationState();
      });
    }
  };
  MDCRippleFoundation2.prototype.animateDeactivation = function(_a2) {
    var wasActivatedByPointer = _a2.wasActivatedByPointer, wasElementMadeActive = _a2.wasElementMadeActive;
    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady();
    }
  };
  MDCRippleFoundation2.prototype.layoutInternal = function() {
    var _this = this;
    this.frame = this.adapter.computeBoundingRect();
    var maxDim = Math.max(this.frame.height, this.frame.width);
    var getBoundedRadius = function() {
      var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
      return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
    };
    this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
    var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
    if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
      this.initialSize = initialSize - 1;
    } else {
      this.initialSize = initialSize;
    }
    this.fgScale = "" + this.maxRadius / this.initialSize;
    this.updateLayoutCssVars();
  };
  MDCRippleFoundation2.prototype.updateLayoutCssVars = function() {
    var _a2 = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a2.VAR_FG_SIZE, VAR_LEFT = _a2.VAR_LEFT, VAR_TOP = _a2.VAR_TOP, VAR_FG_SCALE = _a2.VAR_FG_SCALE;
    this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
    this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
    if (this.adapter.isUnbounded()) {
      this.unboundedCoords = {
        left: Math.round(this.frame.width / 2 - this.initialSize / 2),
        top: Math.round(this.frame.height / 2 - this.initialSize / 2)
      };
      this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
      this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
    }
  };
  return MDCRippleFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$9 = {
  FIXED_CLASS: "mdc-top-app-bar--fixed",
  FIXED_SCROLLED_CLASS: "mdc-top-app-bar--fixed-scrolled",
  SHORT_CLASS: "mdc-top-app-bar--short",
  SHORT_COLLAPSED_CLASS: "mdc-top-app-bar--short-collapsed",
  SHORT_HAS_ACTION_ITEM_CLASS: "mdc-top-app-bar--short-has-action-item"
};
var numbers$4 = {
  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
  MAX_TOP_APP_BAR_HEIGHT: 128
};
var strings$7 = {
  ACTION_ITEM_SELECTOR: ".mdc-top-app-bar__action-item",
  NAVIGATION_EVENT: "MDCTopAppBar:nav",
  NAVIGATION_ICON_SELECTOR: ".mdc-top-app-bar__navigation-icon",
  ROOT_SELECTOR: ".mdc-top-app-bar",
  TITLE_SELECTOR: ".mdc-top-app-bar__title"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTopAppBarBaseFoundation = function(_super) {
  __extends(MDCTopAppBarBaseFoundation2, _super);
  function MDCTopAppBarBaseFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCTopAppBarBaseFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCTopAppBarBaseFoundation2, "strings", {
    get: function() {
      return strings$7;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTopAppBarBaseFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$9;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTopAppBarBaseFoundation2, "numbers", {
    get: function() {
      return numbers$4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTopAppBarBaseFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        setStyle: function() {
          return void 0;
        },
        getTopAppBarHeight: function() {
          return 0;
        },
        notifyNavigationIconClicked: function() {
          return void 0;
        },
        getViewportScrollY: function() {
          return 0;
        },
        getTotalActionItems: function() {
          return 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTopAppBarBaseFoundation2.prototype.handleTargetScroll = function() {
  };
  MDCTopAppBarBaseFoundation2.prototype.handleWindowResize = function() {
  };
  MDCTopAppBarBaseFoundation2.prototype.handleNavigationClick = function() {
    this.adapter.notifyNavigationIconClicked();
  };
  return MDCTopAppBarBaseFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var INITIAL_VALUE = 0;
var MDCTopAppBarFoundation = function(_super) {
  __extends(MDCTopAppBarFoundation2, _super);
  function MDCTopAppBarFoundation2(adapter) {
    var _this = _super.call(this, adapter) || this;
    _this.wasDocked = true;
    _this.isDockedShowing = true;
    _this.currentAppBarOffsetTop = 0;
    _this.isCurrentlyBeingResized = false;
    _this.resizeThrottleId = INITIAL_VALUE;
    _this.resizeDebounceId = INITIAL_VALUE;
    _this.lastScrollPosition = _this.adapter.getViewportScrollY();
    _this.topAppBarHeight = _this.adapter.getTopAppBarHeight();
    return _this;
  }
  MDCTopAppBarFoundation2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.adapter.setStyle("top", "");
  };
  MDCTopAppBarFoundation2.prototype.handleTargetScroll = function() {
    var currentScrollPosition = Math.max(this.adapter.getViewportScrollY(), 0);
    var diff = currentScrollPosition - this.lastScrollPosition;
    this.lastScrollPosition = currentScrollPosition;
    if (!this.isCurrentlyBeingResized) {
      this.currentAppBarOffsetTop -= diff;
      if (this.currentAppBarOffsetTop > 0) {
        this.currentAppBarOffsetTop = 0;
      } else if (Math.abs(this.currentAppBarOffsetTop) > this.topAppBarHeight) {
        this.currentAppBarOffsetTop = -this.topAppBarHeight;
      }
      this.moveTopAppBar();
    }
  };
  MDCTopAppBarFoundation2.prototype.handleWindowResize = function() {
    var _this = this;
    if (!this.resizeThrottleId) {
      this.resizeThrottleId = setTimeout(function() {
        _this.resizeThrottleId = INITIAL_VALUE;
        _this.throttledResizeHandler();
      }, numbers$4.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
    }
    this.isCurrentlyBeingResized = true;
    if (this.resizeDebounceId) {
      clearTimeout(this.resizeDebounceId);
    }
    this.resizeDebounceId = setTimeout(function() {
      _this.handleTargetScroll();
      _this.isCurrentlyBeingResized = false;
      _this.resizeDebounceId = INITIAL_VALUE;
    }, numbers$4.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
  };
  MDCTopAppBarFoundation2.prototype.checkForUpdate = function() {
    var offscreenBoundaryTop = -this.topAppBarHeight;
    var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop < 0;
    var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop > offscreenBoundaryTop;
    var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;
    if (partiallyShowing) {
      this.wasDocked = false;
    } else {
      if (!this.wasDocked) {
        this.wasDocked = true;
        return true;
      } else if (this.isDockedShowing !== hasAnyPixelsOnscreen) {
        this.isDockedShowing = hasAnyPixelsOnscreen;
        return true;
      }
    }
    return partiallyShowing;
  };
  MDCTopAppBarFoundation2.prototype.moveTopAppBar = function() {
    if (this.checkForUpdate()) {
      var offset = this.currentAppBarOffsetTop;
      if (Math.abs(offset) >= this.topAppBarHeight) {
        offset = -numbers$4.MAX_TOP_APP_BAR_HEIGHT;
      }
      this.adapter.setStyle("top", offset + "px");
    }
  };
  MDCTopAppBarFoundation2.prototype.throttledResizeHandler = function() {
    var currentHeight = this.adapter.getTopAppBarHeight();
    if (this.topAppBarHeight !== currentHeight) {
      this.wasDocked = false;
      this.currentAppBarOffsetTop -= this.topAppBarHeight - currentHeight;
      this.topAppBarHeight = currentHeight;
    }
    this.handleTargetScroll();
  };
  return MDCTopAppBarFoundation2;
}(MDCTopAppBarBaseFoundation);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFixedTopAppBarFoundation = function(_super) {
  __extends(MDCFixedTopAppBarFoundation2, _super);
  function MDCFixedTopAppBarFoundation2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.wasScrolled = false;
    return _this;
  }
  MDCFixedTopAppBarFoundation2.prototype.handleTargetScroll = function() {
    var currentScroll = this.adapter.getViewportScrollY();
    if (currentScroll <= 0) {
      if (this.wasScrolled) {
        this.adapter.removeClass(cssClasses$9.FIXED_SCROLLED_CLASS);
        this.wasScrolled = false;
      }
    } else {
      if (!this.wasScrolled) {
        this.adapter.addClass(cssClasses$9.FIXED_SCROLLED_CLASS);
        this.wasScrolled = true;
      }
    }
  };
  return MDCFixedTopAppBarFoundation2;
}(MDCTopAppBarFoundation);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCShortTopAppBarFoundation = function(_super) {
  __extends(MDCShortTopAppBarFoundation2, _super);
  function MDCShortTopAppBarFoundation2(adapter) {
    var _this = _super.call(this, adapter) || this;
    _this.collapsed = false;
    _this.isAlwaysCollapsed = false;
    return _this;
  }
  Object.defineProperty(MDCShortTopAppBarFoundation2.prototype, "isCollapsed", {
    get: function() {
      return this.collapsed;
    },
    enumerable: false,
    configurable: true
  });
  MDCShortTopAppBarFoundation2.prototype.init = function() {
    _super.prototype.init.call(this);
    if (this.adapter.getTotalActionItems() > 0) {
      this.adapter.addClass(cssClasses$9.SHORT_HAS_ACTION_ITEM_CLASS);
    }
    this.setAlwaysCollapsed(this.adapter.hasClass(cssClasses$9.SHORT_COLLAPSED_CLASS));
  };
  MDCShortTopAppBarFoundation2.prototype.setAlwaysCollapsed = function(value) {
    this.isAlwaysCollapsed = !!value;
    if (this.isAlwaysCollapsed) {
      this.collapse();
    } else {
      this.maybeCollapseBar();
    }
  };
  MDCShortTopAppBarFoundation2.prototype.getAlwaysCollapsed = function() {
    return this.isAlwaysCollapsed;
  };
  MDCShortTopAppBarFoundation2.prototype.handleTargetScroll = function() {
    this.maybeCollapseBar();
  };
  MDCShortTopAppBarFoundation2.prototype.maybeCollapseBar = function() {
    if (this.isAlwaysCollapsed) {
      return;
    }
    var currentScroll = this.adapter.getViewportScrollY();
    if (currentScroll <= 0) {
      if (this.collapsed) {
        this.uncollapse();
      }
    } else {
      if (!this.collapsed) {
        this.collapse();
      }
    }
  };
  MDCShortTopAppBarFoundation2.prototype.uncollapse = function() {
    this.adapter.removeClass(cssClasses$9.SHORT_COLLAPSED_CLASS);
    this.collapsed = false;
  };
  MDCShortTopAppBarFoundation2.prototype.collapse = function() {
    this.adapter.addClass(cssClasses$9.SHORT_COLLAPSED_CLASS);
    this.collapsed = true;
  };
  return MDCShortTopAppBarFoundation2;
}(MDCTopAppBarBaseFoundation);
function classMap(classObj) {
  return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
}
function dispatch(element2, eventType, detail, eventInit = { bubbles: true }, duplicateEventForMDC = false) {
  if (typeof Event !== "undefined" && element2) {
    const event = new CustomEvent(eventType, Object.assign(Object.assign({}, eventInit), { detail }));
    element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(event);
    if (duplicateEventForMDC && eventType.startsWith("SMUI")) {
      const duplicateEvent = new CustomEvent(eventType.replace(/^SMUI/g, () => "MDC"), Object.assign(Object.assign({}, eventInit), { detail }));
      element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(duplicateEvent);
      if (duplicateEvent.defaultPrevented) {
        event.preventDefault();
      }
    }
    return event;
  }
}
function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    const cashIndex = name.indexOf("$");
    if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
      continue;
    }
    if (keys.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }
  return newObj;
}
const oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
const newModifierRegex = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
function forwardEventsBuilder(component) {
  let $on;
  let events2 = [];
  component.$on = (fullEventType, callback) => {
    let eventType = fullEventType;
    let destructor = () => {
    };
    if ($on) {
      destructor = $on(eventType, callback);
    } else {
      events2.push([eventType, callback]);
    }
    const oldModifierMatch = eventType.match(oldModifierRegex);
    if (oldModifierMatch && console) {
      console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
    }
    return () => {
      destructor();
    };
  };
  function forward(e) {
    bubble(component, e);
  }
  return (node) => {
    const destructors = [];
    const forwardDestructors = {};
    $on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let handler = callback;
      let options = false;
      const oldModifierMatch = eventType.match(oldModifierRegex);
      const newModifierMatch = eventType.match(newModifierRegex);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (eventType.match(/^SMUI:\w+:/)) {
        const newEventTypeParts = eventType.split(":");
        let newEventType = "";
        for (let i = 0; i < newEventTypeParts.length; i++) {
          newEventType += i === newEventTypeParts.length - 1 ? ":" + newEventTypeParts[i] : newEventTypeParts[i].split("-").map((value) => value.slice(0, 1).toUpperCase() + value.slice(1)).join("");
        }
        console.warn(`The event ${eventType.split("$")[0]} has been renamed to ${newEventType.split("$")[0]}.`);
        eventType = newEventType;
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
        const eventOptions = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
        if (eventOptions.passive) {
          options = options || {};
          options.passive = true;
        }
        if (eventOptions.nonpassive) {
          options = options || {};
          options.passive = false;
        }
        if (eventOptions.capture) {
          options = options || {};
          options.capture = true;
        }
        if (eventOptions.once) {
          options = options || {};
          options.once = true;
        }
        if (eventOptions.preventDefault) {
          handler = prevent_default(handler);
        }
        if (eventOptions.stopPropagation) {
          handler = stop_propagation(handler);
        }
      }
      const off = listen(node, eventType, handler, options);
      const destructor = () => {
        off();
        const idx = destructors.indexOf(destructor);
        if (idx > -1) {
          destructors.splice(idx, 1);
        }
      };
      destructors.push(destructor);
      if (!(eventType in forwardDestructors)) {
        forwardDestructors[eventType] = listen(node, eventType, forward);
      }
      return destructor;
    };
    for (let i = 0; i < events2.length; i++) {
      $on(events2[i][0], events2[i][1]);
    }
    return {
      destroy: () => {
        for (let i = 0; i < destructors.length; i++) {
          destructors[i]();
        }
        for (let entry of Object.entries(forwardDestructors)) {
          entry[1]();
        }
      }
    };
  };
}
function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }
  return newObj;
}
function useActions(node, actions) {
  let actionReturns = [];
  if (actions) {
    for (let i = 0; i < actions.length; i++) {
      const actionEntry = actions[i];
      const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
      if (Array.isArray(actionEntry) && actionEntry.length > 1) {
        actionReturns.push(action(node, actionEntry[1]));
      } else {
        actionReturns.push(action(node));
      }
    }
  }
  return {
    update(actions2) {
      if ((actions2 && actions2.length || 0) != actionReturns.length) {
        throw new Error("You must not change the length of an actions array.");
      }
      if (actions2) {
        for (let i = 0; i < actions2.length; i++) {
          const returnEntry = actionReturns[i];
          if (returnEntry && returnEntry.update) {
            const actionEntry = actions2[i];
            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
              returnEntry.update(actionEntry[1]);
            } else {
              returnEntry.update();
            }
          }
        }
      }
    },
    destroy() {
      for (let i = 0; i < actionReturns.length; i++) {
        const returnEntry = actionReturns[i];
        if (returnEntry && returnEntry.destroy) {
          returnEntry.destroy();
        }
      }
    }
  };
}
const { window: window_1$1 } = globals;
function create_fragment$I(ctx) {
  let header;
  let header_class_value;
  let header_style_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let header_levels = [
    {
      class: header_class_value = classMap(__spreadValues({
        [ctx[2]]: true,
        "mdc-top-app-bar": true,
        "mdc-top-app-bar--short": ctx[4] === "short",
        "mdc-top-app-bar--short-collapsed": ctx[0],
        "mdc-top-app-bar--fixed": ctx[4] === "fixed",
        "smui-top-app-bar--static": ctx[4] === "static",
        "smui-top-app-bar--color-secondary": ctx[5] === "secondary",
        "mdc-top-app-bar--prominent": ctx[6],
        "mdc-top-app-bar--dense": ctx[7]
      }, ctx[11]))
    },
    {
      style: header_style_value = Object.entries(ctx[12]).map(func$8).concat([ctx[3]]).join(" ")
    },
    ctx[15]
  ];
  let header_data = {};
  for (let i = 0; i < header_levels.length; i += 1) {
    header_data = assign(header_data, header_levels[i]);
  }
  return {
    c() {
      header = element("header");
      if (default_slot)
        default_slot.c();
      set_attributes(header, header_data);
    },
    m(target, anchor) {
      insert(target, header, anchor);
      if (default_slot) {
        default_slot.m(header, null);
      }
      ctx[25](header);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window_1$1, "resize", ctx[23]),
          listen(window_1$1, "scroll", ctx[24]),
          action_destroyer(useActions_action = useActions.call(null, header, ctx[1])),
          action_destroyer(ctx[13].call(null, header)),
          listen(header, "SMUITopAppBarIconButton:nav", ctx[26])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 2097152)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
        }
      }
      set_attributes(header, header_data = get_spread_update(header_levels, [
        (!current || dirty[0] & 2293 && header_class_value !== (header_class_value = classMap(__spreadValues({
          [ctx2[2]]: true,
          "mdc-top-app-bar": true,
          "mdc-top-app-bar--short": ctx2[4] === "short",
          "mdc-top-app-bar--short-collapsed": ctx2[0],
          "mdc-top-app-bar--fixed": ctx2[4] === "fixed",
          "smui-top-app-bar--static": ctx2[4] === "static",
          "smui-top-app-bar--color-secondary": ctx2[5] === "secondary",
          "mdc-top-app-bar--prominent": ctx2[6],
          "mdc-top-app-bar--dense": ctx2[7]
        }, ctx2[11])))) && { class: header_class_value },
        (!current || dirty[0] & 4104 && header_style_value !== (header_style_value = Object.entries(ctx2[12]).map(func$8).concat([ctx2[3]]).join(" "))) && { style: header_style_value },
        dirty[0] & 32768 && ctx2[15]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 2)
        useActions_action.update.call(null, ctx2[1]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      if (default_slot)
        default_slot.d(detaching);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const func$8 = ([name, value]) => `${name}: ${value};`;
function instance_1$9($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "variant",
    "color",
    "collapsed",
    "prominent",
    "dense",
    "scrollTarget",
    "getPropStore",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { variant = "standard" } = $$props;
  let { color = "primary" } = $$props;
  let { collapsed = uninitializedValue } = $$props;
  const alwaysCollapsed = !isUninitializedValue(collapsed) && !!collapsed;
  if (isUninitializedValue(collapsed)) {
    collapsed = false;
  }
  let { prominent = false } = $$props;
  let { dense = false } = $$props;
  let { scrollTarget = void 0 } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let propStoreSet;
  let propStore = readable({ variant, prominent, dense }, (set) => {
    $$invalidate(18, propStoreSet = set);
  });
  let oldScrollTarget = void 0;
  let oldVariant = variant;
  onMount(() => {
    $$invalidate(9, instance2 = getInstance());
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  function getInstance() {
    const Foundation = {
      static: MDCTopAppBarBaseFoundation,
      short: MDCShortTopAppBarFoundation,
      fixed: MDCFixedTopAppBarFoundation
    }[variant] || MDCTopAppBarFoundation;
    return new Foundation({
      hasClass,
      addClass,
      removeClass,
      setStyle: addStyle,
      getTopAppBarHeight: () => element2.clientHeight,
      notifyNavigationIconClicked: () => dispatch(element2, "SMUITopAppBar:nav", void 0, void 0, true),
      getViewportScrollY: () => scrollTarget == null ? window.pageYOffset : scrollTarget.scrollTop,
      getTotalActionItems: () => element2.querySelectorAll(".mdc-top-app-bar__action-item").length
    });
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(12, internalStyles), $$invalidate(20, oldVariant), $$invalidate(4, variant), $$invalidate(9, instance2);
      } else {
        $$invalidate(12, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function handleTargetScroll() {
    if (instance2) {
      instance2.handleTargetScroll();
      if (variant === "short") {
        $$invalidate(0, collapsed = "isCollapsed" in instance2 && instance2.isCollapsed);
      }
    }
  }
  function getPropStore() {
    return propStore;
  }
  function getElement() {
    return element2;
  }
  const resize_handler = () => variant !== "short" && variant !== "fixed" && instance2 && instance2.handleWindowResize();
  const scroll_handler = () => scrollTarget == null && handleTargetScroll();
  function header_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(10, element2);
    });
  }
  const SMUITopAppBarIconButton_nav_handler = () => instance2 && instance2.handleNavigationClick();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(3, style = $$new_props.style);
    if ("variant" in $$new_props)
      $$invalidate(4, variant = $$new_props.variant);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("collapsed" in $$new_props)
      $$invalidate(0, collapsed = $$new_props.collapsed);
    if ("prominent" in $$new_props)
      $$invalidate(6, prominent = $$new_props.prominent);
    if ("dense" in $$new_props)
      $$invalidate(7, dense = $$new_props.dense);
    if ("scrollTarget" in $$new_props)
      $$invalidate(8, scrollTarget = $$new_props.scrollTarget);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 262352) {
      if (propStoreSet) {
        propStoreSet({ variant, prominent, dense });
      }
    }
    if ($$self.$$.dirty[0] & 1049104) {
      if (oldVariant !== variant && instance2) {
        $$invalidate(20, oldVariant = variant);
        instance2.destroy();
        $$invalidate(11, internalClasses = {});
        $$invalidate(12, internalStyles = {});
        $$invalidate(9, instance2 = getInstance());
        instance2.init();
      }
    }
    if ($$self.$$.dirty[0] & 528) {
      if (instance2 && variant === "short" && "setAlwaysCollapsed" in instance2) {
        instance2.setAlwaysCollapsed(alwaysCollapsed);
      }
    }
    if ($$self.$$.dirty[0] & 524544) {
      if (oldScrollTarget !== scrollTarget) {
        if (oldScrollTarget) {
          oldScrollTarget.removeEventListener("scroll", handleTargetScroll);
        }
        if (scrollTarget) {
          scrollTarget.addEventListener("scroll", handleTargetScroll);
        }
        $$invalidate(19, oldScrollTarget = scrollTarget);
      }
    }
  };
  return [
    collapsed,
    use,
    className,
    style,
    variant,
    color,
    prominent,
    dense,
    scrollTarget,
    instance2,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    handleTargetScroll,
    $$restProps,
    getPropStore,
    getElement,
    propStoreSet,
    oldScrollTarget,
    oldVariant,
    $$scope,
    slots,
    resize_handler,
    scroll_handler,
    header_binding,
    SMUITopAppBarIconButton_nav_handler
  ];
}
class TopAppBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$9, create_fragment$I, safe_not_equal, {
      use: 1,
      class: 2,
      style: 3,
      variant: 4,
      color: 5,
      collapsed: 0,
      prominent: 6,
      dense: 7,
      scrollTarget: 8,
      getPropStore: 16,
      getElement: 17
    }, null, [-1, -1]);
  }
  get getPropStore() {
    return this.$$.ctx[16];
  }
  get getElement() {
    return this.$$.ctx[17];
  }
}
function create_fragment$H(ctx) {
  let div;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [ctx[3]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(ctx[2].call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    div_binding
  ];
}
class Div$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$H, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_default_slot$d(ctx) {
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$G(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [ctx[7], ...ctx[0]]
    },
    {
      class: classMap(__spreadValues({
        [ctx[1]]: true,
        [ctx[5]]: true
      }, ctx[4]))
    },
    ctx[6],
    ctx[8]
  ];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    ctx[11](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 499 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 129 && {
          use: [ctx2[7], ...ctx2[0]]
        },
        dirty & 50 && {
          class: classMap(__spreadValues({
            [ctx2[1]]: true,
            [ctx2[5]]: true
          }, ctx2[4]))
        },
        dirty & 64 && get_spread_object(ctx2[6]),
        dirty & 256 && get_spread_object(ctx2[8])
      ]) : {};
      if (dirty & 4096) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          ctx2[11](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[11](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
const internals = {
  component: Div$1,
  class: "",
  classMap: {},
  contexts: {},
  props: {}
};
function instance$w($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "component", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  const smuiClass = internals.class;
  const smuiClassMap = {};
  const smuiClassUnsubscribes = [];
  const contexts = internals.contexts;
  const props = internals.props;
  let { component = internals.component } = $$props;
  Object.entries(internals.classMap).forEach(([name, context]) => {
    const store = getContext(context);
    if (store && "subscribe" in store) {
      smuiClassUnsubscribes.push(store.subscribe((value) => {
        $$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
      }));
    }
  });
  const forwardEvents = forwardEventsBuilder(get_current_component());
  for (let context in contexts) {
    if (contexts.hasOwnProperty(context)) {
      setContext(context, contexts[context]);
    }
  }
  onDestroy(() => {
    for (const unsubscribe of smuiClassUnsubscribes) {
      unsubscribe();
    }
  });
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(3, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("component" in $$new_props)
      $$invalidate(2, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    className,
    component,
    element2,
    smuiClassMap,
    smuiClass,
    props,
    forwardEvents,
    $$restProps,
    getElement,
    slots,
    switch_instance_binding,
    $$scope
  ];
}
class ClassAdder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$G, safe_not_equal, {
      use: 0,
      class: 1,
      component: 2,
      getElement: 9
    });
  }
  get getElement() {
    return this.$$.ctx[9];
  }
}
const defaults = Object.assign({}, internals);
function classAdderBuilder(props) {
  return new Proxy(ClassAdder, {
    construct: function(target, args) {
      Object.assign(internals, defaults, props);
      return new target(...args);
    },
    get: function(target, prop) {
      Object.assign(internals, defaults, props);
      return target[prop];
    }
  });
}
function create_fragment$F(ctx) {
  let a;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let a_levels = [{ href: ctx[1] }, ctx[4]];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[8](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, a, ctx[0])),
          action_destroyer(ctx[3].call(null, a))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 2) && { href: ctx2[1] },
        dirty & 16 && ctx2[4]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (default_slot)
        default_slot.d(detaching);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "href", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  let { href = "javascript:void(0);" } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    href,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    a_binding
  ];
}
class A$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$F, safe_not_equal, { use: 0, href: 1, getElement: 5 });
  }
  get getElement() {
    return this.$$.ctx[5];
  }
}
function create_fragment$E(ctx) {
  let button;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let button_levels = [ctx[3]];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      set_attributes(button, button_data);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, button, ctx[0])),
          action_destroyer(ctx[2].call(null, button))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    button_binding
  ];
}
class Button$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$E, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$D(ctx) {
  let h1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let h1_levels = [ctx[3]];
  let h1_data = {};
  for (let i = 0; i < h1_levels.length; i += 1) {
    h1_data = assign(h1_data, h1_levels[i]);
  }
  return {
    c() {
      h1 = element("h1");
      if (default_slot)
        default_slot.c();
      set_attributes(h1, h1_data);
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      if (default_slot) {
        default_slot.m(h1, null);
      }
      ctx[7](h1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, h1, ctx[0])),
          action_destroyer(ctx[2].call(null, h1))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(h1, h1_data = get_spread_update(h1_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function h1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    h1_binding
  ];
}
class H1$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$D, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$C(ctx) {
  let h2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let h2_levels = [ctx[3]];
  let h2_data = {};
  for (let i = 0; i < h2_levels.length; i += 1) {
    h2_data = assign(h2_data, h2_levels[i]);
  }
  return {
    c() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      set_attributes(h2, h2_data);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      ctx[7](h2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, h2, ctx[0])),
          action_destroyer(ctx[2].call(null, h2))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(h2, h2_data = get_spread_update(h2_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h2);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function h2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    h2_binding
  ];
}
class H2$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$C, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$B(ctx) {
  let h3;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let h3_levels = [ctx[3]];
  let h3_data = {};
  for (let i = 0; i < h3_levels.length; i += 1) {
    h3_data = assign(h3_data, h3_levels[i]);
  }
  return {
    c() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      set_attributes(h3, h3_data);
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      ctx[7](h3);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, h3, ctx[0])),
          action_destroyer(ctx[2].call(null, h3))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(h3, h3_data = get_spread_update(h3_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function h3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    h3_binding
  ];
}
class H3$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$B, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$A(ctx) {
  let hr;
  let useActions_action;
  let t;
  let current;
  let mounted;
  let dispose;
  let hr_levels = [ctx[3]];
  let hr_data = {};
  for (let i = 0; i < hr_levels.length; i += 1) {
    hr_data = assign(hr_data, hr_levels[i]);
  }
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      hr = element("hr");
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(hr, hr_data);
    },
    m(target, anchor) {
      insert(target, hr, anchor);
      ctx[7](hr);
      insert(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, hr, ctx[0])),
          action_destroyer(ctx[2].call(null, hr))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(hr, hr_data = get_spread_update(hr_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(hr);
      ctx[7](null);
      if (detaching)
        detach(t);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function hr_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    hr_binding
  ];
}
class Hr$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$A, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$z(ctx) {
  let li;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let li_levels = [ctx[3]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  return {
    c() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[7](li);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, li, ctx[0])),
          action_destroyer(ctx[2].call(null, li))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    li_binding
  ];
}
class Li$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$z, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$y(ctx) {
  let nav;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let nav_levels = [ctx[3]];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  return {
    c() {
      nav = element("nav");
      if (default_slot)
        default_slot.c();
      set_attributes(nav, nav_data);
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      if (default_slot) {
        default_slot.m(nav, null);
      }
      ctx[7](nav);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, nav, ctx[0])),
          action_destroyer(ctx[2].call(null, nav))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(nav);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function nav_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    nav_binding
  ];
}
class Nav$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$y, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$x(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let span_levels = [ctx[3]];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[7](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, span, ctx[0])),
          action_destroyer(ctx[2].call(null, span))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    span_binding
  ];
}
class Span$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$x, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_fragment$w(ctx) {
  let ul;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let ul_levels = [ctx[3]];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[7](ul);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, ul, ctx[0])),
          action_destroyer(ctx[2].call(null, ul))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 8 && ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    ul_binding
  ];
}
class Ul$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$w, safe_not_equal, { use: 0, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
const A = A$1;
const Button = Button$1;
const Div = Div$1;
const H1 = H1$1;
const H2 = H2$1;
const H3 = H3$1;
const Hr = Hr$1;
const Li = Li$1;
const Nav = Nav$1;
const Span = Span$1;
const Ul = Ul$1;
var Row = classAdderBuilder({
  class: "mdc-top-app-bar__row",
  component: Div
});
function create_fragment$v(ctx) {
  let section;
  let section_class_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let section_levels = [
    {
      class: section_class_value = classMap({
        [ctx[1]]: true,
        "mdc-top-app-bar__section": true,
        "mdc-top-app-bar__section--align-start": ctx[2] === "start",
        "mdc-top-app-bar__section--align-end": ctx[2] === "end"
      })
    },
    ctx[3] ? { role: "toolbar" } : {},
    ctx[6]
  ];
  let section_data = {};
  for (let i = 0; i < section_levels.length; i += 1) {
    section_data = assign(section_data, section_levels[i]);
  }
  return {
    c() {
      section = element("section");
      if (default_slot)
        default_slot.c();
      set_attributes(section, section_data);
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[10](section);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, section, ctx[0])),
          action_destroyer(ctx[5].call(null, section))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null), null);
        }
      }
      set_attributes(section, section_data = get_spread_update(section_levels, [
        (!current || dirty & 6 && section_class_value !== (section_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-top-app-bar__section": true,
          "mdc-top-app-bar__section--align-start": ctx2[2] === "start",
          "mdc-top-app-bar__section--align-end": ctx2[2] === "end"
        }))) && { class: section_class_value },
        dirty & 8 && (ctx2[3] ? { role: "toolbar" } : {}),
        dirty & 64 && ctx2[6]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "align", "toolbar", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { align = "start" } = $$props;
  let { toolbar = false } = $$props;
  let element2;
  setContext("SMUI:icon-button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
  setContext("SMUI:button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
  function getElement() {
    return element2;
  }
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("align" in $$new_props)
      $$invalidate(2, align = $$new_props.align);
    if ("toolbar" in $$new_props)
      $$invalidate(3, toolbar = $$new_props.toolbar);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    className,
    align,
    toolbar,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    section_binding
  ];
}
class Section$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$v, safe_not_equal, {
      use: 0,
      class: 1,
      align: 2,
      toolbar: 3,
      getElement: 7
    });
  }
  get getElement() {
    return this.$$.ctx[7];
  }
}
var Title$1 = classAdderBuilder({
  class: "mdc-top-app-bar__title",
  component: Span
});
const Section = Section$1;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$8 = {
  ICON_BUTTON_ON: "mdc-icon-button--on",
  ROOT: "mdc-icon-button"
};
var strings$6 = {
  ARIA_LABEL: "aria-label",
  ARIA_PRESSED: "aria-pressed",
  DATA_ARIA_LABEL_OFF: "data-aria-label-off",
  DATA_ARIA_LABEL_ON: "data-aria-label-on",
  CHANGE_EVENT: "MDCIconButtonToggle:change"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCIconButtonToggleFoundation = function(_super) {
  __extends(MDCIconButtonToggleFoundation2, _super);
  function MDCIconButtonToggleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCIconButtonToggleFoundation2.defaultAdapter), adapter)) || this;
    _this.hasToggledAriaLabel = false;
    return _this;
  }
  Object.defineProperty(MDCIconButtonToggleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$8;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCIconButtonToggleFoundation2, "strings", {
    get: function() {
      return strings$6;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCIconButtonToggleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        notifyChange: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        getAttr: function() {
          return null;
        },
        setAttr: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCIconButtonToggleFoundation2.prototype.init = function() {
    var ariaLabelOn = this.adapter.getAttr(strings$6.DATA_ARIA_LABEL_ON);
    var ariaLabelOff = this.adapter.getAttr(strings$6.DATA_ARIA_LABEL_OFF);
    if (ariaLabelOn && ariaLabelOff) {
      if (this.adapter.getAttr(strings$6.ARIA_PRESSED) !== null) {
        throw new Error("MDCIconButtonToggleFoundation: Button should not set `aria-pressed` if it has a toggled aria label.");
      }
      this.hasToggledAriaLabel = true;
    } else {
      this.adapter.setAttr(strings$6.ARIA_PRESSED, String(this.isOn()));
    }
  };
  MDCIconButtonToggleFoundation2.prototype.handleClick = function() {
    this.toggle();
    this.adapter.notifyChange({ isOn: this.isOn() });
  };
  MDCIconButtonToggleFoundation2.prototype.isOn = function() {
    return this.adapter.hasClass(cssClasses$8.ICON_BUTTON_ON);
  };
  MDCIconButtonToggleFoundation2.prototype.toggle = function(isOn) {
    if (isOn === void 0) {
      isOn = !this.isOn();
    }
    if (isOn) {
      this.adapter.addClass(cssClasses$8.ICON_BUTTON_ON);
    } else {
      this.adapter.removeClass(cssClasses$8.ICON_BUTTON_ON);
    }
    if (this.hasToggledAriaLabel) {
      var ariaLabel = isOn ? this.adapter.getAttr(strings$6.DATA_ARIA_LABEL_ON) : this.adapter.getAttr(strings$6.DATA_ARIA_LABEL_OFF);
      this.adapter.setAttr(strings$6.ARIA_LABEL, ariaLabel || "");
    } else {
      this.adapter.setAttr(strings$6.ARIA_PRESSED, "" + isOn);
    }
  };
  return MDCIconButtonToggleFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var FOCUS_SENTINEL_CLASS = "mdc-dom-focus-sentinel";
var FocusTrap = function() {
  function FocusTrap2(root, options) {
    if (options === void 0) {
      options = {};
    }
    this.root = root;
    this.options = options;
    this.elFocusedBeforeTrapFocus = null;
  }
  FocusTrap2.prototype.trapFocus = function() {
    var focusableEls = this.getFocusableElements(this.root);
    if (focusableEls.length === 0) {
      throw new Error("FocusTrap: Element must have at least one focusable child.");
    }
    this.elFocusedBeforeTrapFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    this.wrapTabFocus(this.root);
    if (!this.options.skipInitialFocus) {
      this.focusInitialElement(focusableEls, this.options.initialFocusEl);
    }
  };
  FocusTrap2.prototype.releaseFocus = function() {
    [].slice.call(this.root.querySelectorAll("." + FOCUS_SENTINEL_CLASS)).forEach(function(sentinelEl) {
      sentinelEl.parentElement.removeChild(sentinelEl);
    });
    if (!this.options.skipRestoreFocus && this.elFocusedBeforeTrapFocus) {
      this.elFocusedBeforeTrapFocus.focus();
    }
  };
  FocusTrap2.prototype.wrapTabFocus = function(el) {
    var _this = this;
    var sentinelStart = this.createSentinel();
    var sentinelEnd = this.createSentinel();
    sentinelStart.addEventListener("focus", function() {
      var focusableEls = _this.getFocusableElements(el);
      if (focusableEls.length > 0) {
        focusableEls[focusableEls.length - 1].focus();
      }
    });
    sentinelEnd.addEventListener("focus", function() {
      var focusableEls = _this.getFocusableElements(el);
      if (focusableEls.length > 0) {
        focusableEls[0].focus();
      }
    });
    el.insertBefore(sentinelStart, el.children[0]);
    el.appendChild(sentinelEnd);
  };
  FocusTrap2.prototype.focusInitialElement = function(focusableEls, initialFocusEl) {
    var focusIndex = 0;
    if (initialFocusEl) {
      focusIndex = Math.max(focusableEls.indexOf(initialFocusEl), 0);
    }
    focusableEls[focusIndex].focus();
  };
  FocusTrap2.prototype.getFocusableElements = function(root) {
    var focusableEls = [].slice.call(root.querySelectorAll("[autofocus], [tabindex], a, input, textarea, select, button"));
    return focusableEls.filter(function(el) {
      var isDisabledOrHidden = el.getAttribute("aria-disabled") === "true" || el.getAttribute("disabled") != null || el.getAttribute("hidden") != null || el.getAttribute("aria-hidden") === "true";
      var isTabbableAndVisible = el.tabIndex >= 0 && el.getBoundingClientRect().width > 0 && !el.classList.contains(FOCUS_SENTINEL_CLASS) && !isDisabledOrHidden;
      var isProgrammaticallyHidden = false;
      if (isTabbableAndVisible) {
        var style = getComputedStyle(el);
        isProgrammaticallyHidden = style.display === "none" || style.visibility === "hidden";
      }
      return isTabbableAndVisible && !isProgrammaticallyHidden;
    });
  };
  FocusTrap2.prototype.createSentinel = function() {
    var sentinel = document.createElement("div");
    sentinel.setAttribute("tabindex", "0");
    sentinel.setAttribute("aria-hidden", "true");
    sentinel.classList.add(FOCUS_SENTINEL_CLASS);
    return sentinel;
  };
  return FocusTrap2;
}();
var domFocusTrap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FocusTrap
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var KEY = {
  UNKNOWN: "Unknown",
  BACKSPACE: "Backspace",
  ENTER: "Enter",
  SPACEBAR: "Spacebar",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  END: "End",
  HOME: "Home",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  DELETE: "Delete",
  ESCAPE: "Escape",
  TAB: "Tab"
};
var normalizedKeys = /* @__PURE__ */ new Set();
normalizedKeys.add(KEY.BACKSPACE);
normalizedKeys.add(KEY.ENTER);
normalizedKeys.add(KEY.SPACEBAR);
normalizedKeys.add(KEY.PAGE_UP);
normalizedKeys.add(KEY.PAGE_DOWN);
normalizedKeys.add(KEY.END);
normalizedKeys.add(KEY.HOME);
normalizedKeys.add(KEY.ARROW_LEFT);
normalizedKeys.add(KEY.ARROW_UP);
normalizedKeys.add(KEY.ARROW_RIGHT);
normalizedKeys.add(KEY.ARROW_DOWN);
normalizedKeys.add(KEY.DELETE);
normalizedKeys.add(KEY.ESCAPE);
normalizedKeys.add(KEY.TAB);
var KEY_CODE = {
  BACKSPACE: 8,
  ENTER: 13,
  SPACEBAR: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  DELETE: 46,
  ESCAPE: 27,
  TAB: 9
};
var mappedKeyCodes = /* @__PURE__ */ new Map();
mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
mappedKeyCodes.set(KEY_CODE.END, KEY.END);
mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
var navigationKeys = /* @__PURE__ */ new Set();
navigationKeys.add(KEY.PAGE_UP);
navigationKeys.add(KEY.PAGE_DOWN);
navigationKeys.add(KEY.END);
navigationKeys.add(KEY.HOME);
navigationKeys.add(KEY.ARROW_LEFT);
navigationKeys.add(KEY.ARROW_UP);
navigationKeys.add(KEY.ARROW_RIGHT);
navigationKeys.add(KEY.ARROW_DOWN);
function normalizeKey(evt) {
  var key = evt.key;
  if (normalizedKeys.has(key)) {
    return key;
  }
  var mappedKey = mappedKeyCodes.get(evt.keyCode);
  if (mappedKey) {
    return mappedKey;
  }
  return KEY.UNKNOWN;
}
const { applyPassive } = events;
const { matches } = ponyfill;
function Ripple(node, { ripple = true, surface = false, unbounded = false, disabled = false, color, active: active2, rippleElement, eventTarget, activeTarget, addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className), addStyle = (name, value) => node.style.setProperty(name, value), initPromise = Promise.resolve() } = {}) {
  let instance2;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let oldActive = active2;
  let oldEventTarget = eventTarget;
  let oldActiveTarget = activeTarget;
  function handleProps() {
    if (surface) {
      addClass("mdc-ripple-surface");
      if (color === "primary") {
        addClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      } else if (color === "secondary") {
        removeClass("smui-ripple-surface--primary");
        addClass("smui-ripple-surface--secondary");
      } else {
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
    } else {
      removeClass("mdc-ripple-surface");
      removeClass("smui-ripple-surface--primary");
      removeClass("smui-ripple-surface--secondary");
    }
    if (instance2 && oldActive !== active2) {
      oldActive = active2;
      if (active2) {
        instance2.activate();
      } else if (active2 === false) {
        instance2.deactivate();
      }
    }
    if (ripple && !instance2) {
      instance2 = new MDCRippleFoundation({
        addClass,
        browserSupportsCssVars: () => supportsCssVariables(window),
        computeBoundingRect: () => (rippleElement || node).getBoundingClientRect(),
        containsEventTarget: (target) => node.contains(target),
        deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
        deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
        deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
        getWindowPageOffset: () => ({
          x: window.pageXOffset,
          y: window.pageYOffset
        }),
        isSurfaceActive: () => active2 == null ? matches(activeTarget || node, ":active") : active2,
        isSurfaceDisabled: () => !!disabled,
        isUnbounded: () => !!unbounded,
        registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
        registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
        registerResizeHandler: (handler) => window.addEventListener("resize", handler),
        removeClass,
        updateCssVariable: addStyle
      });
      initPromise.then(() => {
        if (instance2) {
          instance2.init();
          instance2.setUnbounded(unbounded);
        }
      });
    } else if (instance2 && !ripple) {
      initPromise.then(() => {
        if (instance2) {
          instance2.destroy();
          instance2 = void 0;
        }
      });
    }
    if (instance2 && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
      oldEventTarget = eventTarget;
      oldActiveTarget = activeTarget;
      instance2.destroy();
      requestAnimationFrame(() => {
        if (instance2) {
          instance2.init();
          instance2.setUnbounded(unbounded);
        }
      });
    }
    if (!ripple && unbounded) {
      addClass("mdc-ripple-upgraded--unbounded");
    }
  }
  handleProps();
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  function layout() {
    if (instance2) {
      instance2.layout();
    }
  }
  return {
    update(props) {
      ({
        ripple,
        surface,
        unbounded,
        disabled,
        color,
        active: active2,
        rippleElement,
        eventTarget,
        activeTarget,
        addClass,
        removeClass,
        addStyle,
        initPromise
      } = Object.assign({ ripple: true, surface: false, unbounded: false, disabled: false, color: void 0, active: void 0, rippleElement: void 0, eventTarget: void 0, activeTarget: void 0, addClass: (className) => node.classList.add(className), removeClass: (className) => node.classList.remove(className), addStyle: (name, value) => node.style.setProperty(name, value), initPromise: Promise.resolve() }, props));
      handleProps();
    },
    destroy() {
      if (instance2) {
        instance2.destroy();
        instance2 = void 0;
        removeClass("mdc-ripple-surface");
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    }
  };
}
function create_if_block$e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "mdc-icon-button__touch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$c(ctx) {
  let div;
  let t;
  let if_block_anchor;
  let current;
  const default_slot_template = ctx[32].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[36], null);
  let if_block = ctx[8] && create_if_block$e();
  return {
    c() {
      div = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "mdc-icon-button__ripple");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[36], !current ? get_all_dirty_from_scope(ctx2[36]) : get_slot_changes(default_slot_template, ctx2[36], dirty, null), null);
        }
      }
      if (ctx2[8]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$e();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$u(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        [
          Ripple,
          {
            ripple: ctx[4],
            unbounded: true,
            color: ctx[5],
            disabled: !!ctx[28].disabled,
            addClass: ctx[25],
            removeClass: ctx[26],
            addStyle: ctx[27]
          }
        ],
        ctx[21],
        ...ctx[1]
      ]
    },
    {
      class: classMap(__spreadValues({
        [ctx[2]]: true,
        "mdc-icon-button": true,
        "mdc-icon-button--on": !ctx[22](ctx[0]) && ctx[0],
        "mdc-icon-button--touch": ctx[8],
        "mdc-icon-button--display-flex": ctx[9],
        "smui-icon-button--size-button": ctx[10] === "button",
        "mdc-icon-button--reduced-size": ctx[10] === "mini" || ctx[10] === "button",
        "mdc-card__action": ctx[23] === "card:action",
        "mdc-card__action--icon": ctx[23] === "card:action",
        "mdc-top-app-bar__navigation-icon": ctx[23] === "top-app-bar:navigation",
        "mdc-top-app-bar__action-item": ctx[23] === "top-app-bar:action",
        "mdc-snackbar__dismiss": ctx[23] === "snackbar:actions",
        "mdc-data-table__pagination-button": ctx[23] === "data-table:pagination",
        "mdc-data-table__sort-icon-button": ctx[23] === "data-table:sortable-header-cell",
        "mdc-dialog__close": ctx[23] === "dialog:header" && ctx[12] === "close"
      }, ctx[17]))
    },
    {
      style: Object.entries(ctx[18]).map(func$7).concat([ctx[3]]).join(" ")
    },
    {
      "aria-pressed": !ctx[22](ctx[0]) ? ctx[0] ? "true" : "false" : null
    },
    {
      "aria-label": ctx[0] ? ctx[6] : ctx[7]
    },
    {
      "data-aria-label-on": ctx[6]
    },
    {
      "data-aria-label-off": ctx[7]
    },
    {
      "aria-describedby": ctx[24]
    },
    { href: ctx[11] },
    ctx[20],
    ctx[19],
    ctx[28]
  ];
  var switch_value = ctx[13];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    ctx[33](switch_instance);
    switch_instance.$on("click", ctx[34]);
    switch_instance.$on("click", ctx[35]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & 536748031 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & 505413682 && {
          use: [
            [
              Ripple,
              {
                ripple: ctx2[4],
                unbounded: true,
                color: ctx2[5],
                disabled: !!ctx2[28].disabled,
                addClass: ctx2[25],
                removeClass: ctx2[26],
                addStyle: ctx2[27]
              }
            ],
            ctx2[21],
            ...ctx2[1]
          ]
        },
        dirty[0] & 12719877 && {
          class: classMap(__spreadValues({
            [ctx2[2]]: true,
            "mdc-icon-button": true,
            "mdc-icon-button--on": !ctx2[22](ctx2[0]) && ctx2[0],
            "mdc-icon-button--touch": ctx2[8],
            "mdc-icon-button--display-flex": ctx2[9],
            "smui-icon-button--size-button": ctx2[10] === "button",
            "mdc-icon-button--reduced-size": ctx2[10] === "mini" || ctx2[10] === "button",
            "mdc-card__action": ctx2[23] === "card:action",
            "mdc-card__action--icon": ctx2[23] === "card:action",
            "mdc-top-app-bar__navigation-icon": ctx2[23] === "top-app-bar:navigation",
            "mdc-top-app-bar__action-item": ctx2[23] === "top-app-bar:action",
            "mdc-snackbar__dismiss": ctx2[23] === "snackbar:actions",
            "mdc-data-table__pagination-button": ctx2[23] === "data-table:pagination",
            "mdc-data-table__sort-icon-button": ctx2[23] === "data-table:sortable-header-cell",
            "mdc-dialog__close": ctx2[23] === "dialog:header" && ctx2[12] === "close"
          }, ctx2[17]))
        },
        dirty[0] & 262152 && {
          style: Object.entries(ctx2[18]).map(func$7).concat([ctx2[3]]).join(" ")
        },
        dirty[0] & 4194305 && {
          "aria-pressed": !ctx2[22](ctx2[0]) ? ctx2[0] ? "true" : "false" : null
        },
        dirty[0] & 193 && {
          "aria-label": ctx2[0] ? ctx2[6] : ctx2[7]
        },
        dirty[0] & 64 && {
          "data-aria-label-on": ctx2[6]
        },
        dirty[0] & 128 && {
          "data-aria-label-off": ctx2[7]
        },
        dirty[0] & 16777216 && {
          "aria-describedby": ctx2[24]
        },
        dirty[0] & 2048 && { href: ctx2[11] },
        dirty[0] & 1048576 && get_spread_object(ctx2[20]),
        dirty[0] & 524288 && get_spread_object(ctx2[19]),
        dirty[0] & 268435456 && get_spread_object(ctx2[28])
      ]) : {};
      if (dirty[0] & 256 | dirty[1] & 32) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[13])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          ctx2[33](switch_instance);
          switch_instance.$on("click", ctx2[34]);
          switch_instance.$on("click", ctx2[35]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[33](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
const func$7 = ([name, value]) => `${name}: ${value};`;
function instance_1$8($$self, $$props, $$invalidate) {
  let actionProp;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "color",
    "toggle",
    "pressed",
    "ariaLabelOn",
    "ariaLabelOff",
    "touch",
    "displayFlex",
    "size",
    "href",
    "action",
    "component",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { color = void 0 } = $$props;
  let { toggle = false } = $$props;
  let { pressed = uninitializedValue } = $$props;
  let { ariaLabelOn = void 0 } = $$props;
  let { ariaLabelOff = void 0 } = $$props;
  let { touch = false } = $$props;
  let { displayFlex = true } = $$props;
  let { size = "normal" } = $$props;
  let { href = void 0 } = $$props;
  let { action = void 0 } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let context = getContext("SMUI:icon-button:context");
  let ariaDescribedby = getContext("SMUI:icon-button:aria-describedby");
  let { component = href == null ? Button : A } = $$props;
  let previousDisabled = $$restProps.disabled;
  setContext("SMUI:icon:context", "icon-button");
  let oldToggle = null;
  onDestroy(() => {
    instance2 && instance2.destroy();
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(17, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(17, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(18, internalStyles);
      } else {
        $$invalidate(18, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getAttr(name) {
    var _a2;
    return name in internalAttrs ? (_a2 = internalAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(19, internalAttrs[name] = value, internalAttrs);
    }
  }
  function handleChange(evtData) {
    $$invalidate(0, pressed = evtData.isOn);
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(15, element2);
    });
  }
  const click_handler = () => instance2 && instance2.handleClick();
  const click_handler_1 = () => context === "top-app-bar:navigation" && dispatch(getElement(), "SMUITopAppBarIconButton:nav");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(3, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(4, ripple = $$new_props.ripple);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("toggle" in $$new_props)
      $$invalidate(29, toggle = $$new_props.toggle);
    if ("pressed" in $$new_props)
      $$invalidate(0, pressed = $$new_props.pressed);
    if ("ariaLabelOn" in $$new_props)
      $$invalidate(6, ariaLabelOn = $$new_props.ariaLabelOn);
    if ("ariaLabelOff" in $$new_props)
      $$invalidate(7, ariaLabelOff = $$new_props.ariaLabelOff);
    if ("touch" in $$new_props)
      $$invalidate(8, touch = $$new_props.touch);
    if ("displayFlex" in $$new_props)
      $$invalidate(9, displayFlex = $$new_props.displayFlex);
    if ("size" in $$new_props)
      $$invalidate(10, size = $$new_props.size);
    if ("href" in $$new_props)
      $$invalidate(11, href = $$new_props.href);
    if ("action" in $$new_props)
      $$invalidate(12, action = $$new_props.action);
    if ("component" in $$new_props)
      $$invalidate(13, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(36, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4096) {
      $$invalidate(20, actionProp = (() => {
        if (context === "data-table:pagination") {
          switch (action) {
            case "first-page":
              return { "data-first-page": "true" };
            case "prev-page":
              return { "data-prev-page": "true" };
            case "next-page":
              return { "data-next-page": "true" };
            case "last-page":
              return { "data-last-page": "true" };
            default:
              return { "data-action": "true" };
          }
        } else if (context === "dialog:header") {
          return { "data-mdc-dialog-action": action };
        } else {
          return { action };
        }
      })());
    }
    if (previousDisabled !== $$restProps.disabled) {
      const elem = getElement();
      if ("blur" in elem) {
        elem.blur();
      }
      $$invalidate(30, previousDisabled = $$restProps.disabled);
    }
    if ($$self.$$.dirty[0] & 536969216 | $$self.$$.dirty[1] & 1) {
      if (element2 && getElement() && toggle !== oldToggle) {
        if (toggle && !instance2) {
          $$invalidate(16, instance2 = new MDCIconButtonToggleFoundation({
            addClass,
            hasClass,
            notifyChange: (evtData) => {
              handleChange(evtData);
              dispatch(getElement(), "SMUIIconButtonToggle:change", evtData, void 0, true);
            },
            removeClass,
            getAttr,
            setAttr: addAttr
          }));
          instance2.init();
        } else if (!toggle && instance2) {
          instance2.destroy();
          $$invalidate(16, instance2 = void 0);
          $$invalidate(17, internalClasses = {});
          $$invalidate(19, internalAttrs = {});
        }
        $$invalidate(31, oldToggle = toggle);
      }
    }
    if ($$self.$$.dirty[0] & 65537) {
      if (instance2 && !isUninitializedValue(pressed) && instance2.isOn() !== pressed) {
        instance2.toggle(pressed);
      }
    }
  };
  return [
    pressed,
    use,
    className,
    style,
    ripple,
    color,
    ariaLabelOn,
    ariaLabelOff,
    touch,
    displayFlex,
    size,
    href,
    action,
    component,
    getElement,
    element2,
    instance2,
    internalClasses,
    internalStyles,
    internalAttrs,
    actionProp,
    forwardEvents,
    isUninitializedValue,
    context,
    ariaDescribedby,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    toggle,
    previousDisabled,
    oldToggle,
    slots,
    switch_instance_binding,
    click_handler,
    click_handler_1,
    $$scope
  ];
}
class IconButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$8, create_fragment$u, safe_not_equal, {
      use: 1,
      class: 2,
      style: 3,
      ripple: 4,
      color: 5,
      toggle: 29,
      pressed: 0,
      ariaLabelOn: 6,
      ariaLabelOff: 7,
      touch: 8,
      displayFlex: 9,
      size: 10,
      href: 11,
      action: 12,
      component: 13,
      getElement: 14
    }, null, [-1, -1]);
  }
  get getElement() {
    return this.$$.ctx[14];
  }
}
function create_default_slot$b(ctx) {
  let current;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$t(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [ctx[4], ...ctx[0]]
    },
    {
      class: classMap({
        [ctx[1]]: true,
        "mdc-button__label": ctx[5] === "button",
        "mdc-fab__label": ctx[5] === "fab",
        "mdc-tab__text-label": ctx[5] === "tab",
        "mdc-image-list__label": ctx[5] === "image-list",
        "mdc-snackbar__label": ctx[5] === "snackbar",
        "mdc-banner__text": ctx[5] === "banner",
        "mdc-segmented-button__label": ctx[5] === "segmented-button",
        "mdc-data-table__pagination-rows-per-page-label": ctx[5] === "data-table:pagination",
        "mdc-data-table__header-cell-label": ctx[5] === "data-table:sortable-header-cell"
      })
    },
    ctx[5] === "snackbar" ? { "aria-atomic": "false" } : {},
    { tabindex: ctx[6] },
    ctx[7]
  ];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    ctx[10](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 243 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 17 && {
          use: [ctx2[4], ...ctx2[0]]
        },
        dirty & 34 && {
          class: classMap({
            [ctx2[1]]: true,
            "mdc-button__label": ctx2[5] === "button",
            "mdc-fab__label": ctx2[5] === "fab",
            "mdc-tab__text-label": ctx2[5] === "tab",
            "mdc-image-list__label": ctx2[5] === "image-list",
            "mdc-snackbar__label": ctx2[5] === "snackbar",
            "mdc-banner__text": ctx2[5] === "banner",
            "mdc-segmented-button__label": ctx2[5] === "segmented-button",
            "mdc-data-table__pagination-rows-per-page-label": ctx2[5] === "data-table:pagination",
            "mdc-data-table__header-cell-label": ctx2[5] === "data-table:sortable-header-cell"
          })
        },
        dirty & 32 && get_spread_object(ctx2[5] === "snackbar" ? { "aria-atomic": "false" } : {}),
        dirty & 64 && { tabindex: ctx2[6] },
        dirty & 128 && get_spread_object(ctx2[7])
      ]) : {};
      if (dirty & 2048) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          ctx2[10](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[10](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "component", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let { component = Span$1 } = $$props;
  const context = getContext("SMUI:label:context");
  const tabindex = getContext("SMUI:label:tabindex");
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(3, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("component" in $$new_props)
      $$invalidate(2, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    className,
    component,
    element2,
    forwardEvents,
    context,
    tabindex,
    $$restProps,
    getElement,
    slots,
    switch_instance_binding,
    $$scope
  ];
}
class CommonLabel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$t, safe_not_equal, {
      use: 0,
      class: 1,
      component: 2,
      getElement: 8
    });
  }
  get getElement() {
    return this.$$.ctx[8];
  }
}
function create_fragment$s(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let $storeValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { key } = $$props;
  let { value } = $$props;
  const storeValue = writable(value);
  component_subscribe($$self, storeValue, (value2) => $$invalidate(5, $storeValue = value2));
  setContext(key, storeValue);
  onDestroy(() => {
    storeValue.set(void 0);
  });
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      set_store_value(storeValue, $storeValue = value, $storeValue);
    }
  };
  return [storeValue, key, value, $$scope, slots];
}
class ContextFragment extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$s, safe_not_equal, { key: 1, value: 2 });
  }
}
const Label = CommonLabel;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _a, _b;
var cssClasses$7 = {
  LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
  LIST_ITEM_CLASS: "mdc-list-item",
  LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
  LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
  LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
  LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
  ROOT: "mdc-list"
};
_a = {}, _a["" + cssClasses$7.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", _a["" + cssClasses$7.LIST_ITEM_CLASS] = "mdc-list-item", _a["" + cssClasses$7.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", _a["" + cssClasses$7.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", _a["" + cssClasses$7.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", _a["" + cssClasses$7.ROOT] = "mdc-list", _a;
var deprecatedClassNameMap = (_b = {}, _b["" + cssClasses$7.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", _b["" + cssClasses$7.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", _b["" + cssClasses$7.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", _b["" + cssClasses$7.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", _b["" + cssClasses$7.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", _b["" + cssClasses$7.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", _b["" + cssClasses$7.ROOT] = "mdc-deprecated-list", _b);
var strings$5 = {
  ACTION_EVENT: "MDCList:action",
  ARIA_CHECKED: "aria-checked",
  ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
  ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
  ARIA_CURRENT: "aria-current",
  ARIA_DISABLED: "aria-disabled",
  ARIA_ORIENTATION: "aria-orientation",
  ARIA_ORIENTATION_HORIZONTAL: "horizontal",
  ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
  ARIA_SELECTED: "aria-selected",
  ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
  ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
  CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$7.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$7.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses$7.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$7.LIST_ITEM_CLASS] + " a\n  ",
  DEPRECATED_SELECTOR: ".mdc-deprecated-list",
  FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$7.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$7.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$7.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + cssClasses$7.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$7.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$7.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses$7.LIST_ITEM_CLASS] + ' input[type="radio"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$7.LIST_ITEM_CLASS] + ' input[type="checkbox"]:not(:disabled)\n  ',
  RADIO_SELECTOR: 'input[type="radio"]',
  SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
};
var numbers$3 = {
  UNSET_INDEX: -1,
  TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
};
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ELEMENTS_KEY_ALLOWED_IN = ["input", "button", "textarea", "select"];
var preventDefaultEvent = function(evt) {
  var target = evt.target;
  if (!target) {
    return;
  }
  var tagName = ("" + target.tagName).toLowerCase();
  if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
    evt.preventDefault();
  }
};
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function initState() {
  var state = {
    bufferClearTimeout: 0,
    currentFirstChar: "",
    sortedIndexCursor: 0,
    typeaheadBuffer: ""
  };
  return state;
}
function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
  var sortedIndexByFirstChar = /* @__PURE__ */ new Map();
  for (var i = 0; i < listItemCount; i++) {
    var primaryText = getPrimaryTextByItemIndex(i).trim();
    if (!primaryText) {
      continue;
    }
    var firstChar = primaryText[0].toLowerCase();
    if (!sortedIndexByFirstChar.has(firstChar)) {
      sortedIndexByFirstChar.set(firstChar, []);
    }
    sortedIndexByFirstChar.get(firstChar).push({ text: primaryText.toLowerCase(), index: i });
  }
  sortedIndexByFirstChar.forEach(function(values) {
    values.sort(function(first, second) {
      return first.index - second.index;
    });
  });
  return sortedIndexByFirstChar;
}
function matchItem(opts, state) {
  var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  clearTimeout(state.bufferClearTimeout);
  state.bufferClearTimeout = setTimeout(function() {
    clearBuffer(state);
  }, numbers$3.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
  state.typeaheadBuffer = state.typeaheadBuffer + nextChar;
  var index;
  if (state.typeaheadBuffer.length === 1) {
    index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);
  } else {
    index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);
  }
  if (index !== -1 && !skipFocus) {
    focusItemAtIndex(index);
  }
  return index;
}
function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {
  var firstChar = state.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  if (firstChar === state.currentFirstChar && itemsMatchingFirstChar[state.sortedIndexCursor].index === focusedItemIndex) {
    state.sortedIndexCursor = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
    var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;
    if (!isItemAtIndexDisabled(newIndex)) {
      return newIndex;
    }
  }
  state.currentFirstChar = firstChar;
  var newCursorPosition = -1;
  var cursorPosition;
  for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  if (newCursorPosition !== -1) {
    state.sortedIndexCursor = newCursorPosition;
    return itemsMatchingFirstChar[state.sortedIndexCursor].index;
  }
  return -1;
}
function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {
  var firstChar = state.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];
  if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {
    return startingItem.index;
  }
  var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
  var nextCursorPosition = -1;
  while (cursorPosition !== state.sortedIndexCursor) {
    var currentItem = itemsMatchingFirstChar[cursorPosition];
    var matches2 = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;
    var isEnabled = !isItemAtIndexDisabled(currentItem.index);
    if (matches2 && isEnabled) {
      nextCursorPosition = cursorPosition;
      break;
    }
    cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
  }
  if (nextCursorPosition !== -1) {
    state.sortedIndexCursor = nextCursorPosition;
    return itemsMatchingFirstChar[state.sortedIndexCursor].index;
  }
  return -1;
}
function isTypingInProgress(state) {
  return state.typeaheadBuffer.length > 0;
}
function clearBuffer(state) {
  state.typeaheadBuffer = "";
}
function handleKeydown(opts, state) {
  var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  var isArrowLeft = normalizeKey(event) === "ArrowLeft";
  var isArrowUp = normalizeKey(event) === "ArrowUp";
  var isArrowRight = normalizeKey(event) === "ArrowRight";
  var isArrowDown = normalizeKey(event) === "ArrowDown";
  var isHome = normalizeKey(event) === "Home";
  var isEnd = normalizeKey(event) === "End";
  var isEnter = normalizeKey(event) === "Enter";
  var isSpace = normalizeKey(event) === "Spacebar";
  if (event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
    return -1;
  }
  var isCharacterKey = !isSpace && event.key.length === 1;
  if (isCharacterKey) {
    preventDefaultEvent(event);
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: event.key.toLowerCase(),
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state);
  }
  if (!isSpace) {
    return -1;
  }
  if (isTargetListItem) {
    preventDefaultEvent(event);
  }
  var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);
  if (typeaheadOnListItem) {
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: " ",
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state);
  }
  return -1;
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function isNumberArray(selectedIndex) {
  return selectedIndex instanceof Array;
}
var MDCListFoundation = function(_super) {
  __extends(MDCListFoundation2, _super);
  function MDCListFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCListFoundation2.defaultAdapter), adapter)) || this;
    _this.wrapFocus = false;
    _this.isVertical = true;
    _this.isSingleSelectionList = false;
    _this.selectedIndex = numbers$3.UNSET_INDEX;
    _this.focusedItemIndex = numbers$3.UNSET_INDEX;
    _this.useActivatedClass = false;
    _this.useSelectedAttr = false;
    _this.ariaCurrentAttrValue = null;
    _this.isCheckboxList = false;
    _this.isRadioList = false;
    _this.hasTypeahead = false;
    _this.typeaheadState = initState();
    _this.sortedIndexByFirstChar = /* @__PURE__ */ new Map();
    return _this;
  }
  Object.defineProperty(MDCListFoundation2, "strings", {
    get: function() {
      return strings$5;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCListFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$7;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCListFoundation2, "numbers", {
    get: function() {
      return numbers$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCListFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClassForElementIndex: function() {
          return void 0;
        },
        focusItemAtIndex: function() {
          return void 0;
        },
        getAttributeForElementIndex: function() {
          return null;
        },
        getFocusedElementIndex: function() {
          return 0;
        },
        getListItemCount: function() {
          return 0;
        },
        hasCheckboxAtIndex: function() {
          return false;
        },
        hasRadioAtIndex: function() {
          return false;
        },
        isCheckboxCheckedAtIndex: function() {
          return false;
        },
        isFocusInsideList: function() {
          return false;
        },
        isRootFocused: function() {
          return false;
        },
        listItemAtIndexHasClass: function() {
          return false;
        },
        notifyAction: function() {
          return void 0;
        },
        removeClassForElementIndex: function() {
          return void 0;
        },
        setAttributeForElementIndex: function() {
          return void 0;
        },
        setCheckedCheckboxOrRadioAtIndex: function() {
          return void 0;
        },
        setTabIndexForListItemChildren: function() {
          return void 0;
        },
        getPrimaryTextAtIndex: function() {
          return "";
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCListFoundation2.prototype.layout = function() {
    if (this.adapter.getListItemCount() === 0) {
      return;
    }
    if (this.adapter.hasCheckboxAtIndex(0)) {
      this.isCheckboxList = true;
    } else if (this.adapter.hasRadioAtIndex(0)) {
      this.isRadioList = true;
    } else {
      this.maybeInitializeSingleSelection();
    }
    if (this.hasTypeahead) {
      this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
    }
  };
  MDCListFoundation2.prototype.getFocusedItemIndex = function() {
    return this.focusedItemIndex;
  };
  MDCListFoundation2.prototype.setWrapFocus = function(value) {
    this.wrapFocus = value;
  };
  MDCListFoundation2.prototype.setVerticalOrientation = function(value) {
    this.isVertical = value;
  };
  MDCListFoundation2.prototype.setSingleSelection = function(value) {
    this.isSingleSelectionList = value;
    if (value) {
      this.maybeInitializeSingleSelection();
      this.selectedIndex = this.getSelectedIndexFromDOM();
    }
  };
  MDCListFoundation2.prototype.maybeInitializeSingleSelection = function() {
    var selectedItemIndex = this.getSelectedIndexFromDOM();
    if (selectedItemIndex === numbers$3.UNSET_INDEX)
      return;
    var hasActivatedClass = this.adapter.listItemAtIndexHasClass(selectedItemIndex, cssClasses$7.LIST_ITEM_ACTIVATED_CLASS);
    if (hasActivatedClass) {
      this.setUseActivatedClass(true);
    }
    this.isSingleSelectionList = true;
    this.selectedIndex = selectedItemIndex;
  };
  MDCListFoundation2.prototype.getSelectedIndexFromDOM = function() {
    var selectedIndex = numbers$3.UNSET_INDEX;
    var listItemsCount = this.adapter.getListItemCount();
    for (var i = 0; i < listItemsCount; i++) {
      var hasSelectedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses$7.LIST_ITEM_SELECTED_CLASS);
      var hasActivatedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses$7.LIST_ITEM_ACTIVATED_CLASS);
      if (!(hasSelectedClass || hasActivatedClass)) {
        continue;
      }
      selectedIndex = i;
      break;
    }
    return selectedIndex;
  };
  MDCListFoundation2.prototype.setHasTypeahead = function(hasTypeahead) {
    this.hasTypeahead = hasTypeahead;
    if (hasTypeahead) {
      this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
    }
  };
  MDCListFoundation2.prototype.isTypeaheadInProgress = function() {
    return this.hasTypeahead && isTypingInProgress(this.typeaheadState);
  };
  MDCListFoundation2.prototype.setUseActivatedClass = function(useActivated) {
    this.useActivatedClass = useActivated;
  };
  MDCListFoundation2.prototype.setUseSelectedAttribute = function(useSelected) {
    this.useSelectedAttr = useSelected;
  };
  MDCListFoundation2.prototype.getSelectedIndex = function() {
    return this.selectedIndex;
  };
  MDCListFoundation2.prototype.setSelectedIndex = function(index, _a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, forceUpdate = _b2.forceUpdate;
    if (!this.isIndexValid(index)) {
      return;
    }
    if (this.isCheckboxList) {
      this.setCheckboxAtIndex(index);
    } else if (this.isRadioList) {
      this.setRadioAtIndex(index);
    } else {
      this.setSingleSelectionAtIndex(index, { forceUpdate });
    }
  };
  MDCListFoundation2.prototype.handleFocusIn = function(listItemIndex) {
    if (listItemIndex >= 0) {
      this.focusedItemIndex = listItemIndex;
      this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "0");
      this.adapter.setTabIndexForListItemChildren(listItemIndex, "0");
    }
  };
  MDCListFoundation2.prototype.handleFocusOut = function(listItemIndex) {
    var _this = this;
    if (listItemIndex >= 0) {
      this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "-1");
      this.adapter.setTabIndexForListItemChildren(listItemIndex, "-1");
    }
    setTimeout(function() {
      if (!_this.adapter.isFocusInsideList()) {
        _this.setTabindexToFirstSelectedOrFocusedItem();
      }
    }, 0);
  };
  MDCListFoundation2.prototype.handleKeydown = function(event, isRootListItem, listItemIndex) {
    var _this = this;
    var isArrowLeft = normalizeKey(event) === "ArrowLeft";
    var isArrowUp = normalizeKey(event) === "ArrowUp";
    var isArrowRight = normalizeKey(event) === "ArrowRight";
    var isArrowDown = normalizeKey(event) === "ArrowDown";
    var isHome = normalizeKey(event) === "Home";
    var isEnd = normalizeKey(event) === "End";
    var isEnter = normalizeKey(event) === "Enter";
    var isSpace = normalizeKey(event) === "Spacebar";
    var isLetterA = event.key === "A" || event.key === "a";
    if (this.adapter.isRootFocused()) {
      if (isArrowUp || isEnd) {
        event.preventDefault();
        this.focusLastElement();
      } else if (isArrowDown || isHome) {
        event.preventDefault();
        this.focusFirstElement();
      }
      if (this.hasTypeahead) {
        var handleKeydownOpts = {
          event,
          focusItemAtIndex: function(index) {
            _this.focusItemAtIndex(index);
          },
          focusedItemIndex: -1,
          isTargetListItem: isRootListItem,
          sortedIndexByFirstChar: this.sortedIndexByFirstChar,
          isItemAtIndexDisabled: function(index) {
            return _this.adapter.listItemAtIndexHasClass(index, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
          }
        };
        handleKeydown(handleKeydownOpts, this.typeaheadState);
      }
      return;
    }
    var currentIndex = this.adapter.getFocusedElementIndex();
    if (currentIndex === -1) {
      currentIndex = listItemIndex;
      if (currentIndex < 0) {
        return;
      }
    }
    if (this.isVertical && isArrowDown || !this.isVertical && isArrowRight) {
      preventDefaultEvent(event);
      this.focusNextElement(currentIndex);
    } else if (this.isVertical && isArrowUp || !this.isVertical && isArrowLeft) {
      preventDefaultEvent(event);
      this.focusPrevElement(currentIndex);
    } else if (isHome) {
      preventDefaultEvent(event);
      this.focusFirstElement();
    } else if (isEnd) {
      preventDefaultEvent(event);
      this.focusLastElement();
    } else if (isLetterA && event.ctrlKey && this.isCheckboxList) {
      event.preventDefault();
      this.toggleAll(this.selectedIndex === numbers$3.UNSET_INDEX ? [] : this.selectedIndex);
    } else if (isEnter || isSpace) {
      if (isRootListItem) {
        var target = event.target;
        if (target && target.tagName === "A" && isEnter) {
          return;
        }
        preventDefaultEvent(event);
        if (this.adapter.listItemAtIndexHasClass(currentIndex, cssClasses$7.LIST_ITEM_DISABLED_CLASS)) {
          return;
        }
        if (!this.isTypeaheadInProgress()) {
          if (this.isSelectableList()) {
            this.setSelectedIndexOnAction(currentIndex);
          }
          this.adapter.notifyAction(currentIndex);
        }
      }
    }
    if (this.hasTypeahead) {
      var handleKeydownOpts = {
        event,
        focusItemAtIndex: function(index) {
          _this.focusItemAtIndex(index);
        },
        focusedItemIndex: this.focusedItemIndex,
        isTargetListItem: isRootListItem,
        sortedIndexByFirstChar: this.sortedIndexByFirstChar,
        isItemAtIndexDisabled: function(index) {
          return _this.adapter.listItemAtIndexHasClass(index, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
        }
      };
      handleKeydown(handleKeydownOpts, this.typeaheadState);
    }
  };
  MDCListFoundation2.prototype.handleClick = function(index, toggleCheckbox) {
    if (index === numbers$3.UNSET_INDEX) {
      return;
    }
    if (this.adapter.listItemAtIndexHasClass(index, cssClasses$7.LIST_ITEM_DISABLED_CLASS)) {
      return;
    }
    if (this.isSelectableList()) {
      this.setSelectedIndexOnAction(index, toggleCheckbox);
    }
    this.adapter.notifyAction(index);
  };
  MDCListFoundation2.prototype.focusNextElement = function(index) {
    var count = this.adapter.getListItemCount();
    var nextIndex = index + 1;
    if (nextIndex >= count) {
      if (this.wrapFocus) {
        nextIndex = 0;
      } else {
        return index;
      }
    }
    this.focusItemAtIndex(nextIndex);
    return nextIndex;
  };
  MDCListFoundation2.prototype.focusPrevElement = function(index) {
    var prevIndex = index - 1;
    if (prevIndex < 0) {
      if (this.wrapFocus) {
        prevIndex = this.adapter.getListItemCount() - 1;
      } else {
        return index;
      }
    }
    this.focusItemAtIndex(prevIndex);
    return prevIndex;
  };
  MDCListFoundation2.prototype.focusFirstElement = function() {
    this.focusItemAtIndex(0);
    return 0;
  };
  MDCListFoundation2.prototype.focusLastElement = function() {
    var lastIndex = this.adapter.getListItemCount() - 1;
    this.focusItemAtIndex(lastIndex);
    return lastIndex;
  };
  MDCListFoundation2.prototype.focusInitialElement = function() {
    var initialIndex = this.getFirstSelectedOrFocusedItemIndex();
    this.focusItemAtIndex(initialIndex);
    return initialIndex;
  };
  MDCListFoundation2.prototype.setEnabled = function(itemIndex, isEnabled) {
    if (!this.isIndexValid(itemIndex)) {
      return;
    }
    if (isEnabled) {
      this.adapter.removeClassForElementIndex(itemIndex, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
      this.adapter.setAttributeForElementIndex(itemIndex, strings$5.ARIA_DISABLED, "false");
    } else {
      this.adapter.addClassForElementIndex(itemIndex, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
      this.adapter.setAttributeForElementIndex(itemIndex, strings$5.ARIA_DISABLED, "true");
    }
  };
  MDCListFoundation2.prototype.setSingleSelectionAtIndex = function(index, _a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, forceUpdate = _b2.forceUpdate;
    if (this.selectedIndex === index && !forceUpdate) {
      return;
    }
    var selectedClassName = cssClasses$7.LIST_ITEM_SELECTED_CLASS;
    if (this.useActivatedClass) {
      selectedClassName = cssClasses$7.LIST_ITEM_ACTIVATED_CLASS;
    }
    if (this.selectedIndex !== numbers$3.UNSET_INDEX) {
      this.adapter.removeClassForElementIndex(this.selectedIndex, selectedClassName);
    }
    this.setAriaForSingleSelectionAtIndex(index);
    this.setTabindexAtIndex(index);
    if (index !== numbers$3.UNSET_INDEX) {
      this.adapter.addClassForElementIndex(index, selectedClassName);
    }
    this.selectedIndex = index;
  };
  MDCListFoundation2.prototype.setAriaForSingleSelectionAtIndex = function(index) {
    if (this.selectedIndex === numbers$3.UNSET_INDEX) {
      this.ariaCurrentAttrValue = this.adapter.getAttributeForElementIndex(index, strings$5.ARIA_CURRENT);
    }
    var isAriaCurrent = this.ariaCurrentAttrValue !== null;
    var ariaAttribute = isAriaCurrent ? strings$5.ARIA_CURRENT : strings$5.ARIA_SELECTED;
    if (this.selectedIndex !== numbers$3.UNSET_INDEX) {
      this.adapter.setAttributeForElementIndex(this.selectedIndex, ariaAttribute, "false");
    }
    if (index !== numbers$3.UNSET_INDEX) {
      var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue : "true";
      this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
    }
  };
  MDCListFoundation2.prototype.getSelectionAttribute = function() {
    return this.useSelectedAttr ? strings$5.ARIA_SELECTED : strings$5.ARIA_CHECKED;
  };
  MDCListFoundation2.prototype.setRadioAtIndex = function(index) {
    var selectionAttribute = this.getSelectionAttribute();
    this.adapter.setCheckedCheckboxOrRadioAtIndex(index, true);
    if (this.selectedIndex !== numbers$3.UNSET_INDEX) {
      this.adapter.setAttributeForElementIndex(this.selectedIndex, selectionAttribute, "false");
    }
    this.adapter.setAttributeForElementIndex(index, selectionAttribute, "true");
    this.selectedIndex = index;
  };
  MDCListFoundation2.prototype.setCheckboxAtIndex = function(index) {
    var selectionAttribute = this.getSelectionAttribute();
    for (var i = 0; i < this.adapter.getListItemCount(); i++) {
      var isChecked = false;
      if (index.indexOf(i) >= 0) {
        isChecked = true;
      }
      this.adapter.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
      this.adapter.setAttributeForElementIndex(i, selectionAttribute, isChecked ? "true" : "false");
    }
    this.selectedIndex = index;
  };
  MDCListFoundation2.prototype.setTabindexAtIndex = function(index) {
    if (this.focusedItemIndex === numbers$3.UNSET_INDEX && index !== 0) {
      this.adapter.setAttributeForElementIndex(0, "tabindex", "-1");
    } else if (this.focusedItemIndex >= 0 && this.focusedItemIndex !== index) {
      this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1");
    }
    if (!(this.selectedIndex instanceof Array) && this.selectedIndex !== index) {
      this.adapter.setAttributeForElementIndex(this.selectedIndex, "tabindex", "-1");
    }
    if (index !== numbers$3.UNSET_INDEX) {
      this.adapter.setAttributeForElementIndex(index, "tabindex", "0");
    }
  };
  MDCListFoundation2.prototype.isSelectableList = function() {
    return this.isSingleSelectionList || this.isCheckboxList || this.isRadioList;
  };
  MDCListFoundation2.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
    var targetIndex = this.getFirstSelectedOrFocusedItemIndex();
    this.setTabindexAtIndex(targetIndex);
  };
  MDCListFoundation2.prototype.getFirstSelectedOrFocusedItemIndex = function() {
    if (!this.isSelectableList()) {
      return Math.max(this.focusedItemIndex, 0);
    }
    if (typeof this.selectedIndex === "number" && this.selectedIndex !== numbers$3.UNSET_INDEX) {
      return this.selectedIndex;
    }
    if (isNumberArray(this.selectedIndex) && this.selectedIndex.length > 0) {
      return this.selectedIndex.reduce(function(minIndex, currentIndex) {
        return Math.min(minIndex, currentIndex);
      });
    }
    return 0;
  };
  MDCListFoundation2.prototype.isIndexValid = function(index) {
    var _this = this;
    if (index instanceof Array) {
      if (!this.isCheckboxList) {
        throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
      }
      if (index.length === 0) {
        return true;
      } else {
        return index.some(function(i) {
          return _this.isIndexInRange(i);
        });
      }
    } else if (typeof index === "number") {
      if (this.isCheckboxList) {
        throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + index);
      }
      return this.isIndexInRange(index) || this.isSingleSelectionList && index === numbers$3.UNSET_INDEX;
    } else {
      return false;
    }
  };
  MDCListFoundation2.prototype.isIndexInRange = function(index) {
    var listSize = this.adapter.getListItemCount();
    return index >= 0 && index < listSize;
  };
  MDCListFoundation2.prototype.setSelectedIndexOnAction = function(index, toggleCheckbox) {
    if (toggleCheckbox === void 0) {
      toggleCheckbox = true;
    }
    if (this.isCheckboxList) {
      this.toggleCheckboxAtIndex(index, toggleCheckbox);
    } else {
      this.setSelectedIndex(index);
    }
  };
  MDCListFoundation2.prototype.toggleCheckboxAtIndex = function(index, toggleCheckbox) {
    var selectionAttribute = this.getSelectionAttribute();
    var isChecked = this.adapter.isCheckboxCheckedAtIndex(index);
    if (toggleCheckbox) {
      isChecked = !isChecked;
      this.adapter.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
    }
    this.adapter.setAttributeForElementIndex(index, selectionAttribute, isChecked ? "true" : "false");
    var selectedIndexes = this.selectedIndex === numbers$3.UNSET_INDEX ? [] : this.selectedIndex.slice();
    if (isChecked) {
      selectedIndexes.push(index);
    } else {
      selectedIndexes = selectedIndexes.filter(function(i) {
        return i !== index;
      });
    }
    this.selectedIndex = selectedIndexes;
  };
  MDCListFoundation2.prototype.focusItemAtIndex = function(index) {
    this.adapter.focusItemAtIndex(index);
    this.focusedItemIndex = index;
  };
  MDCListFoundation2.prototype.toggleAll = function(currentlySelectedIndexes) {
    var count = this.adapter.getListItemCount();
    if (currentlySelectedIndexes.length === count) {
      this.setCheckboxAtIndex([]);
    } else {
      var allIndexes = [];
      for (var i = 0; i < count; i++) {
        if (!this.adapter.listItemAtIndexHasClass(i, cssClasses$7.LIST_ITEM_DISABLED_CLASS) || currentlySelectedIndexes.indexOf(i) > -1) {
          allIndexes.push(i);
        }
      }
      this.setCheckboxAtIndex(allIndexes);
    }
  };
  MDCListFoundation2.prototype.typeaheadMatchItem = function(nextChar, startingIndex, skipFocus) {
    var _this = this;
    if (skipFocus === void 0) {
      skipFocus = false;
    }
    var opts = {
      focusItemAtIndex: function(index) {
        _this.focusItemAtIndex(index);
      },
      focusedItemIndex: startingIndex ? startingIndex : this.focusedItemIndex,
      nextChar,
      sortedIndexByFirstChar: this.sortedIndexByFirstChar,
      skipFocus,
      isItemAtIndexDisabled: function(index) {
        return _this.adapter.listItemAtIndexHasClass(index, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
      }
    };
    return matchItem(opts, this.typeaheadState);
  };
  MDCListFoundation2.prototype.typeaheadInitSortedIndex = function() {
    return initSortedIndex(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
  };
  MDCListFoundation2.prototype.clearTypeaheadBuffer = function() {
    clearBuffer(this.typeaheadState);
  };
  return MDCListFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$6 = {
  ANIMATE: "mdc-drawer--animate",
  CLOSING: "mdc-drawer--closing",
  DISMISSIBLE: "mdc-drawer--dismissible",
  MODAL: "mdc-drawer--modal",
  OPEN: "mdc-drawer--open",
  OPENING: "mdc-drawer--opening",
  ROOT: "mdc-drawer"
};
var strings$4 = {
  APP_CONTENT_SELECTOR: ".mdc-drawer-app-content",
  CLOSE_EVENT: "MDCDrawer:closed",
  OPEN_EVENT: "MDCDrawer:opened",
  SCRIM_SELECTOR: ".mdc-drawer-scrim",
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  LIST_ITEM_ACTIVATED_SELECTOR: ".mdc-list-item--activated,.mdc-deprecated-list-item--activated"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCDismissibleDrawerFoundation = function(_super) {
  __extends(MDCDismissibleDrawerFoundation2, _super);
  function MDCDismissibleDrawerFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCDismissibleDrawerFoundation2.defaultAdapter), adapter)) || this;
    _this.animationFrame = 0;
    _this.animationTimer = 0;
    return _this;
  }
  Object.defineProperty(MDCDismissibleDrawerFoundation2, "strings", {
    get: function() {
      return strings$4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDismissibleDrawerFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$6;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDismissibleDrawerFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        elementHasClass: function() {
          return false;
        },
        notifyClose: function() {
          return void 0;
        },
        notifyOpen: function() {
          return void 0;
        },
        saveFocus: function() {
          return void 0;
        },
        restoreFocus: function() {
          return void 0;
        },
        focusActiveNavigationItem: function() {
          return void 0;
        },
        trapFocus: function() {
          return void 0;
        },
        releaseFocus: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCDismissibleDrawerFoundation2.prototype.destroy = function() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
    }
  };
  MDCDismissibleDrawerFoundation2.prototype.open = function() {
    var _this = this;
    if (this.isOpen() || this.isOpening() || this.isClosing()) {
      return;
    }
    this.adapter.addClass(cssClasses$6.OPEN);
    this.adapter.addClass(cssClasses$6.ANIMATE);
    this.runNextAnimationFrame(function() {
      _this.adapter.addClass(cssClasses$6.OPENING);
    });
    this.adapter.saveFocus();
  };
  MDCDismissibleDrawerFoundation2.prototype.close = function() {
    if (!this.isOpen() || this.isOpening() || this.isClosing()) {
      return;
    }
    this.adapter.addClass(cssClasses$6.CLOSING);
  };
  MDCDismissibleDrawerFoundation2.prototype.isOpen = function() {
    return this.adapter.hasClass(cssClasses$6.OPEN);
  };
  MDCDismissibleDrawerFoundation2.prototype.isOpening = function() {
    return this.adapter.hasClass(cssClasses$6.OPENING) || this.adapter.hasClass(cssClasses$6.ANIMATE);
  };
  MDCDismissibleDrawerFoundation2.prototype.isClosing = function() {
    return this.adapter.hasClass(cssClasses$6.CLOSING);
  };
  MDCDismissibleDrawerFoundation2.prototype.handleKeydown = function(evt) {
    var keyCode = evt.keyCode, key = evt.key;
    var isEscape = key === "Escape" || keyCode === 27;
    if (isEscape) {
      this.close();
    }
  };
  MDCDismissibleDrawerFoundation2.prototype.handleTransitionEnd = function(evt) {
    var OPENING = cssClasses$6.OPENING, CLOSING = cssClasses$6.CLOSING, OPEN = cssClasses$6.OPEN, ANIMATE = cssClasses$6.ANIMATE, ROOT = cssClasses$6.ROOT;
    var isRootElement = this.isElement(evt.target) && this.adapter.elementHasClass(evt.target, ROOT);
    if (!isRootElement) {
      return;
    }
    if (this.isClosing()) {
      this.adapter.removeClass(OPEN);
      this.closed();
      this.adapter.restoreFocus();
      this.adapter.notifyClose();
    } else {
      this.adapter.focusActiveNavigationItem();
      this.opened();
      this.adapter.notifyOpen();
    }
    this.adapter.removeClass(ANIMATE);
    this.adapter.removeClass(OPENING);
    this.adapter.removeClass(CLOSING);
  };
  MDCDismissibleDrawerFoundation2.prototype.opened = function() {
  };
  MDCDismissibleDrawerFoundation2.prototype.closed = function() {
  };
  MDCDismissibleDrawerFoundation2.prototype.runNextAnimationFrame = function(callback) {
    var _this = this;
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = requestAnimationFrame(function() {
      _this.animationFrame = 0;
      clearTimeout(_this.animationTimer);
      _this.animationTimer = setTimeout(callback, 0);
    });
  };
  MDCDismissibleDrawerFoundation2.prototype.isElement = function(element2) {
    return Boolean(element2.classList);
  };
  return MDCDismissibleDrawerFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCModalDrawerFoundation = function(_super) {
  __extends(MDCModalDrawerFoundation2, _super);
  function MDCModalDrawerFoundation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCModalDrawerFoundation2.prototype.handleScrimClick = function() {
    this.close();
  };
  MDCModalDrawerFoundation2.prototype.opened = function() {
    this.adapter.trapFocus();
  };
  MDCModalDrawerFoundation2.prototype.closed = function() {
    this.adapter.releaseFocus();
  };
  return MDCModalDrawerFoundation2;
}(MDCDismissibleDrawerFoundation);
function create_fragment$r(ctx) {
  let aside;
  let aside_class_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  let aside_levels = [
    {
      class: aside_class_value = classMap(__spreadValues({
        [ctx[1]]: true,
        "mdc-drawer": true,
        "mdc-drawer--dismissible": ctx[2] === "dismissible",
        "mdc-drawer--modal": ctx[2] === "modal",
        "smui-drawer__absolute": ctx[2] === "modal" && !ctx[3]
      }, ctx[6]))
    },
    ctx[8]
  ];
  let aside_data = {};
  for (let i = 0; i < aside_levels.length; i += 1) {
    aside_data = assign(aside_data, aside_levels[i]);
  }
  return {
    c() {
      aside = element("aside");
      if (default_slot)
        default_slot.c();
      set_attributes(aside, aside_data);
    },
    m(target, anchor) {
      insert(target, aside, anchor);
      if (default_slot) {
        default_slot.m(aside, null);
      }
      ctx[16](aside);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, aside, ctx[0])),
          action_destroyer(ctx[7].call(null, aside)),
          listen(aside, "keydown", ctx[17]),
          listen(aside, "transitionend", ctx[18])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[14], !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null), null);
        }
      }
      set_attributes(aside, aside_data = get_spread_update(aside_levels, [
        (!current || dirty & 78 && aside_class_value !== (aside_class_value = classMap(__spreadValues({
          [ctx2[1]]: true,
          "mdc-drawer": true,
          "mdc-drawer--dismissible": ctx2[2] === "dismissible",
          "mdc-drawer--modal": ctx2[2] === "modal",
          "smui-drawer__absolute": ctx2[2] === "modal" && !ctx2[3]
        }, ctx2[6])))) && { class: aside_class_value },
        dirty & 256 && ctx2[8]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(aside);
      if (default_slot)
        default_slot.d(detaching);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance_1$7($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "variant", "open", "fixed", "setOpen", "isOpen", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const { FocusTrap: FocusTrap2 } = domFocusTrap;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { variant = void 0 } = $$props;
  let { open = false } = $$props;
  let { fixed = true } = $$props;
  let element2;
  let instance2 = void 0;
  let internalClasses = {};
  let previousFocus = null;
  let focusTrap;
  let scrim = false;
  setContext("SMUI:list:nav", true);
  setContext("SMUI:list:item:nav", true);
  setContext("SMUI:list:wrapFocus", true);
  let oldVariant = variant;
  onMount(() => {
    focusTrap = new FocusTrap2(element2, {
      skipInitialFocus: true
    });
    $$invalidate(4, instance2 = getInstance());
    instance2 && instance2.init();
  });
  onDestroy(() => {
    instance2 && instance2.destroy();
    scrim && scrim.removeEventListener("SMUIDrawerScrim:click", handleScrimClick);
  });
  function getInstance() {
    var _a2, _b2;
    if (scrim) {
      scrim.removeEventListener("SMUIDrawerScrim:click", handleScrimClick);
    }
    if (variant === "modal") {
      scrim = (_b2 = (_a2 = element2.parentNode) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".mdc-drawer-scrim")) !== null && _b2 !== void 0 ? _b2 : false;
      if (scrim) {
        scrim.addEventListener("SMUIDrawerScrim:click", handleScrimClick);
      }
    }
    const Foundation = variant === "dismissible" ? MDCDismissibleDrawerFoundation : variant === "modal" ? MDCModalDrawerFoundation : void 0;
    return Foundation ? new Foundation({
      addClass,
      removeClass,
      hasClass,
      elementHasClass: (element3, className2) => element3.classList.contains(className2),
      saveFocus: () => previousFocus = document.activeElement,
      restoreFocus: () => {
        if (previousFocus && "focus" in previousFocus && element2.contains(document.activeElement)) {
          previousFocus.focus();
        }
      },
      focusActiveNavigationItem: () => {
        const activeNavItemEl = element2.querySelector(".mdc-list-item--activated,.mdc-deprecated-list-item--activated");
        if (activeNavItemEl) {
          activeNavItemEl.focus();
        }
      },
      notifyClose: () => {
        $$invalidate(9, open = false);
        dispatch(element2, "SMUIDrawer:closed", void 0, void 0, true);
      },
      notifyOpen: () => {
        $$invalidate(9, open = true);
        dispatch(element2, "SMUIDrawer:opened", void 0, void 0, true);
      },
      trapFocus: () => focusTrap.trapFocus(),
      releaseFocus: () => focusTrap.releaseFocus()
    }) : void 0;
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function handleScrimClick() {
    instance2 && "handleScrimClick" in instance2 && instance2.handleScrimClick();
  }
  function setOpen(value) {
    $$invalidate(9, open = value);
  }
  function isOpen() {
    return open;
  }
  function getElement() {
    return element2;
  }
  function aside_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const keydown_handler = (event) => instance2 && instance2.handleKeydown(event);
  const transitionend_handler = (event) => instance2 && instance2.handleTransitionEnd(event);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("variant" in $$new_props)
      $$invalidate(2, variant = $$new_props.variant);
    if ("open" in $$new_props)
      $$invalidate(9, open = $$new_props.open);
    if ("fixed" in $$new_props)
      $$invalidate(3, fixed = $$new_props.fixed);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8212) {
      if (oldVariant !== variant) {
        $$invalidate(13, oldVariant = variant);
        instance2 && instance2.destroy();
        $$invalidate(6, internalClasses = {});
        $$invalidate(4, instance2 = getInstance());
        instance2 && instance2.init();
      }
    }
    if ($$self.$$.dirty & 528) {
      if (instance2 && instance2.isOpen() !== open) {
        if (open) {
          instance2.open();
        } else {
          instance2.close();
        }
      }
    }
  };
  return [
    use,
    className,
    variant,
    fixed,
    instance2,
    element2,
    internalClasses,
    forwardEvents,
    $$restProps,
    open,
    setOpen,
    isOpen,
    getElement,
    oldVariant,
    $$scope,
    slots,
    aside_binding,
    keydown_handler,
    transitionend_handler
  ];
}
class Drawer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$7, create_fragment$r, safe_not_equal, {
      use: 0,
      class: 1,
      variant: 2,
      open: 9,
      fixed: 3,
      setOpen: 10,
      isOpen: 11,
      getElement: 12
    });
  }
  get setOpen() {
    return this.$$.ctx[10];
  }
  get isOpen() {
    return this.$$.ctx[11];
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
var AppContent = classAdderBuilder({
  class: "mdc-drawer-app-content",
  component: Div
});
var Content$1 = classAdderBuilder({
  class: "mdc-drawer__content",
  component: Div
});
classAdderBuilder({
  class: "mdc-drawer__header",
  component: Div
});
classAdderBuilder({
  class: "mdc-drawer__title",
  component: H1
});
classAdderBuilder({
  class: "mdc-drawer__subtitle",
  component: H2
});
function create_default_slot$a(ctx) {
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$q(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [ctx[6], ...ctx[0]]
    },
    {
      class: classMap({
        [ctx[1]]: true,
        "mdc-drawer-scrim": true,
        "smui-drawer-scrim__absolute": !ctx[2]
      })
    },
    ctx[7]
  ];
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    ctx[9](switch_instance);
    switch_instance.$on("click", ctx[10]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 199 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 65 && {
          use: [ctx2[6], ...ctx2[0]]
        },
        dirty & 6 && {
          class: classMap({
            [ctx2[1]]: true,
            "mdc-drawer-scrim": true,
            "smui-drawer-scrim__absolute": !ctx2[2]
          })
        },
        dirty & 128 && get_spread_object(ctx2[7])
      ]) : {};
      if (dirty & 2048) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          ctx2[9](switch_instance);
          switch_instance.$on("click", ctx2[10]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[9](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "fixed", "component", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { fixed = true } = $$props;
  let element2;
  let { component = Div } = $$props;
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const click_handler = (event) => dispatch(getElement(), "SMUIDrawerScrim:click", event);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("fixed" in $$new_props)
      $$invalidate(2, fixed = $$new_props.fixed);
    if ("component" in $$new_props)
      $$invalidate(3, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    className,
    fixed,
    component,
    getElement,
    element2,
    forwardEvents,
    $$restProps,
    slots,
    switch_instance_binding,
    click_handler,
    $$scope
  ];
}
class Scrim$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$q, safe_not_equal, {
      use: 0,
      class: 1,
      fixed: 2,
      component: 3,
      getElement: 4
    });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
const Scrim = Scrim$1;
function create_default_slot$9(ctx) {
  let current;
  const default_slot_template = ctx[37].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[43], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 4096)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[43], !current ? get_all_dirty_from_scope(ctx2[43]) : get_slot_changes(default_slot_template, ctx2[43], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$p(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [ctx[17], ...ctx[0]]
    },
    {
      class: classMap({
        [ctx[1]]: true,
        "mdc-deprecated-list": true,
        "mdc-deprecated-list--non-interactive": ctx[2],
        "mdc-deprecated-list--dense": ctx[3],
        "mdc-deprecated-list--textual-list": ctx[4],
        "mdc-deprecated-list--avatar-list": ctx[5] || ctx[18],
        "mdc-deprecated-list--icon-list": ctx[6],
        "mdc-deprecated-list--image-list": ctx[7],
        "mdc-deprecated-list--thumbnail-list": ctx[8],
        "mdc-deprecated-list--video-list": ctx[9],
        "mdc-deprecated-list--two-line": ctx[10],
        "smui-list--three-line": ctx[11] && !ctx[10]
      })
    },
    { role: ctx[15] },
    ctx[23]
  ];
  var switch_value = ctx[12];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    ctx[38](switch_instance);
    switch_instance.$on("keydown", ctx[39]);
    switch_instance.$on("focusin", ctx[40]);
    switch_instance.$on("focusout", ctx[41]);
    switch_instance.$on("click", ctx[42]);
    switch_instance.$on("SMUIListItem:mount", ctx[19]);
    switch_instance.$on("SMUIListItem:unmount", ctx[20]);
    switch_instance.$on("SMUI:action", ctx[21]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & 8818687 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & 131073 && {
          use: [ctx2[17], ...ctx2[0]]
        },
        dirty[0] & 266238 && {
          class: classMap({
            [ctx2[1]]: true,
            "mdc-deprecated-list": true,
            "mdc-deprecated-list--non-interactive": ctx2[2],
            "mdc-deprecated-list--dense": ctx2[3],
            "mdc-deprecated-list--textual-list": ctx2[4],
            "mdc-deprecated-list--avatar-list": ctx2[5] || ctx2[18],
            "mdc-deprecated-list--icon-list": ctx2[6],
            "mdc-deprecated-list--image-list": ctx2[7],
            "mdc-deprecated-list--thumbnail-list": ctx2[8],
            "mdc-deprecated-list--video-list": ctx2[9],
            "mdc-deprecated-list--two-line": ctx2[10],
            "smui-list--three-line": ctx2[11] && !ctx2[10]
          })
        },
        dirty[0] & 32768 && { role: ctx2[15] },
        dirty[0] & 8388608 && get_spread_object(ctx2[23])
      ]) : {};
      if (dirty[1] & 4096) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[12])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          ctx2[38](switch_instance);
          switch_instance.$on("keydown", ctx2[39]);
          switch_instance.$on("focusin", ctx2[40]);
          switch_instance.$on("focusout", ctx2[41]);
          switch_instance.$on("click", ctx2[42]);
          switch_instance.$on("SMUIListItem:mount", ctx2[19]);
          switch_instance.$on("SMUIListItem:unmount", ctx2[20]);
          switch_instance.$on("SMUI:action", ctx2[21]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[38](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance_1$6($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "nonInteractive",
    "dense",
    "textualList",
    "avatarList",
    "iconList",
    "imageList",
    "thumbnailList",
    "videoList",
    "twoLine",
    "threeLine",
    "vertical",
    "wrapFocus",
    "singleSelection",
    "selectedIndex",
    "radioList",
    "checkList",
    "hasTypeahead",
    "component",
    "layout",
    "setEnabled",
    "getTypeaheadInProgress",
    "getSelectedIndex",
    "getFocusedItemIndex",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a2;
  const { closest: closest2, matches: matches2 } = ponyfill;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { nonInteractive = false } = $$props;
  let { dense = false } = $$props;
  let { textualList = false } = $$props;
  let { avatarList = false } = $$props;
  let { iconList = false } = $$props;
  let { imageList = false } = $$props;
  let { thumbnailList = false } = $$props;
  let { videoList = false } = $$props;
  let { twoLine = false } = $$props;
  let { threeLine = false } = $$props;
  let { vertical = true } = $$props;
  let { wrapFocus = (_a2 = getContext("SMUI:list:wrapFocus")) !== null && _a2 !== void 0 ? _a2 : false } = $$props;
  let { singleSelection = false } = $$props;
  let { selectedIndex = -1 } = $$props;
  let { radioList = false } = $$props;
  let { checkList = false } = $$props;
  let { hasTypeahead = false } = $$props;
  let element2;
  let instance2;
  let items = [];
  let role = getContext("SMUI:list:role");
  let nav = getContext("SMUI:list:nav");
  const itemAccessorMap = /* @__PURE__ */ new WeakMap();
  let selectionDialog = getContext("SMUI:dialog:selection");
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let { component = nav ? Nav : Ul } = $$props;
  setContext("SMUI:list:nonInteractive", nonInteractive);
  setContext("SMUI:separator:context", "list");
  if (!role) {
    if (singleSelection) {
      role = "listbox";
      setContext("SMUI:list:item:role", "option");
    } else if (radioList) {
      role = "radiogroup";
      setContext("SMUI:list:item:role", "radio");
    } else if (checkList) {
      role = "group";
      setContext("SMUI:list:item:role", "checkbox");
    } else {
      role = "list";
      setContext("SMUI:list:item:role", void 0);
    }
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(13, instance2 = new MDCListFoundation({
      addClassForElementIndex,
      focusItemAtIndex,
      getAttributeForElementIndex: (index, name) => {
        var _a3, _b2;
        return (_b2 = (_a3 = getOrderedList()[index]) === null || _a3 === void 0 ? void 0 : _a3.getAttr(name)) !== null && _b2 !== void 0 ? _b2 : null;
      },
      getFocusedElementIndex: () => document.activeElement ? getOrderedList().map((accessor2) => accessor2.element).indexOf(document.activeElement) : -1,
      getListItemCount: () => items.length,
      getPrimaryTextAtIndex,
      hasCheckboxAtIndex: (index) => {
        var _a3, _b2;
        return (_b2 = (_a3 = getOrderedList()[index]) === null || _a3 === void 0 ? void 0 : _a3.hasCheckbox) !== null && _b2 !== void 0 ? _b2 : false;
      },
      hasRadioAtIndex: (index) => {
        var _a3, _b2;
        return (_b2 = (_a3 = getOrderedList()[index]) === null || _a3 === void 0 ? void 0 : _a3.hasRadio) !== null && _b2 !== void 0 ? _b2 : false;
      },
      isCheckboxCheckedAtIndex: (index) => {
        var _a3;
        const listItem = getOrderedList()[index];
        return (_a3 = (listItem === null || listItem === void 0 ? void 0 : listItem.hasCheckbox) && listItem.checked) !== null && _a3 !== void 0 ? _a3 : false;
      },
      isFocusInsideList: () => element2 != null && getElement() !== document.activeElement && getElement().contains(document.activeElement),
      isRootFocused: () => element2 != null && document.activeElement === getElement(),
      listItemAtIndexHasClass,
      notifyAction: (index) => {
        $$invalidate(24, selectedIndex = index);
        if (element2 != null) {
          dispatch(getElement(), "SMUIList:action", { index }, void 0, true);
        }
      },
      removeClassForElementIndex,
      setAttributeForElementIndex,
      setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
        getOrderedList()[index].checked = isChecked;
      },
      setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
        const listItem = getOrderedList()[listItemIndex];
        const selector = "button:not(:disabled), a";
        Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
          el.setAttribute("tabindex", tabIndexValue);
        });
      }
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      get items() {
        return items;
      },
      get typeaheadInProgress() {
        return instance2.isTypeaheadInProgress();
      },
      typeaheadMatchItem(nextChar, startingIndex) {
        return instance2.typeaheadMatchItem(nextChar, startingIndex, true);
      },
      getOrderedList,
      focusItemAtIndex,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getAttributeFromElementIndex,
      getPrimaryTextAtIndex
    };
    dispatch(getElement(), "SMUIList:mount", accessor);
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleItemMount(event) {
    items.push(event.detail);
    itemAccessorMap.set(event.detail.element, event.detail);
    if (singleSelection && event.detail.selected) {
      $$invalidate(24, selectedIndex = getListItemIndex(event.detail.element));
    }
    event.stopPropagation();
  }
  function handleItemUnmount(event) {
    var _a3;
    const idx = (_a3 = event.detail && items.indexOf(event.detail)) !== null && _a3 !== void 0 ? _a3 : -1;
    if (idx !== -1) {
      items.splice(idx, 1);
      items = items;
      itemAccessorMap.delete(event.detail.element);
    }
    event.stopPropagation();
  }
  function handleAction(event) {
    if (radioList || checkList) {
      const index = getListItemIndex(event.target);
      if (index !== -1) {
        const item = getOrderedList()[index];
        if (item && (radioList && !item.checked || checkList)) {
          item.checked = !item.checked;
          item.activateRipple();
          window.requestAnimationFrame(() => {
            item.deactivateRipple();
          });
        }
      }
    }
  }
  function getOrderedList() {
    if (element2 == null) {
      return [];
    }
    return [...getElement().children].map((element3) => itemAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
  }
  function focusItemAtIndex(index) {
    const accessor = getOrderedList()[index];
    accessor && "focus" in accessor.element && accessor.element.focus();
  }
  function listItemAtIndexHasClass(index, className2) {
    var _a3;
    const accessor = getOrderedList()[index];
    return (_a3 = accessor && accessor.hasClass(className2)) !== null && _a3 !== void 0 ? _a3 : false;
  }
  function addClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addClass(className2);
  }
  function removeClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeClass(className2);
  }
  function setAttributeForElementIndex(index, name, value) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addAttr(name, value);
  }
  function removeAttributeForElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeAttr(name);
  }
  function getAttributeFromElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    if (accessor) {
      return accessor.getAttr(name);
    } else {
      return null;
    }
  }
  function getPrimaryTextAtIndex(index) {
    var _a3;
    const accessor = getOrderedList()[index];
    return (_a3 = accessor && accessor.getPrimaryText()) !== null && _a3 !== void 0 ? _a3 : "";
  }
  function getListItemIndex(element3) {
    const nearestParent = closest2(element3, ".mdc-deprecated-list-item, .mdc-deprecated-list");
    if (nearestParent && matches2(nearestParent, ".mdc-deprecated-list-item")) {
      return getOrderedList().map((item) => item === null || item === void 0 ? void 0 : item.element).indexOf(nearestParent);
    }
    return -1;
  }
  function layout() {
    return instance2.layout();
  }
  function setEnabled(itemIndex, isEnabled) {
    return instance2.setEnabled(itemIndex, isEnabled);
  }
  function getTypeaheadInProgress() {
    return instance2.isTypeaheadInProgress();
  }
  function getSelectedIndex() {
    return instance2.getSelectedIndex();
  }
  function getFocusedItemIndex() {
    return instance2.getFocusedItemIndex();
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(14, element2);
    });
  }
  const keydown_handler = (event) => instance2 && instance2.handleKeydown(event, event.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event.target));
  const focusin_handler = (event) => instance2 && instance2.handleFocusIn(getListItemIndex(event.target));
  const focusout_handler = (event) => instance2 && instance2.handleFocusOut(getListItemIndex(event.target));
  const click_handler = (event) => instance2 && instance2.handleClick(getListItemIndex(event.target), !matches2(event.target, 'input[type="checkbox"], input[type="radio"]'));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("nonInteractive" in $$new_props)
      $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    if ("dense" in $$new_props)
      $$invalidate(3, dense = $$new_props.dense);
    if ("textualList" in $$new_props)
      $$invalidate(4, textualList = $$new_props.textualList);
    if ("avatarList" in $$new_props)
      $$invalidate(5, avatarList = $$new_props.avatarList);
    if ("iconList" in $$new_props)
      $$invalidate(6, iconList = $$new_props.iconList);
    if ("imageList" in $$new_props)
      $$invalidate(7, imageList = $$new_props.imageList);
    if ("thumbnailList" in $$new_props)
      $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
    if ("videoList" in $$new_props)
      $$invalidate(9, videoList = $$new_props.videoList);
    if ("twoLine" in $$new_props)
      $$invalidate(10, twoLine = $$new_props.twoLine);
    if ("threeLine" in $$new_props)
      $$invalidate(11, threeLine = $$new_props.threeLine);
    if ("vertical" in $$new_props)
      $$invalidate(25, vertical = $$new_props.vertical);
    if ("wrapFocus" in $$new_props)
      $$invalidate(26, wrapFocus = $$new_props.wrapFocus);
    if ("singleSelection" in $$new_props)
      $$invalidate(27, singleSelection = $$new_props.singleSelection);
    if ("selectedIndex" in $$new_props)
      $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
    if ("radioList" in $$new_props)
      $$invalidate(28, radioList = $$new_props.radioList);
    if ("checkList" in $$new_props)
      $$invalidate(29, checkList = $$new_props.checkList);
    if ("hasTypeahead" in $$new_props)
      $$invalidate(30, hasTypeahead = $$new_props.hasTypeahead);
    if ("component" in $$new_props)
      $$invalidate(12, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 33562624) {
      if (instance2) {
        instance2.setVerticalOrientation(vertical);
      }
    }
    if ($$self.$$.dirty[0] & 67117056) {
      if (instance2) {
        instance2.setWrapFocus(wrapFocus);
      }
    }
    if ($$self.$$.dirty[0] & 1073750016) {
      if (instance2) {
        instance2.setHasTypeahead(hasTypeahead);
      }
    }
    if ($$self.$$.dirty[0] & 134225920) {
      if (instance2) {
        instance2.setSingleSelection(singleSelection);
      }
    }
    if ($$self.$$.dirty[0] & 151003136) {
      if (instance2 && singleSelection && getSelectedIndex() !== selectedIndex) {
        instance2.setSelectedIndex(selectedIndex);
      }
    }
  };
  return [
    use,
    className,
    nonInteractive,
    dense,
    textualList,
    avatarList,
    iconList,
    imageList,
    thumbnailList,
    videoList,
    twoLine,
    threeLine,
    component,
    instance2,
    element2,
    role,
    matches2,
    forwardEvents,
    selectionDialog,
    handleItemMount,
    handleItemUnmount,
    handleAction,
    getListItemIndex,
    $$restProps,
    selectedIndex,
    vertical,
    wrapFocus,
    singleSelection,
    radioList,
    checkList,
    hasTypeahead,
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    getElement,
    slots,
    switch_instance_binding,
    keydown_handler,
    focusin_handler,
    focusout_handler,
    click_handler,
    $$scope
  ];
}
class List extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$6, create_fragment$p, safe_not_equal, {
      use: 0,
      class: 1,
      nonInteractive: 2,
      dense: 3,
      textualList: 4,
      avatarList: 5,
      iconList: 6,
      imageList: 7,
      thumbnailList: 8,
      videoList: 9,
      twoLine: 10,
      threeLine: 11,
      vertical: 25,
      wrapFocus: 26,
      singleSelection: 27,
      selectedIndex: 24,
      radioList: 28,
      checkList: 29,
      hasTypeahead: 30,
      component: 12,
      layout: 31,
      setEnabled: 32,
      getTypeaheadInProgress: 33,
      getSelectedIndex: 34,
      getFocusedItemIndex: 35,
      getElement: 36
    }, null, [-1, -1]);
  }
  get layout() {
    return this.$$.ctx[31];
  }
  get setEnabled() {
    return this.$$.ctx[32];
  }
  get getTypeaheadInProgress() {
    return this.$$.ctx[33];
  }
  get getSelectedIndex() {
    return this.$$.ctx[34];
  }
  get getFocusedItemIndex() {
    return this.$$.ctx[35];
  }
  get getElement() {
    return this.$$.ctx[36];
  }
}
function create_if_block$d(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "mdc-deprecated-list-item__ripple");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot$8(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[7] && create_if_block$d();
  const default_slot_template = ctx[32].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[35], null);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[7]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$d();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 16)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[35], !current ? get_all_dirty_from_scope(ctx2[35]) : get_slot_changes(default_slot_template, ctx2[35], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$o(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        ...ctx[6] ? [] : [
          [
            Ripple,
            {
              ripple: !ctx[14],
              unbounded: false,
              color: (ctx[1] || ctx[0]) && ctx[5] == null ? "primary" : ctx[5],
              disabled: ctx[9],
              addClass: ctx[22],
              removeClass: ctx[23],
              addStyle: ctx[24]
            }
          ]
        ],
        ctx[20],
        ...ctx[2]
      ]
    },
    {
      class: classMap(__spreadValues({
        [ctx[3]]: true,
        "mdc-deprecated-list-item": true,
        "mdc-deprecated-list-item--activated": ctx[1],
        "mdc-deprecated-list-item--selected": ctx[0],
        "mdc-deprecated-list-item--disabled": ctx[9],
        "mdc-menu-item--selected": !ctx[21] && ctx[8] === "menuitem" && ctx[0],
        "smui-menu-item--non-interactive": ctx[6]
      }, ctx[16]))
    },
    {
      style: Object.entries(ctx[17]).map(func$6).concat([ctx[4]]).join(" ")
    },
    ctx[21] && ctx[1] ? { "aria-current": "page" } : {},
    !ctx[21] ? { role: ctx[8] } : {},
    !ctx[21] && ctx[8] === "option" ? {
      "aria-selected": ctx[0] ? "true" : "false"
    } : {},
    !ctx[21] && (ctx[8] === "radio" || ctx[8] === "checkbox") ? {
      "aria-checked": ctx[14] && ctx[14].checked ? "true" : "false"
    } : {},
    !ctx[21] ? {
      "aria-disabled": ctx[9] ? "true" : "false"
    } : {},
    {
      "data-menu-item-skip-restore-focus": ctx[10] || void 0
    },
    { tabindex: ctx[19] },
    { href: ctx[11] },
    ctx[18],
    ctx[27]
  ];
  var switch_value = ctx[12];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    ctx[33](switch_instance);
    switch_instance.$on("click", ctx[13]);
    switch_instance.$on("keydown", ctx[25]);
    switch_instance.$on("SMUIGenericInput:mount", ctx[26]);
    switch_instance.$on("SMUIGenericInput:unmount", ctx[34]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & 167726975 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & 30425703 && {
          use: [
            ...ctx2[6] ? [] : [
              [
                Ripple,
                {
                  ripple: !ctx2[14],
                  unbounded: false,
                  color: (ctx2[1] || ctx2[0]) && ctx2[5] == null ? "primary" : ctx2[5],
                  disabled: ctx2[9],
                  addClass: ctx2[22],
                  removeClass: ctx2[23],
                  addStyle: ctx2[24]
                }
              ]
            ],
            ctx2[20],
            ...ctx2[2]
          ]
        },
        dirty[0] & 2163531 && {
          class: classMap(__spreadValues({
            [ctx2[3]]: true,
            "mdc-deprecated-list-item": true,
            "mdc-deprecated-list-item--activated": ctx2[1],
            "mdc-deprecated-list-item--selected": ctx2[0],
            "mdc-deprecated-list-item--disabled": ctx2[9],
            "mdc-menu-item--selected": !ctx2[21] && ctx2[8] === "menuitem" && ctx2[0],
            "smui-menu-item--non-interactive": ctx2[6]
          }, ctx2[16]))
        },
        dirty[0] & 131088 && {
          style: Object.entries(ctx2[17]).map(func$6).concat([ctx2[4]]).join(" ")
        },
        dirty[0] & 2097154 && get_spread_object(ctx2[21] && ctx2[1] ? { "aria-current": "page" } : {}),
        dirty[0] & 2097408 && get_spread_object(!ctx2[21] ? { role: ctx2[8] } : {}),
        dirty[0] & 2097409 && get_spread_object(!ctx2[21] && ctx2[8] === "option" ? {
          "aria-selected": ctx2[0] ? "true" : "false"
        } : {}),
        dirty[0] & 2113792 && get_spread_object(!ctx2[21] && (ctx2[8] === "radio" || ctx2[8] === "checkbox") ? {
          "aria-checked": ctx2[14] && ctx2[14].checked ? "true" : "false"
        } : {}),
        dirty[0] & 2097664 && get_spread_object(!ctx2[21] ? {
          "aria-disabled": ctx2[9] ? "true" : "false"
        } : {}),
        dirty[0] & 1024 && {
          "data-menu-item-skip-restore-focus": ctx2[10] || void 0
        },
        dirty[0] & 524288 && { tabindex: ctx2[19] },
        dirty[0] & 2048 && { href: ctx2[11] },
        dirty[0] & 262144 && get_spread_object(ctx2[18]),
        dirty[0] & 134217728 && get_spread_object(ctx2[27])
      ]) : {};
      if (dirty[0] & 128 | dirty[1] & 16) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[12])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          ctx2[33](switch_instance);
          switch_instance.$on("click", ctx2[13]);
          switch_instance.$on("keydown", ctx2[25]);
          switch_instance.$on("SMUIGenericInput:mount", ctx2[26]);
          switch_instance.$on("SMUIGenericInput:unmount", ctx2[34]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[33](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
let counter$1 = 0;
const func$6 = ([name, value]) => `${name}: ${value};`;
function instance$h($$self, $$props, $$invalidate) {
  let tabindex;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "color",
    "nonInteractive",
    "ripple",
    "activated",
    "role",
    "selected",
    "disabled",
    "skipRestoreFocus",
    "tabindex",
    "inputId",
    "href",
    "component",
    "action",
    "getPrimaryText",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a2;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { color = void 0 } = $$props;
  let { nonInteractive = (_a2 = getContext("SMUI:list:nonInteractive")) !== null && _a2 !== void 0 ? _a2 : false } = $$props;
  setContext("SMUI:list:nonInteractive", void 0);
  let { ripple = !nonInteractive } = $$props;
  let { activated = false } = $$props;
  let { role = getContext("SMUI:list:item:role") } = $$props;
  setContext("SMUI:list:item:role", void 0);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { skipRestoreFocus = false } = $$props;
  let { tabindex: tabindexProp = uninitializedValue } = $$props;
  let { inputId = "SMUI-form-field-list-" + counter$1++ } = $$props;
  let { href = void 0 } = $$props;
  let element2;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let input;
  let addTabindexIfNoItemsSelectedRaf;
  let nav = getContext("SMUI:list:item:nav");
  let { component = nav ? href ? A : Span : Li } = $$props;
  setContext("SMUI:generic:input:props", { id: inputId });
  setContext("SMUI:separator:context", void 0);
  onMount(() => {
    if (!selected && !nonInteractive) {
      let first = true;
      let el = element2;
      while (el.previousSibling) {
        el = el.previousSibling;
        if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
          first = false;
          break;
        }
      }
      if (first) {
        addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
      }
    }
    const accessor = {
      _smui_list_item_accessor: true,
      get element() {
        return getElement();
      },
      get selected() {
        return selected;
      },
      set selected(value) {
        $$invalidate(0, selected = value);
      },
      hasClass,
      addClass,
      removeClass,
      getAttr,
      addAttr,
      removeAttr,
      getPrimaryText,
      get checked() {
        var _a3;
        return (_a3 = input && input.checked) !== null && _a3 !== void 0 ? _a3 : false;
      },
      set checked(value) {
        if (input) {
          $$invalidate(14, input.checked = !!value, input);
        }
      },
      get hasCheckbox() {
        return !!(input && "_smui_checkbox_accessor" in input);
      },
      get hasRadio() {
        return !!(input && "_smui_radio_accessor" in input);
      },
      activateRipple() {
        if (input) {
          input.activateRipple();
        }
      },
      deactivateRipple() {
        if (input) {
          input.deactivateRipple();
        }
      },
      getValue() {
        return $$restProps.value;
      },
      action,
      get tabindex() {
        return tabindex;
      },
      set tabindex(value) {
        $$invalidate(28, tabindexProp = value);
      },
      get disabled() {
        return disabled;
      },
      get activated() {
        return activated;
      },
      set activated(value) {
        $$invalidate(1, activated = value);
      }
    };
    dispatch(getElement(), "SMUIListItem:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIListItem:unmount", accessor);
    };
  });
  onDestroy(() => {
    if (addTabindexIfNoItemsSelectedRaf) {
      window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(16, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(16, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(17, internalStyles);
      } else {
        $$invalidate(17, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getAttr(name) {
    var _a3;
    return name in internalAttrs ? (_a3 = internalAttrs[name]) !== null && _a3 !== void 0 ? _a3 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(18, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(18, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function addTabindexIfNoItemsSelected() {
    let noneSelected = true;
    let el = element2.getElement();
    while (el.nextElementSibling) {
      el = el.nextElementSibling;
      if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item")) {
        const tabindexAttr = el.attributes.getNamedItem("tabindex");
        if (tabindexAttr && tabindexAttr.value === "0") {
          noneSelected = false;
          break;
        }
      }
    }
    if (noneSelected) {
      $$invalidate(19, tabindex = 0);
    }
  }
  function handleKeydown2(e) {
    const isEnter = e.key === "Enter";
    const isSpace = e.key === "Space";
    if (isEnter || isSpace) {
      action(e);
    }
  }
  function handleInputMount(e) {
    if ("_smui_checkbox_accessor" in e.detail || "_smui_radio_accessor" in e.detail) {
      $$invalidate(14, input = e.detail);
    }
  }
  function action(e) {
    if (!disabled) {
      dispatch(getElement(), "SMUI:action", e);
    }
  }
  function getPrimaryText() {
    var _a3, _b2, _c;
    const element3 = getElement();
    const primaryText = element3.querySelector(".mdc-deprecated-list-item__primary-text");
    if (primaryText) {
      return (_a3 = primaryText.textContent) !== null && _a3 !== void 0 ? _a3 : "";
    }
    const text2 = element3.querySelector(".mdc-deprecated-list-item__text");
    if (text2) {
      return (_b2 = text2.textContent) !== null && _b2 !== void 0 ? _b2 : "";
    }
    return (_c = element3.textContent) !== null && _c !== void 0 ? _c : "";
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(15, element2);
    });
  }
  const SMUIGenericInput_unmount_handler = () => $$invalidate(14, input = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(27, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("nonInteractive" in $$new_props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("ripple" in $$new_props)
      $$invalidate(7, ripple = $$new_props.ripple);
    if ("activated" in $$new_props)
      $$invalidate(1, activated = $$new_props.activated);
    if ("role" in $$new_props)
      $$invalidate(8, role = $$new_props.role);
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("skipRestoreFocus" in $$new_props)
      $$invalidate(10, skipRestoreFocus = $$new_props.skipRestoreFocus);
    if ("tabindex" in $$new_props)
      $$invalidate(28, tabindexProp = $$new_props.tabindex);
    if ("inputId" in $$new_props)
      $$invalidate(29, inputId = $$new_props.inputId);
    if ("href" in $$new_props)
      $$invalidate(11, href = $$new_props.href);
    if ("component" in $$new_props)
      $$invalidate(12, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(35, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 268452417) {
      $$invalidate(19, tabindex = isUninitializedValue(tabindexProp) ? !nonInteractive && !disabled && (selected || input && input.checked) ? 0 : -1 : tabindexProp);
    }
  };
  return [
    selected,
    activated,
    use,
    className,
    style,
    color,
    nonInteractive,
    ripple,
    role,
    disabled,
    skipRestoreFocus,
    href,
    component,
    action,
    input,
    element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    tabindex,
    forwardEvents,
    nav,
    addClass,
    removeClass,
    addStyle,
    handleKeydown2,
    handleInputMount,
    $$restProps,
    tabindexProp,
    inputId,
    getPrimaryText,
    getElement,
    slots,
    switch_instance_binding,
    SMUIGenericInput_unmount_handler,
    $$scope
  ];
}
class Item$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$o, safe_not_equal, {
      use: 2,
      class: 3,
      style: 4,
      color: 5,
      nonInteractive: 6,
      ripple: 7,
      activated: 1,
      role: 8,
      selected: 0,
      disabled: 9,
      skipRestoreFocus: 10,
      tabindex: 28,
      inputId: 29,
      href: 11,
      component: 12,
      action: 13,
      getPrimaryText: 30,
      getElement: 31
    }, null, [-1, -1]);
  }
  get action() {
    return this.$$.ctx[13];
  }
  get getPrimaryText() {
    return this.$$.ctx[30];
  }
  get getElement() {
    return this.$$.ctx[31];
  }
}
var Text = classAdderBuilder({
  class: "mdc-deprecated-list-item__text",
  component: Span
});
classAdderBuilder({
  class: "mdc-deprecated-list-item__primary-text",
  component: Span
});
classAdderBuilder({
  class: "mdc-deprecated-list-item__secondary-text",
  component: Span
});
var Meta = classAdderBuilder({
  class: "mdc-deprecated-list-item__meta",
  component: Span
});
classAdderBuilder({
  class: "mdc-deprecated-list-group",
  component: Div
});
classAdderBuilder({
  class: "mdc-deprecated-list-group__subheader",
  component: H3
});
function create_fragment$n(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [ctx[9], ...ctx[0]]
    },
    {
      class: classMap({
        [ctx[1]]: true,
        "mdc-deprecated-list-divider": true,
        "mdc-deprecated-list-divider--padded": ctx[2],
        "mdc-deprecated-list-divider--inset": ctx[3],
        "mdc-deprecated-list-divider--inset-leading": ctx[4],
        "mdc-deprecated-list-divider--inset-trailing": ctx[5],
        "mdc-deprecated-list-divider--inset-padding": ctx[6]
      })
    },
    { role: "separator" },
    ctx[10]
  ];
  var switch_value = ctx[7];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
    ctx[12](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 1663 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 513 && {
          use: [ctx2[9], ...ctx2[0]]
        },
        dirty & 126 && {
          class: classMap({
            [ctx2[1]]: true,
            "mdc-deprecated-list-divider": true,
            "mdc-deprecated-list-divider--padded": ctx2[2],
            "mdc-deprecated-list-divider--inset": ctx2[3],
            "mdc-deprecated-list-divider--inset-leading": ctx2[4],
            "mdc-deprecated-list-divider--inset-trailing": ctx2[5],
            "mdc-deprecated-list-divider--inset-padding": ctx2[6]
          })
        },
        switch_instance_spread_levels[2],
        dirty & 1024 && get_spread_object(ctx2[10])
      ]) : {};
      if (switch_value !== (switch_value = ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          ctx2[12](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[12](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "padded",
    "inset",
    "insetLeading",
    "insetTrailing",
    "insetPadding",
    "component",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { padded = false } = $$props;
  let { inset = false } = $$props;
  let { insetLeading = false } = $$props;
  let { insetTrailing = false } = $$props;
  let { insetPadding = false } = $$props;
  let element2;
  let nav = getContext("SMUI:list:item:nav");
  let context = getContext("SMUI:separator:context");
  let { component = nav || context !== "list" ? Hr : Li } = $$props;
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("padded" in $$new_props)
      $$invalidate(2, padded = $$new_props.padded);
    if ("inset" in $$new_props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("insetLeading" in $$new_props)
      $$invalidate(4, insetLeading = $$new_props.insetLeading);
    if ("insetTrailing" in $$new_props)
      $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
    if ("insetPadding" in $$new_props)
      $$invalidate(6, insetPadding = $$new_props.insetPadding);
    if ("component" in $$new_props)
      $$invalidate(7, component = $$new_props.component);
  };
  return [
    use,
    className,
    padded,
    inset,
    insetLeading,
    insetTrailing,
    insetPadding,
    component,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    switch_instance_binding
  ];
}
class Separator$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$n, safe_not_equal, {
      use: 0,
      class: 1,
      padded: 2,
      inset: 3,
      insetLeading: 4,
      insetTrailing: 5,
      insetPadding: 6,
      component: 7,
      getElement: 11
    });
  }
  get getElement() {
    return this.$$.ctx[11];
  }
}
const Item = Item$1;
const Separator = Separator$1;
function notificationsStore(initialValue = []) {
  const store = writable(initialValue);
  const { set, update: update2, subscribe: subscribe2 } = store;
  let defaultOptions = {
    duration: 3e3,
    placement: "bottom-right",
    type: "info",
    theme: "dark"
  };
  function add(options) {
    const _a2 = __spreadValues(__spreadValues({}, defaultOptions), options), {
      duration = 3e3,
      placement = "bottom-right",
      type: type2 = "info",
      theme = "dark"
    } = _a2, rest = __objRest(_a2, [
      "duration",
      "placement",
      "type",
      "theme"
    ]);
    const uid = Date.now();
    const obj = __spreadProps(__spreadValues({}, rest), {
      uid,
      placement,
      type: type2,
      theme,
      duration,
      remove: () => {
        update2((v) => v.filter((i) => i.uid !== uid));
      },
      update: (data) => {
        var _a3;
        delete data.uid;
        const index = (_a3 = get_store_value(store)) == null ? void 0 : _a3.findIndex((v) => (v == null ? void 0 : v.uid) === uid);
        if (index > -1) {
          update2((v) => [
            ...v.slice(0, index),
            __spreadValues(__spreadValues({}, v[index]), data),
            ...v.slice(index + 1)
          ]);
        }
      }
    });
    update2((v) => [...v, obj]);
    if (duration > 0) {
      setTimeout(() => {
        obj.remove();
        if (typeof obj.onRemove === "function")
          obj.onRemove();
      }, duration);
    }
    return obj;
  }
  function getById(uid) {
    var _a2;
    return (_a2 = get_store_value(store)) == null ? void 0 : _a2.find((v) => (v == null ? void 0 : v.uid) === uid);
  }
  function clearAll() {
    set([]);
  }
  function clearLast() {
    update2((v) => {
      return v.slice(0, v.length - 1);
    });
  }
  function setDefaults(options) {
    defaultOptions = __spreadValues(__spreadValues({}, defaultOptions), options);
  }
  return {
    subscribe: subscribe2,
    add,
    success: getHelper("success", add),
    info: getHelper("info", add),
    error: getHelper("error", add),
    warning: getHelper("warning", add),
    clearAll,
    clearLast,
    getById,
    setDefaults
  };
}
const toasts = notificationsStore([]);
function getHelper(type2, add) {
  return function() {
    if (typeof arguments[0] === "object") {
      const options = arguments[0];
      return add(__spreadProps(__spreadValues({}, options), { type: type2 }));
    } else if (typeof arguments[0] === "string" && typeof arguments[1] === "string") {
      const options = arguments[2] || {};
      return add(__spreadProps(__spreadValues({}, options), {
        type: type2,
        title: arguments[0],
        description: arguments[1]
      }));
    } else if (typeof arguments[0] === "string") {
      const options = arguments[1] || {};
      return add(__spreadProps(__spreadValues({}, options), {
        type: type2,
        description: arguments[0]
      }));
    }
  };
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  return {
    delay,
    duration,
    easing,
    css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
  };
}
function flip(node, { from, to }, params2 = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from.left + from.width * ox / to.width - (to.left + ox);
  const dy = from.top + from.height * oy / to.height - (to.top + oy);
  const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params2;
  return {
    delay,
    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t, u) => {
      const x = u * dx;
      const y = u * dy;
      const sx = t + u * from.width / to.width;
      const sy = t + u * from.height / to.height;
      return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
    }
  };
}
var ToastContainer_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
const get_default_slot_changes = (dirty) => ({ data: dirty & 4 });
const get_default_slot_context = (ctx) => ({ data: ctx[14] });
function create_else_block$4(ctx) {
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], get_default_slot_context);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 516)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[9], !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, get_default_slot_changes), get_default_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$c(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[14].component;
  function switch_props(ctx2) {
    return { props: { data: ctx2[14] } };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 4)
        switch_instance_changes.data = ctx2[14];
      if (switch_value !== (switch_value = ctx2[14].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let t;
  let li_intro;
  let li_outro;
  let rect;
  let stop_animation = noop;
  let current;
  const if_block_creators = [create_if_block$c, create_else_block$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[14].component)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      if_block.c();
      t = space();
      attr(li, "class", "svelte-1hjafm2");
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      append(li, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, t);
      }
    },
    r() {
      rect = li.getBoundingClientRect();
    },
    f() {
      fix_position(li);
      stop_animation();
      add_transform(li, rect);
    },
    a() {
      stop_animation();
      stop_animation = create_animation(li, rect, flip, {});
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      add_render_callback(() => {
        if (li_outro)
          li_outro.end(1);
        li_intro = create_in_transition(li, fade, { duration: 500 });
        li_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (li_intro)
        li_intro.invalidate();
      li_outro = create_out_transition(li, fly, {
        y: ctx[4][ctx[14].placement],
        duration: 1e3
      });
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if_blocks[current_block_type_index].d();
      if (detaching && li_outro)
        li_outro.end();
    }
  };
}
function create_each_block(ctx) {
  let div;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let div_class_value;
  let current;
  function func2(...args) {
    return ctx[11](ctx[1], ...args);
  }
  let each_value_1 = ctx[2].filter(func2).reverse();
  const get_key = (ctx2) => ctx2[14].uid;
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(ul, "class", "svelte-1hjafm2");
      attr(div, "class", div_class_value = "toast-container " + ctx[1] + " svelte-1hjafm2");
      set_style(div, "width", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      append(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 540) {
        each_value_1 = ctx[2].filter(func2).reverse();
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!current || dirty & 1) {
        set_style(div, "width", ctx[0]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_fragment$m(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 541) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $toasts;
  component_subscribe($$self, toasts, ($$value) => $$invalidate(2, $toasts = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { theme = "dark" } = $$props;
  let { placement = "bottom-right" } = $$props;
  let { type: type2 = "info" } = $$props;
  let { showProgress = false } = $$props;
  let { duration = 3e3 } = $$props;
  let { width = "320px" } = $$props;
  const placements = [
    "bottom-right",
    "bottom-left",
    "top-right",
    "top-left",
    "top-center",
    "bottom-center",
    "center-center"
  ];
  const flyMap = {
    "bottom-right": 400,
    "top-right": -400,
    "bottom-left": 400,
    "top-left": -400,
    "bottom-center": 400,
    "top-center": -400,
    "center-center": -800
  };
  onMount(() => {
    toasts.setDefaults({
      placement,
      showProgress,
      theme,
      duration,
      type: type2
    });
  });
  const func2 = (placement2, n) => n.placement === placement2;
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(5, theme = $$props2.theme);
    if ("placement" in $$props2)
      $$invalidate(1, placement = $$props2.placement);
    if ("type" in $$props2)
      $$invalidate(6, type2 = $$props2.type);
    if ("showProgress" in $$props2)
      $$invalidate(7, showProgress = $$props2.showProgress);
    if ("duration" in $$props2)
      $$invalidate(8, duration = $$props2.duration);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    width,
    placement,
    $toasts,
    placements,
    flyMap,
    theme,
    type2,
    showProgress,
    duration,
    $$scope,
    slots,
    func2
  ];
}
class ToastContainer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$m, safe_not_equal, {
      theme: 5,
      placement: 1,
      type: 6,
      showProgress: 7,
      duration: 8,
      width: 0
    });
  }
}
var BootstrapToast_svelte_svelte_type_style_lang = "";
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
function get_interpolator(a, b) {
  if (a === b || a !== a)
    return () => a;
  const type2 = typeof a;
  if (type2 !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
    throw new Error("Cannot interpolate values of different type");
  }
  if (Array.isArray(a)) {
    const arr = b.map((bi, i) => {
      return get_interpolator(a[i], bi);
    });
    return (t) => arr.map((fn) => fn(t));
  }
  if (type2 === "object") {
    if (!a || !b)
      throw new Error("Object cannot be null");
    if (is_date(a) && is_date(b)) {
      a = a.getTime();
      b = b.getTime();
      const delta = b - a;
      return (t) => new Date(a + t * delta);
    }
    const keys = Object.keys(b);
    const interpolators = {};
    keys.forEach((key) => {
      interpolators[key] = get_interpolator(a[key], b[key]);
    });
    return (t) => {
      const result = {};
      keys.forEach((key) => {
        result[key] = interpolators[key](t);
      });
      return result;
    };
  }
  if (type2 === "number") {
    const delta = b - a;
    return (t) => a + t * delta;
  }
  throw new Error(`Cannot interpolate ${type2} values`);
}
function tweened(value, defaults2 = {}) {
  const store = writable(value);
  let task;
  let target_value = value;
  function set(new_value, opts) {
    if (value == null) {
      store.set(value = new_value);
      return Promise.resolve();
    }
    target_value = new_value;
    let previous_task = task;
    let started = false;
    let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults2), opts);
    if (duration === 0) {
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      store.set(value = target_value);
      return Promise.resolve();
    }
    const start2 = now() + delay;
    let fn;
    task = loop((now2) => {
      if (now2 < start2)
        return true;
      if (!started) {
        fn = interpolate(value, new_value);
        if (typeof duration === "function")
          duration = duration(value, new_value);
        started = true;
      }
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      const elapsed = now2 - start2;
      if (elapsed > duration) {
        store.set(value = new_value);
        return false;
      }
      store.set(value = fn(easing(elapsed / duration)));
      return true;
    });
    return task.promise;
  }
  return {
    set,
    update: (fn, opts) => set(fn(target_value, value), opts),
    subscribe: store.subscribe
  };
}
var FlatToast_svelte_svelte_type_style_lang = "";
const get_close_icon_slot_changes = (dirty) => ({});
const get_close_icon_slot_context = (ctx) => ({});
const get_extra_slot_changes = (dirty) => ({});
const get_extra_slot_context = (ctx) => ({});
const get_icon_slot_changes = (dirty) => ({});
const get_icon_slot_context = (ctx) => ({});
function create_else_block$3(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1	s1,0.4,1,1S10.6,16,10,16z");
      attr(path0, "class", "svelte-1hg1dbm");
      attr(path1, "d", "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z");
      attr(path1, "data-icon-path", "inner-path");
      attr(path1, "opacity", "0");
      attr(path1, "class", "svelte-1hg1dbm");
      attr(svg, "class", "st-toast-icon svelte-1hg1dbm");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "20");
      attr(svg, "height", "20");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_4$1(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
      attr(path0, "class", "svelte-1hg1dbm");
      attr(path1, "d", "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
      attr(path1, "data-icon-path", "inner-path");
      attr(path1, "opacity", "0");
      attr(path1, "class", "svelte-1hg1dbm");
      attr(svg, "class", "st-toast-icon svelte-1hg1dbm");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "20");
      attr(svg, "height", "20");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_3$1(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.12H12V21.88h2.88V15.12H13V12.88h4.13v9H20Z");
      attr(path, "class", "svelte-1hg1dbm");
      attr(svg, "class", "st-toast-icon svelte-1hg1dbm");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "20");
      attr(svg, "height", "20");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_2$1(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "d", "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
      attr(path0, "class", "svelte-1hg1dbm");
      attr(path1, "fill", "none");
      attr(path1, "d", "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
      attr(path1, "data-icon-path", "inner-path");
      attr(path1, "opacity", "0");
      attr(path1, "class", "svelte-1hg1dbm");
      attr(svg, "class", "st-toast-icon svelte-1hg1dbm");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "20");
      attr(svg, "height", "20");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function fallback_block_1(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].type === "success")
      return create_if_block_2$1;
    if (ctx2[1].type === "info")
      return create_if_block_3$1;
    if (ctx2[1].type === "error")
      return create_if_block_4$1;
    return create_else_block$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$3(ctx) {
  let h3;
  let t_value = ctx[1].title + "";
  let t;
  return {
    c() {
      h3 = element("h3");
      t = text(t_value);
      attr(h3, "class", "st-toast-title svelte-1hg1dbm");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(h3);
    }
  };
}
function fallback_block(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
      attr(path, "class", "svelte-1hg1dbm");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "bx--toast-notification__close-icon svelte-1hg1dbm");
      attr(svg, "width", "20");
      attr(svg, "height", "20");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block$b(ctx) {
  let progress_1;
  return {
    c() {
      progress_1 = element("progress");
      set_style(progress_1, "height", ctx[1].duration > 0 ? "4px" : 0);
      progress_1.value = ctx[2];
      attr(progress_1, "class", "svelte-1hg1dbm");
    },
    m(target, anchor) {
      insert(target, progress_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        set_style(progress_1, "height", ctx2[1].duration > 0 ? "4px" : 0);
      }
      if (dirty & 4) {
        progress_1.value = ctx2[2];
      }
    },
    d(detaching) {
      if (detaching)
        detach(progress_1);
    }
  };
}
function create_fragment$l(ctx) {
  let div2;
  let t0;
  let div1;
  let t1;
  let p2;
  let t2_value = ctx[1].description + "";
  let t2;
  let t3;
  let div0;
  let t4;
  let button;
  let t5;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = ctx[7].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[6], get_icon_slot_context);
  const icon_slot_or_fallback = icon_slot || fallback_block_1(ctx);
  let if_block0 = ctx[1].title && create_if_block_1$3(ctx);
  const extra_slot_template = ctx[7].extra;
  const extra_slot = create_slot(extra_slot_template, ctx, ctx[6], get_extra_slot_context);
  const close_icon_slot_template = ctx[7]["close-icon"];
  const close_icon_slot = create_slot(close_icon_slot_template, ctx, ctx[6], get_close_icon_slot_context);
  const close_icon_slot_or_fallback = close_icon_slot || fallback_block();
  let if_block1 = ctx[1].showProgress && create_if_block$b(ctx);
  return {
    c() {
      div2 = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      t3 = space();
      div0 = element("div");
      if (extra_slot)
        extra_slot.c();
      t4 = space();
      button = element("button");
      if (close_icon_slot_or_fallback)
        close_icon_slot_or_fallback.c();
      t5 = space();
      if (if_block1)
        if_block1.c();
      attr(p2, "class", "st-toast-description svelte-1hg1dbm");
      attr(div0, "class", "st-toast-extra svelte-1hg1dbm");
      attr(div1, "class", "st-toast-details svelte-1hg1dbm");
      attr(button, "class", "st-toast-close-btn svelte-1hg1dbm");
      attr(button, "type", "button");
      attr(button, "aria-label", "close");
      attr(div2, "class", div2_class_value = "st-toast flat " + (ctx[1].theme || ctx[0]) + " " + (ctx[1].type || "info") + " svelte-1hg1dbm");
      attr(div2, "role", "alert");
      attr(div2, "aria-live", "assertive");
      attr(div2, "aria-atomic", "true");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div2, null);
      }
      append(div2, t0);
      append(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t1);
      append(div1, p2);
      append(p2, t2);
      append(div1, t3);
      append(div1, div0);
      if (extra_slot) {
        extra_slot.m(div0, null);
      }
      append(div2, t4);
      append(div2, button);
      if (close_icon_slot_or_fallback) {
        close_icon_slot_or_fallback.m(button, null);
      }
      append(div2, t5);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[4]),
          listen(div2, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 64)) {
          update_slot_base(icon_slot, icon_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(icon_slot_template, ctx2[6], dirty, get_icon_slot_changes), get_icon_slot_context);
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 2)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (ctx2[1].title) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$3(ctx2);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & 2) && t2_value !== (t2_value = ctx2[1].description + ""))
        set_data(t2, t2_value);
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & 64)) {
          update_slot_base(extra_slot, extra_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(extra_slot_template, ctx2[6], dirty, get_extra_slot_changes), get_extra_slot_context);
        }
      }
      if (close_icon_slot) {
        if (close_icon_slot.p && (!current || dirty & 64)) {
          update_slot_base(close_icon_slot, close_icon_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(close_icon_slot_template, ctx2[6], dirty, get_close_icon_slot_changes), get_close_icon_slot_context);
        }
      }
      if (ctx2[1].showProgress) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$b(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 3 && div2_class_value !== (div2_class_value = "st-toast flat " + (ctx2[1].theme || ctx2[0]) + " " + (ctx2[1].type || "info") + " svelte-1hg1dbm")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(extra_slot, local);
      transition_in(close_icon_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(extra_slot, local);
      transition_out(close_icon_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (if_block0)
        if_block0.d();
      if (extra_slot)
        extra_slot.d(detaching);
      if (close_icon_slot_or_fallback)
        close_icon_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $progress;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { theme = "light" } = $$props;
  let { data = {} } = $$props;
  const progress = tweened(1, { duration: data.duration, easing: identity });
  component_subscribe($$self, progress, (value) => $$invalidate(2, $progress = value));
  onMount(() => {
    progress.set(0, { duration: data.duration });
  });
  const onRemove = (e) => {
    e.stopPropagation();
    data.remove();
    if (typeof data.onRemove === "function")
      data.onRemove();
  };
  const onClick = () => {
    if (typeof data.onClick === "function")
      data.onClick();
  };
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [theme, data, $progress, progress, onRemove, onClick, $$scope, slots];
}
class FlatToast extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$l, safe_not_equal, { theme: 0, data: 1 });
  }
}
var Env;
((Env2) => {
  Env2.isProduction = Boolean(false);
})(Env || (Env = {}));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var leafletSrc = { exports: {} };
/* @preserve
 * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    var version = "1.7.1";
    function extend(dest) {
      var i, j, len, src;
      for (j = 1, len = arguments.length; j < len; j++) {
        src = arguments[j];
        for (i in src) {
          dest[i] = src[i];
        }
      }
      return dest;
    }
    var create = Object.create || function() {
      function F() {
      }
      return function(proto) {
        F.prototype = proto;
        return new F();
      };
    }();
    function bind2(fn, obj) {
      var slice = Array.prototype.slice;
      if (fn.bind) {
        return fn.bind.apply(fn, slice.call(arguments, 1));
      }
      var args = slice.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
      };
    }
    var lastId = 0;
    function stamp(obj) {
      obj._leaflet_id = obj._leaflet_id || ++lastId;
      return obj._leaflet_id;
    }
    function throttle(fn, time, context) {
      var lock, args, wrapperFn, later;
      later = function() {
        lock = false;
        if (args) {
          wrapperFn.apply(context, args);
          args = false;
        }
      };
      wrapperFn = function() {
        if (lock) {
          args = arguments;
        } else {
          fn.apply(context, arguments);
          setTimeout(later, time);
          lock = true;
        }
      };
      return wrapperFn;
    }
    function wrapNum(x, range, includeMax) {
      var max = range[1], min = range[0], d = max - min;
      return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
    }
    function falseFn() {
      return false;
    }
    function formatNum(num, digits) {
      var pow = Math.pow(10, digits === void 0 ? 6 : digits);
      return Math.round(num * pow) / pow;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function splitWords(str) {
      return trim(str).split(/\s+/);
    }
    function setOptions(obj, options) {
      if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
        obj.options = obj.options ? create(obj.options) : {};
      }
      for (var i in options) {
        obj.options[i] = options[i];
      }
      return obj.options;
    }
    function getParamString(obj, existingUrl, uppercase) {
      var params2 = [];
      for (var i in obj) {
        params2.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
      }
      return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params2.join("&");
    }
    var templateRe = /\{ *([\w_-]+) *\}/g;
    function template(str, data) {
      return str.replace(templateRe, function(str2, key) {
        var value = data[key];
        if (value === void 0) {
          throw new Error("No value provided for variable " + str2);
        } else if (typeof value === "function") {
          value = value(data);
        }
        return value;
      });
    }
    var isArray = Array.isArray || function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    function indexOf(array, el) {
      for (var i = 0; i < array.length; i++) {
        if (array[i] === el) {
          return i;
        }
      }
      return -1;
    }
    var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    function getPrefixed(name) {
      return window["webkit" + name] || window["moz" + name] || window["ms" + name];
    }
    var lastTime = 0;
    function timeoutDefer(fn) {
      var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
      lastTime = time + timeToCall;
      return window.setTimeout(fn, timeToCall);
    }
    var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
    var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
      window.clearTimeout(id);
    };
    function requestAnimFrame(fn, context, immediate) {
      if (immediate && requestFn === timeoutDefer) {
        fn.call(context);
      } else {
        return requestFn.call(window, bind2(fn, context));
      }
    }
    function cancelAnimFrame(id) {
      if (id) {
        cancelFn.call(window, id);
      }
    }
    var Util = {
      extend,
      create,
      bind: bind2,
      lastId,
      stamp,
      throttle,
      wrapNum,
      falseFn,
      formatNum,
      trim,
      splitWords,
      setOptions,
      getParamString,
      template,
      isArray,
      indexOf,
      emptyImageUrl,
      requestFn,
      cancelFn,
      requestAnimFrame,
      cancelAnimFrame
    };
    function Class() {
    }
    Class.extend = function(props) {
      var NewClass = function() {
        if (this.initialize) {
          this.initialize.apply(this, arguments);
        }
        this.callInitHooks();
      };
      var parentProto = NewClass.__super__ = this.prototype;
      var proto = create(parentProto);
      proto.constructor = NewClass;
      NewClass.prototype = proto;
      for (var i in this) {
        if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
          NewClass[i] = this[i];
        }
      }
      if (props.statics) {
        extend(NewClass, props.statics);
        delete props.statics;
      }
      if (props.includes) {
        checkDeprecatedMixinEvents(props.includes);
        extend.apply(null, [proto].concat(props.includes));
        delete props.includes;
      }
      if (proto.options) {
        props.options = extend(create(proto.options), props.options);
      }
      extend(proto, props);
      proto._initHooks = [];
      proto.callInitHooks = function() {
        if (this._initHooksCalled) {
          return;
        }
        if (parentProto.callInitHooks) {
          parentProto.callInitHooks.call(this);
        }
        this._initHooksCalled = true;
        for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
          proto._initHooks[i2].call(this);
        }
      };
      return NewClass;
    };
    Class.include = function(props) {
      extend(this.prototype, props);
      return this;
    };
    Class.mergeOptions = function(options) {
      extend(this.prototype.options, options);
      return this;
    };
    Class.addInitHook = function(fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      var init2 = typeof fn === "function" ? fn : function() {
        this[fn].apply(this, args);
      };
      this.prototype._initHooks = this.prototype._initHooks || [];
      this.prototype._initHooks.push(init2);
      return this;
    };
    function checkDeprecatedMixinEvents(includes) {
      if (typeof L === "undefined" || !L || !L.Mixin) {
        return;
      }
      includes = isArray(includes) ? includes : [includes];
      for (var i = 0; i < includes.length; i++) {
        if (includes[i] === L.Mixin.Events) {
          console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
    }
    var Events = {
      on: function(types, fn, context) {
        if (typeof types === "object") {
          for (var type2 in types) {
            this._on(type2, types[type2], fn);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            this._on(types[i], fn, context);
          }
        }
        return this;
      },
      off: function(types, fn, context) {
        if (!types) {
          delete this._events;
        } else if (typeof types === "object") {
          for (var type2 in types) {
            this._off(type2, types[type2], fn);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            this._off(types[i], fn, context);
          }
        }
        return this;
      },
      _on: function(type2, fn, context) {
        this._events = this._events || {};
        var typeListeners = this._events[type2];
        if (!typeListeners) {
          typeListeners = [];
          this._events[type2] = typeListeners;
        }
        if (context === this) {
          context = void 0;
        }
        var newListener = { fn, ctx: context }, listeners = typeListeners;
        for (var i = 0, len = listeners.length; i < len; i++) {
          if (listeners[i].fn === fn && listeners[i].ctx === context) {
            return;
          }
        }
        listeners.push(newListener);
      },
      _off: function(type2, fn, context) {
        var listeners, i, len;
        if (!this._events) {
          return;
        }
        listeners = this._events[type2];
        if (!listeners) {
          return;
        }
        if (!fn) {
          for (i = 0, len = listeners.length; i < len; i++) {
            listeners[i].fn = falseFn;
          }
          delete this._events[type2];
          return;
        }
        if (context === this) {
          context = void 0;
        }
        if (listeners) {
          for (i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            if (l.ctx !== context) {
              continue;
            }
            if (l.fn === fn) {
              l.fn = falseFn;
              if (this._firingCount) {
                this._events[type2] = listeners = listeners.slice();
              }
              listeners.splice(i, 1);
              return;
            }
          }
        }
      },
      fire: function(type2, data, propagate) {
        if (!this.listens(type2, propagate)) {
          return this;
        }
        var event = extend({}, data, {
          type: type2,
          target: this,
          sourceTarget: data && data.sourceTarget || this
        });
        if (this._events) {
          var listeners = this._events[type2];
          if (listeners) {
            this._firingCount = this._firingCount + 1 || 1;
            for (var i = 0, len = listeners.length; i < len; i++) {
              var l = listeners[i];
              l.fn.call(l.ctx || this, event);
            }
            this._firingCount--;
          }
        }
        if (propagate) {
          this._propagateEvent(event);
        }
        return this;
      },
      listens: function(type2, propagate) {
        var listeners = this._events && this._events[type2];
        if (listeners && listeners.length) {
          return true;
        }
        if (propagate) {
          for (var id in this._eventParents) {
            if (this._eventParents[id].listens(type2, propagate)) {
              return true;
            }
          }
        }
        return false;
      },
      once: function(types, fn, context) {
        if (typeof types === "object") {
          for (var type2 in types) {
            this.once(type2, types[type2], fn);
          }
          return this;
        }
        var handler = bind2(function() {
          this.off(types, fn, context).off(types, handler, context);
        }, this);
        return this.on(types, fn, context).on(types, handler, context);
      },
      addEventParent: function(obj) {
        this._eventParents = this._eventParents || {};
        this._eventParents[stamp(obj)] = obj;
        return this;
      },
      removeEventParent: function(obj) {
        if (this._eventParents) {
          delete this._eventParents[stamp(obj)];
        }
        return this;
      },
      _propagateEvent: function(e) {
        for (var id in this._eventParents) {
          this._eventParents[id].fire(e.type, extend({
            layer: e.target,
            propagatedFrom: e.target
          }, e), true);
        }
      }
    };
    Events.addEventListener = Events.on;
    Events.removeEventListener = Events.clearAllEventListeners = Events.off;
    Events.addOneTimeEventListener = Events.once;
    Events.fireEvent = Events.fire;
    Events.hasEventListeners = Events.listens;
    var Evented = Class.extend(Events);
    function Point(x, y, round) {
      this.x = round ? Math.round(x) : x;
      this.y = round ? Math.round(y) : y;
    }
    var trunc = Math.trunc || function(v) {
      return v > 0 ? Math.floor(v) : Math.ceil(v);
    };
    Point.prototype = {
      clone: function() {
        return new Point(this.x, this.y);
      },
      add: function(point) {
        return this.clone()._add(toPoint(point));
      },
      _add: function(point) {
        this.x += point.x;
        this.y += point.y;
        return this;
      },
      subtract: function(point) {
        return this.clone()._subtract(toPoint(point));
      },
      _subtract: function(point) {
        this.x -= point.x;
        this.y -= point.y;
        return this;
      },
      divideBy: function(num) {
        return this.clone()._divideBy(num);
      },
      _divideBy: function(num) {
        this.x /= num;
        this.y /= num;
        return this;
      },
      multiplyBy: function(num) {
        return this.clone()._multiplyBy(num);
      },
      _multiplyBy: function(num) {
        this.x *= num;
        this.y *= num;
        return this;
      },
      scaleBy: function(point) {
        return new Point(this.x * point.x, this.y * point.y);
      },
      unscaleBy: function(point) {
        return new Point(this.x / point.x, this.y / point.y);
      },
      round: function() {
        return this.clone()._round();
      },
      _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      floor: function() {
        return this.clone()._floor();
      },
      _floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        return this.clone()._ceil();
      },
      _ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      trunc: function() {
        return this.clone()._trunc();
      },
      _trunc: function() {
        this.x = trunc(this.x);
        this.y = trunc(this.y);
        return this;
      },
      distanceTo: function(point) {
        point = toPoint(point);
        var x = point.x - this.x, y = point.y - this.y;
        return Math.sqrt(x * x + y * y);
      },
      equals: function(point) {
        point = toPoint(point);
        return point.x === this.x && point.y === this.y;
      },
      contains: function(point) {
        point = toPoint(point);
        return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
      },
      toString: function() {
        return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
      }
    };
    function toPoint(x, y, round) {
      if (x instanceof Point) {
        return x;
      }
      if (isArray(x)) {
        return new Point(x[0], x[1]);
      }
      if (x === void 0 || x === null) {
        return x;
      }
      if (typeof x === "object" && "x" in x && "y" in x) {
        return new Point(x.x, x.y);
      }
      return new Point(x, y, round);
    }
    function Bounds(a, b) {
      if (!a) {
        return;
      }
      var points = b ? [a, b] : a;
      for (var i = 0, len = points.length; i < len; i++) {
        this.extend(points[i]);
      }
    }
    Bounds.prototype = {
      extend: function(point) {
        point = toPoint(point);
        if (!this.min && !this.max) {
          this.min = point.clone();
          this.max = point.clone();
        } else {
          this.min.x = Math.min(point.x, this.min.x);
          this.max.x = Math.max(point.x, this.max.x);
          this.min.y = Math.min(point.y, this.min.y);
          this.max.y = Math.max(point.y, this.max.y);
        }
        return this;
      },
      getCenter: function(round) {
        return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
      },
      getBottomLeft: function() {
        return new Point(this.min.x, this.max.y);
      },
      getTopRight: function() {
        return new Point(this.max.x, this.min.y);
      },
      getTopLeft: function() {
        return this.min;
      },
      getBottomRight: function() {
        return this.max;
      },
      getSize: function() {
        return this.max.subtract(this.min);
      },
      contains: function(obj) {
        var min, max;
        if (typeof obj[0] === "number" || obj instanceof Point) {
          obj = toPoint(obj);
        } else {
          obj = toBounds(obj);
        }
        if (obj instanceof Bounds) {
          min = obj.min;
          max = obj.max;
        } else {
          min = max = obj;
        }
        return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
      },
      intersects: function(bounds) {
        bounds = toBounds(bounds);
        var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
        return xIntersects && yIntersects;
      },
      overlaps: function(bounds) {
        bounds = toBounds(bounds);
        var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
        return xOverlaps && yOverlaps;
      },
      isValid: function() {
        return !!(this.min && this.max);
      }
    };
    function toBounds(a, b) {
      if (!a || a instanceof Bounds) {
        return a;
      }
      return new Bounds(a, b);
    }
    function LatLngBounds(corner1, corner2) {
      if (!corner1) {
        return;
      }
      var latlngs = corner2 ? [corner1, corner2] : corner1;
      for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
      }
    }
    LatLngBounds.prototype = {
      extend: function(obj) {
        var sw = this._southWest, ne = this._northEast, sw2, ne2;
        if (obj instanceof LatLng) {
          sw2 = obj;
          ne2 = obj;
        } else if (obj instanceof LatLngBounds) {
          sw2 = obj._southWest;
          ne2 = obj._northEast;
          if (!sw2 || !ne2) {
            return this;
          }
        } else {
          return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
        }
        if (!sw && !ne) {
          this._southWest = new LatLng(sw2.lat, sw2.lng);
          this._northEast = new LatLng(ne2.lat, ne2.lng);
        } else {
          sw.lat = Math.min(sw2.lat, sw.lat);
          sw.lng = Math.min(sw2.lng, sw.lng);
          ne.lat = Math.max(ne2.lat, ne.lat);
          ne.lng = Math.max(ne2.lng, ne.lng);
        }
        return this;
      },
      pad: function(bufferRatio) {
        var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
        return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
      },
      getCenter: function() {
        return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
      },
      getSouthWest: function() {
        return this._southWest;
      },
      getNorthEast: function() {
        return this._northEast;
      },
      getNorthWest: function() {
        return new LatLng(this.getNorth(), this.getWest());
      },
      getSouthEast: function() {
        return new LatLng(this.getSouth(), this.getEast());
      },
      getWest: function() {
        return this._southWest.lng;
      },
      getSouth: function() {
        return this._southWest.lat;
      },
      getEast: function() {
        return this._northEast.lng;
      },
      getNorth: function() {
        return this._northEast.lat;
      },
      contains: function(obj) {
        if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
          obj = toLatLng(obj);
        } else {
          obj = toLatLngBounds(obj);
        }
        var sw = this._southWest, ne = this._northEast, sw2, ne2;
        if (obj instanceof LatLngBounds) {
          sw2 = obj.getSouthWest();
          ne2 = obj.getNorthEast();
        } else {
          sw2 = ne2 = obj;
        }
        return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
      },
      intersects: function(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
        return latIntersects && lngIntersects;
      },
      overlaps: function(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
        return latOverlaps && lngOverlaps;
      },
      toBBoxString: function() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
      },
      equals: function(bounds, maxMargin) {
        if (!bounds) {
          return false;
        }
        bounds = toLatLngBounds(bounds);
        return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
      },
      isValid: function() {
        return !!(this._southWest && this._northEast);
      }
    };
    function toLatLngBounds(a, b) {
      if (a instanceof LatLngBounds) {
        return a;
      }
      return new LatLngBounds(a, b);
    }
    function LatLng(lat, lng, alt) {
      if (isNaN(lat) || isNaN(lng)) {
        throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
      }
      this.lat = +lat;
      this.lng = +lng;
      if (alt !== void 0) {
        this.alt = +alt;
      }
    }
    LatLng.prototype = {
      equals: function(obj, maxMargin) {
        if (!obj) {
          return false;
        }
        obj = toLatLng(obj);
        var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
        return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
      },
      toString: function(precision) {
        return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
      },
      distanceTo: function(other) {
        return Earth.distance(this, toLatLng(other));
      },
      wrap: function() {
        return Earth.wrapLatLng(this);
      },
      toBounds: function(sizeInMeters) {
        var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
        return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
      },
      clone: function() {
        return new LatLng(this.lat, this.lng, this.alt);
      }
    };
    function toLatLng(a, b, c) {
      if (a instanceof LatLng) {
        return a;
      }
      if (isArray(a) && typeof a[0] !== "object") {
        if (a.length === 3) {
          return new LatLng(a[0], a[1], a[2]);
        }
        if (a.length === 2) {
          return new LatLng(a[0], a[1]);
        }
        return null;
      }
      if (a === void 0 || a === null) {
        return a;
      }
      if (typeof a === "object" && "lat" in a) {
        return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
      }
      if (b === void 0) {
        return null;
      }
      return new LatLng(a, b, c);
    }
    var CRS = {
      latLngToPoint: function(latlng, zoom2) {
        var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
        return this.transformation._transform(projectedPoint, scale2);
      },
      pointToLatLng: function(point, zoom2) {
        var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
        return this.projection.unproject(untransformedPoint);
      },
      project: function(latlng) {
        return this.projection.project(latlng);
      },
      unproject: function(point) {
        return this.projection.unproject(point);
      },
      scale: function(zoom2) {
        return 256 * Math.pow(2, zoom2);
      },
      zoom: function(scale2) {
        return Math.log(scale2 / 256) / Math.LN2;
      },
      getProjectedBounds: function(zoom2) {
        if (this.infinite) {
          return null;
        }
        var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
        return new Bounds(min, max);
      },
      infinite: false,
      wrapLatLng: function(latlng) {
        var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
        return new LatLng(lat, lng, alt);
      },
      wrapLatLngBounds: function(bounds) {
        var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
        if (latShift === 0 && lngShift === 0) {
          return bounds;
        }
        var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
        return new LatLngBounds(newSw, newNe);
      }
    };
    var Earth = extend({}, CRS, {
      wrapLng: [-180, 180],
      R: 6371e3,
      distance: function(latlng1, latlng2) {
        var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return this.R * c;
      }
    });
    var earthRadius = 6378137;
    var SphericalMercator = {
      R: earthRadius,
      MAX_LATITUDE: 85.0511287798,
      project: function(latlng) {
        var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
        return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
      },
      unproject: function(point) {
        var d = 180 / Math.PI;
        return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
      },
      bounds: function() {
        var d = earthRadius * Math.PI;
        return new Bounds([-d, -d], [d, d]);
      }()
    };
    function Transformation(a, b, c, d) {
      if (isArray(a)) {
        this._a = a[0];
        this._b = a[1];
        this._c = a[2];
        this._d = a[3];
        return;
      }
      this._a = a;
      this._b = b;
      this._c = c;
      this._d = d;
    }
    Transformation.prototype = {
      transform: function(point, scale2) {
        return this._transform(point.clone(), scale2);
      },
      _transform: function(point, scale2) {
        scale2 = scale2 || 1;
        point.x = scale2 * (this._a * point.x + this._b);
        point.y = scale2 * (this._c * point.y + this._d);
        return point;
      },
      untransform: function(point, scale2) {
        scale2 = scale2 || 1;
        return new Point((point.x / scale2 - this._b) / this._a, (point.y / scale2 - this._d) / this._c);
      }
    };
    function toTransformation(a, b, c, d) {
      return new Transformation(a, b, c, d);
    }
    var EPSG3857 = extend({}, Earth, {
      code: "EPSG:3857",
      projection: SphericalMercator,
      transformation: function() {
        var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
        return toTransformation(scale2, 0.5, -scale2, 0.5);
      }()
    });
    var EPSG900913 = extend({}, EPSG3857, {
      code: "EPSG:900913"
    });
    function svgCreate(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function pointsToPath(rings, closed) {
      var str = "", i, j, len, len2, points, p2;
      for (i = 0, len = rings.length; i < len; i++) {
        points = rings[i];
        for (j = 0, len2 = points.length; j < len2; j++) {
          p2 = points[j];
          str += (j ? "L" : "M") + p2.x + " " + p2.y;
        }
        str += closed ? svg ? "z" : "x" : "";
      }
      return str || "M0 0";
    }
    var style$1 = document.documentElement.style;
    var ie = "ActiveXObject" in window;
    var ielt9 = ie && !document.addEventListener;
    var edge = "msLaunchUri" in navigator && !("documentMode" in document);
    var webkit = userAgentContains("webkit");
    var android = userAgentContains("android");
    var android23 = userAgentContains("android 2") || userAgentContains("android 3");
    var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
    var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
    var opera = !!window.opera;
    var chrome = !edge && userAgentContains("chrome");
    var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
    var safari = !chrome && userAgentContains("safari");
    var phantom = userAgentContains("phantom");
    var opera12 = "OTransition" in style$1;
    var win = navigator.platform.indexOf("Win") === 0;
    var ie3d = ie && "transition" in style$1;
    var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
    var gecko3d = "MozPerspective" in style$1;
    var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
    var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
    var mobileWebkit = mobile && webkit;
    var mobileWebkit3d = mobile && webkit3d;
    var msPointer = !window.PointerEvent && window.MSPointerEvent;
    var pointer = !!(window.PointerEvent || msPointer);
    var touch = !window.L_NO_TOUCH && (pointer || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch);
    var mobileOpera = mobile && opera;
    var mobileGecko = mobile && gecko;
    var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
    var passiveEvents = function() {
      var supportsPassiveOption2 = false;
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function() {
            supportsPassiveOption2 = true;
          }
        });
        window.addEventListener("testPassiveEventSupport", falseFn, opts);
        window.removeEventListener("testPassiveEventSupport", falseFn, opts);
      } catch (e) {
      }
      return supportsPassiveOption2;
    }();
    var canvas = function() {
      return !!document.createElement("canvas").getContext;
    }();
    var svg = !!(document.createElementNS && svgCreate("svg").createSVGRect);
    var vml = !svg && function() {
      try {
        var div = document.createElement("div");
        div.innerHTML = '<v:shape adj="1"/>';
        var shape = div.firstChild;
        shape.style.behavior = "url(#default#VML)";
        return shape && typeof shape.adj === "object";
      } catch (e) {
        return false;
      }
    }();
    function userAgentContains(str) {
      return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
    }
    var Browser = {
      ie,
      ielt9,
      edge,
      webkit,
      android,
      android23,
      androidStock,
      opera,
      chrome,
      gecko,
      safari,
      phantom,
      opera12,
      win,
      ie3d,
      webkit3d,
      gecko3d,
      any3d,
      mobile,
      mobileWebkit,
      mobileWebkit3d,
      msPointer,
      pointer,
      touch,
      mobileOpera,
      mobileGecko,
      retina,
      passiveEvents,
      canvas,
      svg,
      vml
    };
    var POINTER_DOWN = msPointer ? "MSPointerDown" : "pointerdown";
    var POINTER_MOVE = msPointer ? "MSPointerMove" : "pointermove";
    var POINTER_UP = msPointer ? "MSPointerUp" : "pointerup";
    var POINTER_CANCEL = msPointer ? "MSPointerCancel" : "pointercancel";
    var _pointers = {};
    var _pointerDocListener = false;
    function addPointerListener(obj, type2, handler, id) {
      if (type2 === "touchstart") {
        _addPointerStart(obj, handler, id);
      } else if (type2 === "touchmove") {
        _addPointerMove(obj, handler, id);
      } else if (type2 === "touchend") {
        _addPointerEnd(obj, handler, id);
      }
      return this;
    }
    function removePointerListener(obj, type2, id) {
      var handler = obj["_leaflet_" + type2 + id];
      if (type2 === "touchstart") {
        obj.removeEventListener(POINTER_DOWN, handler, false);
      } else if (type2 === "touchmove") {
        obj.removeEventListener(POINTER_MOVE, handler, false);
      } else if (type2 === "touchend") {
        obj.removeEventListener(POINTER_UP, handler, false);
        obj.removeEventListener(POINTER_CANCEL, handler, false);
      }
      return this;
    }
    function _addPointerStart(obj, handler, id) {
      var onDown = bind2(function(e) {
        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e);
        }
        _handlePointer(e, handler);
      });
      obj["_leaflet_touchstart" + id] = onDown;
      obj.addEventListener(POINTER_DOWN, onDown, false);
      if (!_pointerDocListener) {
        document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
        document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
        document.addEventListener(POINTER_UP, _globalPointerUp, true);
        document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
        _pointerDocListener = true;
      }
    }
    function _globalPointerDown(e) {
      _pointers[e.pointerId] = e;
    }
    function _globalPointerMove(e) {
      if (_pointers[e.pointerId]) {
        _pointers[e.pointerId] = e;
      }
    }
    function _globalPointerUp(e) {
      delete _pointers[e.pointerId];
    }
    function _handlePointer(e, handler) {
      e.touches = [];
      for (var i in _pointers) {
        e.touches.push(_pointers[i]);
      }
      e.changedTouches = [e];
      handler(e);
    }
    function _addPointerMove(obj, handler, id) {
      var onMove = function(e) {
        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse") && e.buttons === 0) {
          return;
        }
        _handlePointer(e, handler);
      };
      obj["_leaflet_touchmove" + id] = onMove;
      obj.addEventListener(POINTER_MOVE, onMove, false);
    }
    function _addPointerEnd(obj, handler, id) {
      var onUp = function(e) {
        _handlePointer(e, handler);
      };
      obj["_leaflet_touchend" + id] = onUp;
      obj.addEventListener(POINTER_UP, onUp, false);
      obj.addEventListener(POINTER_CANCEL, onUp, false);
    }
    var _touchstart = msPointer ? "MSPointerDown" : pointer ? "pointerdown" : "touchstart";
    var _touchend = msPointer ? "MSPointerUp" : pointer ? "pointerup" : "touchend";
    var _pre = "_leaflet_";
    function addDoubleTapListener(obj, handler, id) {
      var last, touch$$1, doubleTap = false, delay = 250;
      function onTouchStart(e) {
        if (pointer) {
          if (!e.isPrimary) {
            return;
          }
          if (e.pointerType === "mouse") {
            return;
          }
        } else if (e.touches.length > 1) {
          return;
        }
        var now2 = Date.now(), delta = now2 - (last || now2);
        touch$$1 = e.touches ? e.touches[0] : e;
        doubleTap = delta > 0 && delta <= delay;
        last = now2;
      }
      function onTouchEnd(e) {
        if (doubleTap && !touch$$1.cancelBubble) {
          if (pointer) {
            if (e.pointerType === "mouse") {
              return;
            }
            var newTouch = {}, prop, i;
            for (i in touch$$1) {
              prop = touch$$1[i];
              newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
            }
            touch$$1 = newTouch;
          }
          touch$$1.type = "dblclick";
          touch$$1.button = 0;
          handler(touch$$1);
          last = null;
        }
      }
      obj[_pre + _touchstart + id] = onTouchStart;
      obj[_pre + _touchend + id] = onTouchEnd;
      obj[_pre + "dblclick" + id] = handler;
      obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? { passive: false } : false);
      obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? { passive: false } : false);
      obj.addEventListener("dblclick", handler, false);
      return this;
    }
    function removeDoubleTapListener(obj, id) {
      var touchstart = obj[_pre + _touchstart + id], touchend = obj[_pre + _touchend + id], dblclick = obj[_pre + "dblclick" + id];
      obj.removeEventListener(_touchstart, touchstart, passiveEvents ? { passive: false } : false);
      obj.removeEventListener(_touchend, touchend, passiveEvents ? { passive: false } : false);
      obj.removeEventListener("dblclick", dblclick, false);
      return this;
    }
    var TRANSFORM = testProp(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
    var TRANSITION = testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
    var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
    function get(id) {
      return typeof id === "string" ? document.getElementById(id) : id;
    }
    function getStyle(el, style) {
      var value = el.style[style] || el.currentStyle && el.currentStyle[style];
      if ((!value || value === "auto") && document.defaultView) {
        var css = document.defaultView.getComputedStyle(el, null);
        value = css ? css[style] : null;
      }
      return value === "auto" ? null : value;
    }
    function create$1(tagName, className, container) {
      var el = document.createElement(tagName);
      el.className = className || "";
      if (container) {
        container.appendChild(el);
      }
      return el;
    }
    function remove(el) {
      var parent = el.parentNode;
      if (parent) {
        parent.removeChild(el);
      }
    }
    function empty2(el) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
    }
    function toFront(el) {
      var parent = el.parentNode;
      if (parent && parent.lastChild !== el) {
        parent.appendChild(el);
      }
    }
    function toBack(el) {
      var parent = el.parentNode;
      if (parent && parent.firstChild !== el) {
        parent.insertBefore(el, parent.firstChild);
      }
    }
    function hasClass(el, name) {
      if (el.classList !== void 0) {
        return el.classList.contains(name);
      }
      var className = getClass(el);
      return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
    }
    function addClass(el, name) {
      if (el.classList !== void 0) {
        var classes = splitWords(name);
        for (var i = 0, len = classes.length; i < len; i++) {
          el.classList.add(classes[i]);
        }
      } else if (!hasClass(el, name)) {
        var className = getClass(el);
        setClass(el, (className ? className + " " : "") + name);
      }
    }
    function removeClass(el, name) {
      if (el.classList !== void 0) {
        el.classList.remove(name);
      } else {
        setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
      }
    }
    function setClass(el, name) {
      if (el.className.baseVal === void 0) {
        el.className = name;
      } else {
        el.className.baseVal = name;
      }
    }
    function getClass(el) {
      if (el.correspondingElement) {
        el = el.correspondingElement;
      }
      return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
    }
    function setOpacity(el, value) {
      if ("opacity" in el.style) {
        el.style.opacity = value;
      } else if ("filter" in el.style) {
        _setOpacityIE(el, value);
      }
    }
    function _setOpacityIE(el, value) {
      var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
      try {
        filter = el.filters.item(filterName);
      } catch (e) {
        if (value === 1) {
          return;
        }
      }
      value = Math.round(value * 100);
      if (filter) {
        filter.Enabled = value !== 100;
        filter.Opacity = value;
      } else {
        el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
      }
    }
    function testProp(props) {
      var style = document.documentElement.style;
      for (var i = 0; i < props.length; i++) {
        if (props[i] in style) {
          return props[i];
        }
      }
      return false;
    }
    function setTransform(el, offset, scale2) {
      var pos = offset || new Point(0, 0);
      el.style[TRANSFORM] = (ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
    }
    function setPosition(el, point) {
      el._leaflet_pos = point;
      if (any3d) {
        setTransform(el, point);
      } else {
        el.style.left = point.x + "px";
        el.style.top = point.y + "px";
      }
    }
    function getPosition(el) {
      return el._leaflet_pos || new Point(0, 0);
    }
    var disableTextSelection;
    var enableTextSelection;
    var _userSelect;
    if ("onselectstart" in document) {
      disableTextSelection = function() {
        on(window, "selectstart", preventDefault);
      };
      enableTextSelection = function() {
        off(window, "selectstart", preventDefault);
      };
    } else {
      var userSelectProperty = testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
      disableTextSelection = function() {
        if (userSelectProperty) {
          var style = document.documentElement.style;
          _userSelect = style[userSelectProperty];
          style[userSelectProperty] = "none";
        }
      };
      enableTextSelection = function() {
        if (userSelectProperty) {
          document.documentElement.style[userSelectProperty] = _userSelect;
          _userSelect = void 0;
        }
      };
    }
    function disableImageDrag() {
      on(window, "dragstart", preventDefault);
    }
    function enableImageDrag() {
      off(window, "dragstart", preventDefault);
    }
    var _outlineElement, _outlineStyle;
    function preventOutline(element2) {
      while (element2.tabIndex === -1) {
        element2 = element2.parentNode;
      }
      if (!element2.style) {
        return;
      }
      restoreOutline();
      _outlineElement = element2;
      _outlineStyle = element2.style.outline;
      element2.style.outline = "none";
      on(window, "keydown", restoreOutline);
    }
    function restoreOutline() {
      if (!_outlineElement) {
        return;
      }
      _outlineElement.style.outline = _outlineStyle;
      _outlineElement = void 0;
      _outlineStyle = void 0;
      off(window, "keydown", restoreOutline);
    }
    function getSizedParentNode(element2) {
      do {
        element2 = element2.parentNode;
      } while ((!element2.offsetWidth || !element2.offsetHeight) && element2 !== document.body);
      return element2;
    }
    function getScale(element2) {
      var rect = element2.getBoundingClientRect();
      return {
        x: rect.width / element2.offsetWidth || 1,
        y: rect.height / element2.offsetHeight || 1,
        boundingClientRect: rect
      };
    }
    var DomUtil = {
      TRANSFORM,
      TRANSITION,
      TRANSITION_END,
      get,
      getStyle,
      create: create$1,
      remove,
      empty: empty2,
      toFront,
      toBack,
      hasClass,
      addClass,
      removeClass,
      setClass,
      getClass,
      setOpacity,
      testProp,
      setTransform,
      setPosition,
      getPosition,
      disableTextSelection,
      enableTextSelection,
      disableImageDrag,
      enableImageDrag,
      preventOutline,
      restoreOutline,
      getSizedParentNode,
      getScale
    };
    function on(obj, types, fn, context) {
      if (typeof types === "object") {
        for (var type2 in types) {
          addOne(obj, type2, types[type2], fn);
        }
      } else {
        types = splitWords(types);
        for (var i = 0, len = types.length; i < len; i++) {
          addOne(obj, types[i], fn, context);
        }
      }
      return this;
    }
    var eventsKey = "_leaflet_events";
    function off(obj, types, fn, context) {
      if (typeof types === "object") {
        for (var type2 in types) {
          removeOne(obj, type2, types[type2], fn);
        }
      } else if (types) {
        types = splitWords(types);
        for (var i = 0, len = types.length; i < len; i++) {
          removeOne(obj, types[i], fn, context);
        }
      } else {
        for (var j in obj[eventsKey]) {
          removeOne(obj, j, obj[eventsKey][j]);
        }
        delete obj[eventsKey];
      }
      return this;
    }
    function browserFiresNativeDblClick() {
      if (pointer) {
        return !(edge || safari);
      }
    }
    var mouseSubst = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      wheel: !("onwheel" in window) && "mousewheel"
    };
    function addOne(obj, type2, fn, context) {
      var id = type2 + stamp(fn) + (context ? "_" + stamp(context) : "");
      if (obj[eventsKey] && obj[eventsKey][id]) {
        return this;
      }
      var handler = function(e) {
        return fn.call(context || obj, e || window.event);
      };
      var originalHandler = handler;
      if (pointer && type2.indexOf("touch") === 0) {
        addPointerListener(obj, type2, handler, id);
      } else if (touch && type2 === "dblclick" && !browserFiresNativeDblClick()) {
        addDoubleTapListener(obj, handler, id);
      } else if ("addEventListener" in obj) {
        if (type2 === "touchstart" || type2 === "touchmove" || type2 === "wheel" || type2 === "mousewheel") {
          obj.addEventListener(mouseSubst[type2] || type2, handler, passiveEvents ? { passive: false } : false);
        } else if (type2 === "mouseenter" || type2 === "mouseleave") {
          handler = function(e) {
            e = e || window.event;
            if (isExternalTarget(obj, e)) {
              originalHandler(e);
            }
          };
          obj.addEventListener(mouseSubst[type2], handler, false);
        } else {
          obj.addEventListener(type2, originalHandler, false);
        }
      } else if ("attachEvent" in obj) {
        obj.attachEvent("on" + type2, handler);
      }
      obj[eventsKey] = obj[eventsKey] || {};
      obj[eventsKey][id] = handler;
    }
    function removeOne(obj, type2, fn, context) {
      var id = type2 + stamp(fn) + (context ? "_" + stamp(context) : ""), handler = obj[eventsKey] && obj[eventsKey][id];
      if (!handler) {
        return this;
      }
      if (pointer && type2.indexOf("touch") === 0) {
        removePointerListener(obj, type2, id);
      } else if (touch && type2 === "dblclick" && !browserFiresNativeDblClick()) {
        removeDoubleTapListener(obj, id);
      } else if ("removeEventListener" in obj) {
        obj.removeEventListener(mouseSubst[type2] || type2, handler, false);
      } else if ("detachEvent" in obj) {
        obj.detachEvent("on" + type2, handler);
      }
      obj[eventsKey][id] = null;
    }
    function stopPropagation(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else if (e.originalEvent) {
        e.originalEvent._stopped = true;
      } else {
        e.cancelBubble = true;
      }
      skipped(e);
      return this;
    }
    function disableScrollPropagation(el) {
      addOne(el, "wheel", stopPropagation);
      return this;
    }
    function disableClickPropagation(el) {
      on(el, "mousedown touchstart dblclick", stopPropagation);
      addOne(el, "click", fakeStop);
      return this;
    }
    function preventDefault(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
      return this;
    }
    function stop(e) {
      preventDefault(e);
      stopPropagation(e);
      return this;
    }
    function getMousePosition(e, container) {
      if (!container) {
        return new Point(e.clientX, e.clientY);
      }
      var scale2 = getScale(container), offset = scale2.boundingClientRect;
      return new Point((e.clientX - offset.left) / scale2.x - container.clientLeft, (e.clientY - offset.top) / scale2.y - container.clientTop);
    }
    var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1;
    function getWheelDelta(e) {
      return edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
    }
    var skipEvents = {};
    function fakeStop(e) {
      skipEvents[e.type] = true;
    }
    function skipped(e) {
      var events2 = skipEvents[e.type];
      skipEvents[e.type] = false;
      return events2;
    }
    function isExternalTarget(el, e) {
      var related = e.relatedTarget;
      if (!related) {
        return true;
      }
      try {
        while (related && related !== el) {
          related = related.parentNode;
        }
      } catch (err) {
        return false;
      }
      return related !== el;
    }
    var DomEvent = {
      on,
      off,
      stopPropagation,
      disableScrollPropagation,
      disableClickPropagation,
      preventDefault,
      stop,
      getMousePosition,
      getWheelDelta,
      fakeStop,
      skipped,
      isExternalTarget,
      addListener: on,
      removeListener: off
    };
    var PosAnimation = Evented.extend({
      run: function(el, newPos, duration, easeLinearity) {
        this.stop();
        this._el = el;
        this._inProgress = true;
        this._duration = duration || 0.25;
        this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
        this._startPos = getPosition(el);
        this._offset = newPos.subtract(this._startPos);
        this._startTime = +new Date();
        this.fire("start");
        this._animate();
      },
      stop: function() {
        if (!this._inProgress) {
          return;
        }
        this._step(true);
        this._complete();
      },
      _animate: function() {
        this._animId = requestAnimFrame(this._animate, this);
        this._step();
      },
      _step: function(round) {
        var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
        if (elapsed < duration) {
          this._runFrame(this._easeOut(elapsed / duration), round);
        } else {
          this._runFrame(1);
          this._complete();
        }
      },
      _runFrame: function(progress, round) {
        var pos = this._startPos.add(this._offset.multiplyBy(progress));
        if (round) {
          pos._round();
        }
        setPosition(this._el, pos);
        this.fire("step");
      },
      _complete: function() {
        cancelAnimFrame(this._animId);
        this._inProgress = false;
        this.fire("end");
      },
      _easeOut: function(t) {
        return 1 - Math.pow(1 - t, this._easeOutPower);
      }
    });
    var Map2 = Evented.extend({
      options: {
        crs: EPSG3857,
        center: void 0,
        zoom: void 0,
        minZoom: void 0,
        maxZoom: void 0,
        layers: [],
        maxBounds: void 0,
        renderer: void 0,
        zoomAnimation: true,
        zoomAnimationThreshold: 4,
        fadeAnimation: true,
        markerZoomAnimation: true,
        transform3DLimit: 8388608,
        zoomSnap: 1,
        zoomDelta: 1,
        trackResize: true
      },
      initialize: function(id, options) {
        options = setOptions(this, options);
        this._handlers = [];
        this._layers = {};
        this._zoomBoundLayers = {};
        this._sizeChanged = true;
        this._initContainer(id);
        this._initLayout();
        this._onResize = bind2(this._onResize, this);
        this._initEvents();
        if (options.maxBounds) {
          this.setMaxBounds(options.maxBounds);
        }
        if (options.zoom !== void 0) {
          this._zoom = this._limitZoom(options.zoom);
        }
        if (options.center && options.zoom !== void 0) {
          this.setView(toLatLng(options.center), options.zoom, { reset: true });
        }
        this.callInitHooks();
        this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation;
        if (this._zoomAnimated) {
          this._createAnimProxy();
          on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
        }
        this._addLayers(this.options.layers);
      },
      setView: function(center, zoom2, options) {
        zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
        center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
        options = options || {};
        this._stop();
        if (this._loaded && !options.reset && options !== true) {
          if (options.animate !== void 0) {
            options.zoom = extend({ animate: options.animate }, options.zoom);
            options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
          }
          var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
          if (moved) {
            clearTimeout(this._sizeTimer);
            return this;
          }
        }
        this._resetView(center, zoom2);
        return this;
      },
      setZoom: function(zoom2, options) {
        if (!this._loaded) {
          this._zoom = zoom2;
          return this;
        }
        return this.setView(this.getCenter(), zoom2, { zoom: options });
      },
      zoomIn: function(delta, options) {
        delta = delta || (any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom + delta, options);
      },
      zoomOut: function(delta, options) {
        delta = delta || (any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom - delta, options);
      },
      setZoomAround: function(latlng, zoom2, options) {
        var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
        return this.setView(newCenter, zoom2, { zoom: options });
      },
      _getBoundsCenterZoom: function(bounds, options) {
        options = options || {};
        bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
        var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
        zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
        if (zoom2 === Infinity) {
          return {
            center: bounds.getCenter(),
            zoom: zoom2
          };
        }
        var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
        return {
          center,
          zoom: zoom2
        };
      },
      fitBounds: function(bounds, options) {
        bounds = toLatLngBounds(bounds);
        if (!bounds.isValid()) {
          throw new Error("Bounds are not valid.");
        }
        var target = this._getBoundsCenterZoom(bounds, options);
        return this.setView(target.center, target.zoom, options);
      },
      fitWorld: function(options) {
        return this.fitBounds([[-90, -180], [90, 180]], options);
      },
      panTo: function(center, options) {
        return this.setView(center, this._zoom, { pan: options });
      },
      panBy: function(offset, options) {
        offset = toPoint(offset).round();
        options = options || {};
        if (!offset.x && !offset.y) {
          return this.fire("moveend");
        }
        if (options.animate !== true && !this.getSize().contains(offset)) {
          this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
          return this;
        }
        if (!this._panAnim) {
          this._panAnim = new PosAnimation();
          this._panAnim.on({
            "step": this._onPanTransitionStep,
            "end": this._onPanTransitionEnd
          }, this);
        }
        if (!options.noMoveStart) {
          this.fire("movestart");
        }
        if (options.animate !== false) {
          addClass(this._mapPane, "leaflet-pan-anim");
          var newPos = this._getMapPanePos().subtract(offset).round();
          this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
        } else {
          this._rawPanBy(offset);
          this.fire("move").fire("moveend");
        }
        return this;
      },
      flyTo: function(targetCenter, targetZoom, options) {
        options = options || {};
        if (options.animate === false || !any3d) {
          return this.setView(targetCenter, targetZoom, options);
        }
        this._stop();
        var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
        targetCenter = toLatLng(targetCenter);
        targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
        var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
        function r(i) {
          var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
          var log = sq < 1e-9 ? -18 : Math.log(sq);
          return log;
        }
        function sinh(n) {
          return (Math.exp(n) - Math.exp(-n)) / 2;
        }
        function cosh(n) {
          return (Math.exp(n) + Math.exp(-n)) / 2;
        }
        function tanh(n) {
          return sinh(n) / cosh(n);
        }
        var r0 = r(0);
        function w(s) {
          return w0 * (cosh(r0) / cosh(r0 + rho * s));
        }
        function u(s) {
          return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
        }
        function easeOut(t) {
          return 1 - Math.pow(1 - t, 1.5);
        }
        var start2 = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
        function frame() {
          var t = (Date.now() - start2) / duration, s = easeOut(t) * S;
          if (t <= 1) {
            this._flyToFrame = requestAnimFrame(frame, this);
            this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), { flyTo: true });
          } else {
            this._move(targetCenter, targetZoom)._moveEnd(true);
          }
        }
        this._moveStart(true, options.noMoveStart);
        frame.call(this);
        return this;
      },
      flyToBounds: function(bounds, options) {
        var target = this._getBoundsCenterZoom(bounds, options);
        return this.flyTo(target.center, target.zoom, options);
      },
      setMaxBounds: function(bounds) {
        bounds = toLatLngBounds(bounds);
        if (!bounds.isValid()) {
          this.options.maxBounds = null;
          return this.off("moveend", this._panInsideMaxBounds);
        } else if (this.options.maxBounds) {
          this.off("moveend", this._panInsideMaxBounds);
        }
        this.options.maxBounds = bounds;
        if (this._loaded) {
          this._panInsideMaxBounds();
        }
        return this.on("moveend", this._panInsideMaxBounds);
      },
      setMinZoom: function(zoom2) {
        var oldZoom = this.options.minZoom;
        this.options.minZoom = zoom2;
        if (this._loaded && oldZoom !== zoom2) {
          this.fire("zoomlevelschange");
          if (this.getZoom() < this.options.minZoom) {
            return this.setZoom(zoom2);
          }
        }
        return this;
      },
      setMaxZoom: function(zoom2) {
        var oldZoom = this.options.maxZoom;
        this.options.maxZoom = zoom2;
        if (this._loaded && oldZoom !== zoom2) {
          this.fire("zoomlevelschange");
          if (this.getZoom() > this.options.maxZoom) {
            return this.setZoom(zoom2);
          }
        }
        return this;
      },
      panInsideBounds: function(bounds, options) {
        this._enforcingBounds = true;
        var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
        if (!center.equals(newCenter)) {
          this.panTo(newCenter, options);
        }
        this._enforcingBounds = false;
        return this;
      },
      panInside: function(latlng, options) {
        options = options || {};
        var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), center = this.getCenter(), pixelCenter = this.project(center), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), halfPixelBounds = pixelBounds.getSize().divideBy(2), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);
        if (!paddedBounds.contains(pixelPoint)) {
          this._enforcingBounds = true;
          var diff = pixelCenter.subtract(pixelPoint), newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);
          if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
            newCenter.x = pixelCenter.x - diff.x;
            if (diff.x > 0) {
              newCenter.x += halfPixelBounds.x - paddingTL.x;
            } else {
              newCenter.x -= halfPixelBounds.x - paddingBR.x;
            }
          }
          if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
            newCenter.y = pixelCenter.y - diff.y;
            if (diff.y > 0) {
              newCenter.y += halfPixelBounds.y - paddingTL.y;
            } else {
              newCenter.y -= halfPixelBounds.y - paddingBR.y;
            }
          }
          this.panTo(this.unproject(newCenter), options);
          this._enforcingBounds = false;
        }
        return this;
      },
      invalidateSize: function(options) {
        if (!this._loaded) {
          return this;
        }
        options = extend({
          animate: false,
          pan: true
        }, options === true ? { animate: true } : options);
        var oldSize = this.getSize();
        this._sizeChanged = true;
        this._lastCenter = null;
        var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
        if (!offset.x && !offset.y) {
          return this;
        }
        if (options.animate && options.pan) {
          this.panBy(offset);
        } else {
          if (options.pan) {
            this._rawPanBy(offset);
          }
          this.fire("move");
          if (options.debounceMoveend) {
            clearTimeout(this._sizeTimer);
            this._sizeTimer = setTimeout(bind2(this.fire, this, "moveend"), 200);
          } else {
            this.fire("moveend");
          }
        }
        return this.fire("resize", {
          oldSize,
          newSize
        });
      },
      stop: function() {
        this.setZoom(this._limitZoom(this._zoom));
        if (!this.options.zoomSnap) {
          this.fire("viewreset");
        }
        return this._stop();
      },
      locate: function(options) {
        options = this._locateOptions = extend({
          timeout: 1e4,
          watch: false
        }, options);
        if (!("geolocation" in navigator)) {
          this._handleGeolocationError({
            code: 0,
            message: "Geolocation not supported."
          });
          return this;
        }
        var onResponse = bind2(this._handleGeolocationResponse, this), onError = bind2(this._handleGeolocationError, this);
        if (options.watch) {
          this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
        } else {
          navigator.geolocation.getCurrentPosition(onResponse, onError, options);
        }
        return this;
      },
      stopLocate: function() {
        if (navigator.geolocation && navigator.geolocation.clearWatch) {
          navigator.geolocation.clearWatch(this._locationWatchId);
        }
        if (this._locateOptions) {
          this._locateOptions.setView = false;
        }
        return this;
      },
      _handleGeolocationError: function(error) {
        var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
        if (this._locateOptions.setView && !this._loaded) {
          this.fitWorld();
        }
        this.fire("locationerror", {
          code: c,
          message: "Geolocation error: " + message + "."
        });
      },
      _handleGeolocationResponse: function(pos) {
        var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
        if (options.setView) {
          var zoom2 = this.getBoundsZoom(bounds);
          this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
        }
        var data = {
          latlng,
          bounds,
          timestamp: pos.timestamp
        };
        for (var i in pos.coords) {
          if (typeof pos.coords[i] === "number") {
            data[i] = pos.coords[i];
          }
        }
        this.fire("locationfound", data);
      },
      addHandler: function(name, HandlerClass) {
        if (!HandlerClass) {
          return this;
        }
        var handler = this[name] = new HandlerClass(this);
        this._handlers.push(handler);
        if (this.options[name]) {
          handler.enable();
        }
        return this;
      },
      remove: function() {
        this._initEvents(true);
        this.off("moveend", this._panInsideMaxBounds);
        if (this._containerId !== this._container._leaflet_id) {
          throw new Error("Map container is being reused by another instance");
        }
        try {
          delete this._container._leaflet_id;
          delete this._containerId;
        } catch (e) {
          this._container._leaflet_id = void 0;
          this._containerId = void 0;
        }
        if (this._locationWatchId !== void 0) {
          this.stopLocate();
        }
        this._stop();
        remove(this._mapPane);
        if (this._clearControlPos) {
          this._clearControlPos();
        }
        if (this._resizeRequest) {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = null;
        }
        this._clearHandlers();
        if (this._loaded) {
          this.fire("unload");
        }
        var i;
        for (i in this._layers) {
          this._layers[i].remove();
        }
        for (i in this._panes) {
          remove(this._panes[i]);
        }
        this._layers = [];
        this._panes = [];
        delete this._mapPane;
        delete this._renderer;
        return this;
      },
      createPane: function(name, container) {
        var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
        if (name) {
          this._panes[name] = pane;
        }
        return pane;
      },
      getCenter: function() {
        this._checkIfLoaded();
        if (this._lastCenter && !this._moved()) {
          return this._lastCenter;
        }
        return this.layerPointToLatLng(this._getCenterLayerPoint());
      },
      getZoom: function() {
        return this._zoom;
      },
      getBounds: function() {
        var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
        return new LatLngBounds(sw, ne);
      },
      getMinZoom: function() {
        return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
      },
      getMaxZoom: function() {
        return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
      },
      getBoundsZoom: function(bounds, inside, padding) {
        bounds = toLatLngBounds(bounds);
        padding = toPoint(padding || [0, 0]);
        var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
        zoom2 = this.getScaleZoom(scale2, zoom2);
        if (snap) {
          zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
          zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
        }
        return Math.max(min, Math.min(max, zoom2));
      },
      getSize: function() {
        if (!this._size || this._sizeChanged) {
          this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
          this._sizeChanged = false;
        }
        return this._size.clone();
      },
      getPixelBounds: function(center, zoom2) {
        var topLeftPoint = this._getTopLeftPoint(center, zoom2);
        return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
      },
      getPixelOrigin: function() {
        this._checkIfLoaded();
        return this._pixelOrigin;
      },
      getPixelWorldBounds: function(zoom2) {
        return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
      },
      getPane: function(pane) {
        return typeof pane === "string" ? this._panes[pane] : pane;
      },
      getPanes: function() {
        return this._panes;
      },
      getContainer: function() {
        return this._container;
      },
      getZoomScale: function(toZoom, fromZoom) {
        var crs = this.options.crs;
        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
        return crs.scale(toZoom) / crs.scale(fromZoom);
      },
      getScaleZoom: function(scale2, fromZoom) {
        var crs = this.options.crs;
        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
        var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
        return isNaN(zoom2) ? Infinity : zoom2;
      },
      project: function(latlng, zoom2) {
        zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
        return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
      },
      unproject: function(point, zoom2) {
        zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
        return this.options.crs.pointToLatLng(toPoint(point), zoom2);
      },
      layerPointToLatLng: function(point) {
        var projectedPoint = toPoint(point).add(this.getPixelOrigin());
        return this.unproject(projectedPoint);
      },
      latLngToLayerPoint: function(latlng) {
        var projectedPoint = this.project(toLatLng(latlng))._round();
        return projectedPoint._subtract(this.getPixelOrigin());
      },
      wrapLatLng: function(latlng) {
        return this.options.crs.wrapLatLng(toLatLng(latlng));
      },
      wrapLatLngBounds: function(latlng) {
        return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
      },
      distance: function(latlng1, latlng2) {
        return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
      },
      containerPointToLayerPoint: function(point) {
        return toPoint(point).subtract(this._getMapPanePos());
      },
      layerPointToContainerPoint: function(point) {
        return toPoint(point).add(this._getMapPanePos());
      },
      containerPointToLatLng: function(point) {
        var layerPoint = this.containerPointToLayerPoint(toPoint(point));
        return this.layerPointToLatLng(layerPoint);
      },
      latLngToContainerPoint: function(latlng) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
      },
      mouseEventToContainerPoint: function(e) {
        return getMousePosition(e, this._container);
      },
      mouseEventToLayerPoint: function(e) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
      },
      mouseEventToLatLng: function(e) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
      },
      _initContainer: function(id) {
        var container = this._container = get(id);
        if (!container) {
          throw new Error("Map container not found.");
        } else if (container._leaflet_id) {
          throw new Error("Map container is already initialized.");
        }
        on(container, "scroll", this._onScroll, this);
        this._containerId = stamp(container);
      },
      _initLayout: function() {
        var container = this._container;
        this._fadeAnimated = this.options.fadeAnimation && any3d;
        addClass(container, "leaflet-container" + (touch ? " leaflet-touch" : "") + (retina ? " leaflet-retina" : "") + (ielt9 ? " leaflet-oldie" : "") + (safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
        var position = getStyle(container, "position");
        if (position !== "absolute" && position !== "relative" && position !== "fixed") {
          container.style.position = "relative";
        }
        this._initPanes();
        if (this._initControlPos) {
          this._initControlPos();
        }
      },
      _initPanes: function() {
        var panes = this._panes = {};
        this._paneRenderers = {};
        this._mapPane = this.createPane("mapPane", this._container);
        setPosition(this._mapPane, new Point(0, 0));
        this.createPane("tilePane");
        this.createPane("shadowPane");
        this.createPane("overlayPane");
        this.createPane("markerPane");
        this.createPane("tooltipPane");
        this.createPane("popupPane");
        if (!this.options.markerZoomAnimation) {
          addClass(panes.markerPane, "leaflet-zoom-hide");
          addClass(panes.shadowPane, "leaflet-zoom-hide");
        }
      },
      _resetView: function(center, zoom2) {
        setPosition(this._mapPane, new Point(0, 0));
        var loading = !this._loaded;
        this._loaded = true;
        zoom2 = this._limitZoom(zoom2);
        this.fire("viewprereset");
        var zoomChanged = this._zoom !== zoom2;
        this._moveStart(zoomChanged, false)._move(center, zoom2)._moveEnd(zoomChanged);
        this.fire("viewreset");
        if (loading) {
          this.fire("load");
        }
      },
      _moveStart: function(zoomChanged, noMoveStart) {
        if (zoomChanged) {
          this.fire("zoomstart");
        }
        if (!noMoveStart) {
          this.fire("movestart");
        }
        return this;
      },
      _move: function(center, zoom2, data) {
        if (zoom2 === void 0) {
          zoom2 = this._zoom;
        }
        var zoomChanged = this._zoom !== zoom2;
        this._zoom = zoom2;
        this._lastCenter = center;
        this._pixelOrigin = this._getNewPixelOrigin(center);
        if (zoomChanged || data && data.pinch) {
          this.fire("zoom", data);
        }
        return this.fire("move", data);
      },
      _moveEnd: function(zoomChanged) {
        if (zoomChanged) {
          this.fire("zoomend");
        }
        return this.fire("moveend");
      },
      _stop: function() {
        cancelAnimFrame(this._flyToFrame);
        if (this._panAnim) {
          this._panAnim.stop();
        }
        return this;
      },
      _rawPanBy: function(offset) {
        setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
      },
      _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom();
      },
      _panInsideMaxBounds: function() {
        if (!this._enforcingBounds) {
          this.panInsideBounds(this.options.maxBounds);
        }
      },
      _checkIfLoaded: function() {
        if (!this._loaded) {
          throw new Error("Set map center and zoom first.");
        }
      },
      _initEvents: function(remove$$1) {
        this._targets = {};
        this._targets[stamp(this._container)] = this;
        var onOff = remove$$1 ? off : on;
        onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
        if (this.options.trackResize) {
          onOff(window, "resize", this._onResize, this);
        }
        if (any3d && this.options.transform3DLimit) {
          (remove$$1 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        }
      },
      _onResize: function() {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = requestAnimFrame(function() {
          this.invalidateSize({ debounceMoveend: true });
        }, this);
      },
      _onScroll: function() {
        this._container.scrollTop = 0;
        this._container.scrollLeft = 0;
      },
      _onMoveEnd: function() {
        var pos = this._getMapPanePos();
        if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
          this._resetView(this.getCenter(), this.getZoom());
        }
      },
      _findEventTargets: function(e, type2) {
        var targets = [], target, isHover = type2 === "mouseout" || type2 === "mouseover", src = e.target || e.srcElement, dragging = false;
        while (src) {
          target = this._targets[stamp(src)];
          if (target && (type2 === "click" || type2 === "preclick") && !e._simulated && this._draggableMoved(target)) {
            dragging = true;
            break;
          }
          if (target && target.listens(type2, true)) {
            if (isHover && !isExternalTarget(src, e)) {
              break;
            }
            targets.push(target);
            if (isHover) {
              break;
            }
          }
          if (src === this._container) {
            break;
          }
          src = src.parentNode;
        }
        if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
          targets = [this];
        }
        return targets;
      },
      _handleDOMEvent: function(e) {
        if (!this._loaded || skipped(e)) {
          return;
        }
        var type2 = e.type;
        if (type2 === "mousedown" || type2 === "keypress" || type2 === "keyup" || type2 === "keydown") {
          preventOutline(e.target || e.srcElement);
        }
        this._fireDOMEvent(e, type2);
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(e, type2, targets) {
        if (e.type === "click") {
          var synth = extend({}, e);
          synth.type = "preclick";
          this._fireDOMEvent(synth, synth.type, targets);
        }
        if (e._stopped) {
          return;
        }
        targets = (targets || []).concat(this._findEventTargets(e, type2));
        if (!targets.length) {
          return;
        }
        var target = targets[0];
        if (type2 === "contextmenu" && target.listens(type2, true)) {
          preventDefault(e);
        }
        var data = {
          originalEvent: e
        };
        if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
          var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
          data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
          data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
          data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
        }
        for (var i = 0; i < targets.length; i++) {
          targets[i].fire(type2, data, true);
          if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type2) !== -1) {
            return;
          }
        }
      },
      _draggableMoved: function(obj) {
        obj = obj.dragging && obj.dragging.enabled() ? obj : this;
        return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      },
      _clearHandlers: function() {
        for (var i = 0, len = this._handlers.length; i < len; i++) {
          this._handlers[i].disable();
        }
      },
      whenReady: function(callback, context) {
        if (this._loaded) {
          callback.call(context || this, { target: this });
        } else {
          this.on("load", callback, context);
        }
        return this;
      },
      _getMapPanePos: function() {
        return getPosition(this._mapPane) || new Point(0, 0);
      },
      _moved: function() {
        var pos = this._getMapPanePos();
        return pos && !pos.equals([0, 0]);
      },
      _getTopLeftPoint: function(center, zoom2) {
        var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
        return pixelOrigin.subtract(this._getMapPanePos());
      },
      _getNewPixelOrigin: function(center, zoom2) {
        var viewHalf = this.getSize()._divideBy(2);
        return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
      },
      _latLngToNewLayerPoint: function(latlng, zoom2, center) {
        var topLeft = this._getNewPixelOrigin(center, zoom2);
        return this.project(latlng, zoom2)._subtract(topLeft);
      },
      _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
        var topLeft = this._getNewPixelOrigin(center, zoom2);
        return toBounds([
          this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
        ]);
      },
      _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      },
      _getCenterOffset: function(latlng) {
        return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
      },
      _limitCenter: function(center, zoom2, bounds) {
        if (!bounds) {
          return center;
        }
        var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
        if (offset.round().equals([0, 0])) {
          return center;
        }
        return this.unproject(centerPoint.add(offset), zoom2);
      },
      _limitOffset: function(offset, bounds) {
        if (!bounds) {
          return offset;
        }
        var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
        return offset.add(this._getBoundsOffset(newBounds, bounds));
      },
      _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
        var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom2), this.project(maxBounds.getSouthWest(), zoom2)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
        return new Point(dx, dy);
      },
      _rebound: function(left, right) {
        return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
      },
      _limitZoom: function(zoom2) {
        var min = this.getMinZoom(), max = this.getMaxZoom(), snap = any3d ? this.options.zoomSnap : 1;
        if (snap) {
          zoom2 = Math.round(zoom2 / snap) * snap;
        }
        return Math.max(min, Math.min(max, zoom2));
      },
      _onPanTransitionStep: function() {
        this.fire("move");
      },
      _onPanTransitionEnd: function() {
        removeClass(this._mapPane, "leaflet-pan-anim");
        this.fire("moveend");
      },
      _tryAnimatedPan: function(center, options) {
        var offset = this._getCenterOffset(center)._trunc();
        if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
          return false;
        }
        this.panBy(offset, options);
        return true;
      },
      _createAnimProxy: function() {
        var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(proxy);
        this.on("zoomanim", function(e) {
          var prop = TRANSFORM, transform = this._proxy.style[prop];
          setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
          if (transform === this._proxy.style[prop] && this._animatingZoom) {
            this._onZoomTransitionEnd();
          }
        }, this);
        this.on("load moveend", this._animMoveEnd, this);
        this._on("unload", this._destroyAnimProxy, this);
      },
      _destroyAnimProxy: function() {
        remove(this._proxy);
        this.off("load moveend", this._animMoveEnd, this);
        delete this._proxy;
      },
      _animMoveEnd: function() {
        var c = this.getCenter(), z = this.getZoom();
        setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
      },
      _catchTransitionEnd: function(e) {
        if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
          this._onZoomTransitionEnd();
        }
      },
      _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
      },
      _tryAnimatedZoom: function(center, zoom2, options) {
        if (this._animatingZoom) {
          return true;
        }
        options = options || {};
        if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
          return false;
        }
        var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
        if (options.animate !== true && !this.getSize().contains(offset)) {
          return false;
        }
        requestAnimFrame(function() {
          this._moveStart(true, false)._animateZoom(center, zoom2, true);
        }, this);
        return true;
      },
      _animateZoom: function(center, zoom2, startAnim, noUpdate) {
        if (!this._mapPane) {
          return;
        }
        if (startAnim) {
          this._animatingZoom = true;
          this._animateToCenter = center;
          this._animateToZoom = zoom2;
          addClass(this._mapPane, "leaflet-zoom-anim");
        }
        this.fire("zoomanim", {
          center,
          zoom: zoom2,
          noUpdate
        });
        setTimeout(bind2(this._onZoomTransitionEnd, this), 250);
      },
      _onZoomTransitionEnd: function() {
        if (!this._animatingZoom) {
          return;
        }
        if (this._mapPane) {
          removeClass(this._mapPane, "leaflet-zoom-anim");
        }
        this._animatingZoom = false;
        this._move(this._animateToCenter, this._animateToZoom);
        requestAnimFrame(function() {
          this._moveEnd(true);
        }, this);
      }
    });
    function createMap(id, options) {
      return new Map2(id, options);
    }
    var Control = Class.extend({
      options: {
        position: "topright"
      },
      initialize: function(options) {
        setOptions(this, options);
      },
      getPosition: function() {
        return this.options.position;
      },
      setPosition: function(position) {
        var map = this._map;
        if (map) {
          map.removeControl(this);
        }
        this.options.position = position;
        if (map) {
          map.addControl(this);
        }
        return this;
      },
      getContainer: function() {
        return this._container;
      },
      addTo: function(map) {
        this.remove();
        this._map = map;
        var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
        addClass(container, "leaflet-control");
        if (pos.indexOf("bottom") !== -1) {
          corner.insertBefore(container, corner.firstChild);
        } else {
          corner.appendChild(container);
        }
        this._map.on("unload", this.remove, this);
        return this;
      },
      remove: function() {
        if (!this._map) {
          return this;
        }
        remove(this._container);
        if (this.onRemove) {
          this.onRemove(this._map);
        }
        this._map.off("unload", this.remove, this);
        this._map = null;
        return this;
      },
      _refocusOnMap: function(e) {
        if (this._map && e && e.screenX > 0 && e.screenY > 0) {
          this._map.getContainer().focus();
        }
      }
    });
    var control = function(options) {
      return new Control(options);
    };
    Map2.include({
      addControl: function(control2) {
        control2.addTo(this);
        return this;
      },
      removeControl: function(control2) {
        control2.remove();
        return this;
      },
      _initControlPos: function() {
        var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
        function createCorner(vSide, hSide) {
          var className = l + vSide + " " + l + hSide;
          corners[vSide + hSide] = create$1("div", className, container);
        }
        createCorner("top", "left");
        createCorner("top", "right");
        createCorner("bottom", "left");
        createCorner("bottom", "right");
      },
      _clearControlPos: function() {
        for (var i in this._controlCorners) {
          remove(this._controlCorners[i]);
        }
        remove(this._controlContainer);
        delete this._controlCorners;
        delete this._controlContainer;
      }
    });
    var Layers = Control.extend({
      options: {
        collapsed: true,
        position: "topright",
        autoZIndex: true,
        hideSingleBase: false,
        sortLayers: false,
        sortFunction: function(layerA, layerB, nameA, nameB) {
          return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
        }
      },
      initialize: function(baseLayers, overlays, options) {
        setOptions(this, options);
        this._layerControlInputs = [];
        this._layers = [];
        this._lastZIndex = 0;
        this._handlingClick = false;
        for (var i in baseLayers) {
          this._addLayer(baseLayers[i], i);
        }
        for (i in overlays) {
          this._addLayer(overlays[i], i, true);
        }
      },
      onAdd: function(map) {
        this._initLayout();
        this._update();
        this._map = map;
        map.on("zoomend", this._checkDisabledLayers, this);
        for (var i = 0; i < this._layers.length; i++) {
          this._layers[i].layer.on("add remove", this._onLayerChange, this);
        }
        return this._container;
      },
      addTo: function(map) {
        Control.prototype.addTo.call(this, map);
        return this._expandIfNotCollapsed();
      },
      onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var i = 0; i < this._layers.length; i++) {
          this._layers[i].layer.off("add remove", this._onLayerChange, this);
        }
      },
      addBaseLayer: function(layer, name) {
        this._addLayer(layer, name);
        return this._map ? this._update() : this;
      },
      addOverlay: function(layer, name) {
        this._addLayer(layer, name, true);
        return this._map ? this._update() : this;
      },
      removeLayer: function(layer) {
        layer.off("add remove", this._onLayerChange, this);
        var obj = this._getLayer(stamp(layer));
        if (obj) {
          this._layers.splice(this._layers.indexOf(obj), 1);
        }
        return this._map ? this._update() : this;
      },
      expand: function() {
        addClass(this._container, "leaflet-control-layers-expanded");
        this._section.style.height = null;
        var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
        if (acceptableHeight < this._section.clientHeight) {
          addClass(this._section, "leaflet-control-layers-scrollbar");
          this._section.style.height = acceptableHeight + "px";
        } else {
          removeClass(this._section, "leaflet-control-layers-scrollbar");
        }
        this._checkDisabledLayers();
        return this;
      },
      collapse: function() {
        removeClass(this._container, "leaflet-control-layers-expanded");
        return this;
      },
      _initLayout: function() {
        var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
        container.setAttribute("aria-haspopup", true);
        disableClickPropagation(container);
        disableScrollPropagation(container);
        var section = this._section = create$1("section", className + "-list");
        if (collapsed) {
          this._map.on("click", this.collapse, this);
          if (!android) {
            on(container, {
              mouseenter: this.expand,
              mouseleave: this.collapse
            }, this);
          }
        }
        var link = this._layersLink = create$1("a", className + "-toggle", container);
        link.href = "#";
        link.title = "Layers";
        if (touch) {
          on(link, "click", stop);
          on(link, "click", this.expand, this);
        } else {
          on(link, "focus", this.expand, this);
        }
        if (!collapsed) {
          this.expand();
        }
        this._baseLayersList = create$1("div", className + "-base", section);
        this._separator = create$1("div", className + "-separator", section);
        this._overlaysList = create$1("div", className + "-overlays", section);
        container.appendChild(section);
      },
      _getLayer: function(id) {
        for (var i = 0; i < this._layers.length; i++) {
          if (this._layers[i] && stamp(this._layers[i].layer) === id) {
            return this._layers[i];
          }
        }
      },
      _addLayer: function(layer, name, overlay) {
        if (this._map) {
          layer.on("add remove", this._onLayerChange, this);
        }
        this._layers.push({
          layer,
          name,
          overlay
        });
        if (this.options.sortLayers) {
          this._layers.sort(bind2(function(a, b) {
            return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
          }, this));
        }
        if (this.options.autoZIndex && layer.setZIndex) {
          this._lastZIndex++;
          layer.setZIndex(this._lastZIndex);
        }
        this._expandIfNotCollapsed();
      },
      _update: function() {
        if (!this._container) {
          return this;
        }
        empty2(this._baseLayersList);
        empty2(this._overlaysList);
        this._layerControlInputs = [];
        var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
        for (i = 0; i < this._layers.length; i++) {
          obj = this._layers[i];
          this._addItem(obj);
          overlaysPresent = overlaysPresent || obj.overlay;
          baseLayersPresent = baseLayersPresent || !obj.overlay;
          baseLayersCount += !obj.overlay ? 1 : 0;
        }
        if (this.options.hideSingleBase) {
          baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
          this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
        }
        this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
        return this;
      },
      _onLayerChange: function(e) {
        if (!this._handlingClick) {
          this._update();
        }
        var obj = this._getLayer(stamp(e.target));
        var type2 = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
        if (type2) {
          this._map.fire(type2, obj);
        }
      },
      _createRadioElement: function(name, checked) {
        var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
        var radioFragment = document.createElement("div");
        radioFragment.innerHTML = radioHtml;
        return radioFragment.firstChild;
      },
      _addItem: function(obj) {
        var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
        if (obj.overlay) {
          input = document.createElement("input");
          input.type = "checkbox";
          input.className = "leaflet-control-layers-selector";
          input.defaultChecked = checked;
        } else {
          input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
        }
        this._layerControlInputs.push(input);
        input.layerId = stamp(obj.layer);
        on(input, "click", this._onInputClick, this);
        var name = document.createElement("span");
        name.innerHTML = " " + obj.name;
        var holder = document.createElement("div");
        label.appendChild(holder);
        holder.appendChild(input);
        holder.appendChild(name);
        var container = obj.overlay ? this._overlaysList : this._baseLayersList;
        container.appendChild(label);
        this._checkDisabledLayers();
        return label;
      },
      _onInputClick: function() {
        var inputs = this._layerControlInputs, input, layer;
        var addedLayers = [], removedLayers = [];
        this._handlingClick = true;
        for (var i = inputs.length - 1; i >= 0; i--) {
          input = inputs[i];
          layer = this._getLayer(input.layerId).layer;
          if (input.checked) {
            addedLayers.push(layer);
          } else if (!input.checked) {
            removedLayers.push(layer);
          }
        }
        for (i = 0; i < removedLayers.length; i++) {
          if (this._map.hasLayer(removedLayers[i])) {
            this._map.removeLayer(removedLayers[i]);
          }
        }
        for (i = 0; i < addedLayers.length; i++) {
          if (!this._map.hasLayer(addedLayers[i])) {
            this._map.addLayer(addedLayers[i]);
          }
        }
        this._handlingClick = false;
        this._refocusOnMap();
      },
      _checkDisabledLayers: function() {
        var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
        for (var i = inputs.length - 1; i >= 0; i--) {
          input = inputs[i];
          layer = this._getLayer(input.layerId).layer;
          input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
        }
      },
      _expandIfNotCollapsed: function() {
        if (this._map && !this.options.collapsed) {
          this.expand();
        }
        return this;
      },
      _expand: function() {
        return this.expand();
      },
      _collapse: function() {
        return this.collapse();
      }
    });
    var layers = function(baseLayers, overlays, options) {
      return new Layers(baseLayers, overlays, options);
    };
    var Zoom = Control.extend({
      options: {
        position: "topleft",
        zoomInText: "+",
        zoomInTitle: "Zoom in",
        zoomOutText: "&#x2212;",
        zoomOutTitle: "Zoom out"
      },
      onAdd: function(map) {
        var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
        this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + "-in", container, this._zoomIn);
        this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + "-out", container, this._zoomOut);
        this._updateDisabled();
        map.on("zoomend zoomlevelschange", this._updateDisabled, this);
        return container;
      },
      onRemove: function(map) {
        map.off("zoomend zoomlevelschange", this._updateDisabled, this);
      },
      disable: function() {
        this._disabled = true;
        this._updateDisabled();
        return this;
      },
      enable: function() {
        this._disabled = false;
        this._updateDisabled();
        return this;
      },
      _zoomIn: function(e) {
        if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
          this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
        }
      },
      _zoomOut: function(e) {
        if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
          this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
        }
      },
      _createButton: function(html, title, className, container, fn) {
        var link = create$1("a", className, container);
        link.innerHTML = html;
        link.href = "#";
        link.title = title;
        link.setAttribute("role", "button");
        link.setAttribute("aria-label", title);
        disableClickPropagation(link);
        on(link, "click", stop);
        on(link, "click", fn, this);
        on(link, "click", this._refocusOnMap, this);
        return link;
      },
      _updateDisabled: function() {
        var map = this._map, className = "leaflet-disabled";
        removeClass(this._zoomInButton, className);
        removeClass(this._zoomOutButton, className);
        if (this._disabled || map._zoom === map.getMinZoom()) {
          addClass(this._zoomOutButton, className);
        }
        if (this._disabled || map._zoom === map.getMaxZoom()) {
          addClass(this._zoomInButton, className);
        }
      }
    });
    Map2.mergeOptions({
      zoomControl: true
    });
    Map2.addInitHook(function() {
      if (this.options.zoomControl) {
        this.zoomControl = new Zoom();
        this.addControl(this.zoomControl);
      }
    });
    var zoom = function(options) {
      return new Zoom(options);
    };
    var Scale = Control.extend({
      options: {
        position: "bottomleft",
        maxWidth: 100,
        metric: true,
        imperial: true
      },
      onAdd: function(map) {
        var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
        this._addScales(options, className + "-line", container);
        map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
        map.whenReady(this._update, this);
        return container;
      },
      onRemove: function(map) {
        map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
      },
      _addScales: function(options, className, container) {
        if (options.metric) {
          this._mScale = create$1("div", className, container);
        }
        if (options.imperial) {
          this._iScale = create$1("div", className, container);
        }
      },
      _update: function() {
        var map = this._map, y = map.getSize().y / 2;
        var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));
        this._updateScales(maxMeters);
      },
      _updateScales: function(maxMeters) {
        if (this.options.metric && maxMeters) {
          this._updateMetric(maxMeters);
        }
        if (this.options.imperial && maxMeters) {
          this._updateImperial(maxMeters);
        }
      },
      _updateMetric: function(maxMeters) {
        var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
        this._updateScale(this._mScale, label, meters / maxMeters);
      },
      _updateImperial: function(maxMeters) {
        var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
        if (maxFeet > 5280) {
          maxMiles = maxFeet / 5280;
          miles = this._getRoundNum(maxMiles);
          this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
        } else {
          feet = this._getRoundNum(maxFeet);
          this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
        }
      },
      _updateScale: function(scale2, text2, ratio) {
        scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
        scale2.innerHTML = text2;
      },
      _getRoundNum: function(num) {
        var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
        d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
        return pow10 * d;
      }
    });
    var scale = function(options) {
      return new Scale(options);
    };
    var Attribution = Control.extend({
      options: {
        position: "bottomright",
        prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
      },
      initialize: function(options) {
        setOptions(this, options);
        this._attributions = {};
      },
      onAdd: function(map) {
        map.attributionControl = this;
        this._container = create$1("div", "leaflet-control-attribution");
        disableClickPropagation(this._container);
        for (var i in map._layers) {
          if (map._layers[i].getAttribution) {
            this.addAttribution(map._layers[i].getAttribution());
          }
        }
        this._update();
        return this._container;
      },
      setPrefix: function(prefix) {
        this.options.prefix = prefix;
        this._update();
        return this;
      },
      addAttribution: function(text2) {
        if (!text2) {
          return this;
        }
        if (!this._attributions[text2]) {
          this._attributions[text2] = 0;
        }
        this._attributions[text2]++;
        this._update();
        return this;
      },
      removeAttribution: function(text2) {
        if (!text2) {
          return this;
        }
        if (this._attributions[text2]) {
          this._attributions[text2]--;
          this._update();
        }
        return this;
      },
      _update: function() {
        if (!this._map) {
          return;
        }
        var attribs = [];
        for (var i in this._attributions) {
          if (this._attributions[i]) {
            attribs.push(i);
          }
        }
        var prefixAndAttribs = [];
        if (this.options.prefix) {
          prefixAndAttribs.push(this.options.prefix);
        }
        if (attribs.length) {
          prefixAndAttribs.push(attribs.join(", "));
        }
        this._container.innerHTML = prefixAndAttribs.join(" | ");
      }
    });
    Map2.mergeOptions({
      attributionControl: true
    });
    Map2.addInitHook(function() {
      if (this.options.attributionControl) {
        new Attribution().addTo(this);
      }
    });
    var attribution = function(options) {
      return new Attribution(options);
    };
    Control.Layers = Layers;
    Control.Zoom = Zoom;
    Control.Scale = Scale;
    Control.Attribution = Attribution;
    control.layers = layers;
    control.zoom = zoom;
    control.scale = scale;
    control.attribution = attribution;
    var Handler = Class.extend({
      initialize: function(map) {
        this._map = map;
      },
      enable: function() {
        if (this._enabled) {
          return this;
        }
        this._enabled = true;
        this.addHooks();
        return this;
      },
      disable: function() {
        if (!this._enabled) {
          return this;
        }
        this._enabled = false;
        this.removeHooks();
        return this;
      },
      enabled: function() {
        return !!this._enabled;
      }
    });
    Handler.addTo = function(map, name) {
      map.addHandler(name, this);
      return this;
    };
    var Mixin = { Events };
    var START = touch ? "touchstart mousedown" : "mousedown";
    var END = {
      mousedown: "mouseup",
      touchstart: "touchend",
      pointerdown: "touchend",
      MSPointerDown: "touchend"
    };
    var MOVE = {
      mousedown: "mousemove",
      touchstart: "touchmove",
      pointerdown: "touchmove",
      MSPointerDown: "touchmove"
    };
    var Draggable = Evented.extend({
      options: {
        clickTolerance: 3
      },
      initialize: function(element2, dragStartTarget, preventOutline$$1, options) {
        setOptions(this, options);
        this._element = element2;
        this._dragStartTarget = dragStartTarget || element2;
        this._preventOutline = preventOutline$$1;
      },
      enable: function() {
        if (this._enabled) {
          return;
        }
        on(this._dragStartTarget, START, this._onDown, this);
        this._enabled = true;
      },
      disable: function() {
        if (!this._enabled) {
          return;
        }
        if (Draggable._dragging === this) {
          this.finishDrag();
        }
        off(this._dragStartTarget, START, this._onDown, this);
        this._enabled = false;
        this._moved = false;
      },
      _onDown: function(e) {
        if (e._simulated || !this._enabled) {
          return;
        }
        this._moved = false;
        if (hasClass(this._element, "leaflet-zoom-anim")) {
          return;
        }
        if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
          return;
        }
        Draggable._dragging = this;
        if (this._preventOutline) {
          preventOutline(this._element);
        }
        disableImageDrag();
        disableTextSelection();
        if (this._moving) {
          return;
        }
        this.fire("down");
        var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
        this._startPoint = new Point(first.clientX, first.clientY);
        this._parentScale = getScale(sizedParent);
        on(document, MOVE[e.type], this._onMove, this);
        on(document, END[e.type], this._onUp, this);
      },
      _onMove: function(e) {
        if (e._simulated || !this._enabled) {
          return;
        }
        if (e.touches && e.touches.length > 1) {
          this._moved = true;
          return;
        }
        var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
        if (!offset.x && !offset.y) {
          return;
        }
        if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
          return;
        }
        offset.x /= this._parentScale.x;
        offset.y /= this._parentScale.y;
        preventDefault(e);
        if (!this._moved) {
          this.fire("dragstart");
          this._moved = true;
          this._startPos = getPosition(this._element).subtract(offset);
          addClass(document.body, "leaflet-dragging");
          this._lastTarget = e.target || e.srcElement;
          if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
            this._lastTarget = this._lastTarget.correspondingUseElement;
          }
          addClass(this._lastTarget, "leaflet-drag-target");
        }
        this._newPos = this._startPos.add(offset);
        this._moving = true;
        cancelAnimFrame(this._animRequest);
        this._lastEvent = e;
        this._animRequest = requestAnimFrame(this._updatePosition, this, true);
      },
      _updatePosition: function() {
        var e = { originalEvent: this._lastEvent };
        this.fire("predrag", e);
        setPosition(this._element, this._newPos);
        this.fire("drag", e);
      },
      _onUp: function(e) {
        if (e._simulated || !this._enabled) {
          return;
        }
        this.finishDrag();
      },
      finishDrag: function() {
        removeClass(document.body, "leaflet-dragging");
        if (this._lastTarget) {
          removeClass(this._lastTarget, "leaflet-drag-target");
          this._lastTarget = null;
        }
        for (var i in MOVE) {
          off(document, MOVE[i], this._onMove, this);
          off(document, END[i], this._onUp, this);
        }
        enableImageDrag();
        enableTextSelection();
        if (this._moved && this._moving) {
          cancelAnimFrame(this._animRequest);
          this.fire("dragend", {
            distance: this._newPos.distanceTo(this._startPos)
          });
        }
        this._moving = false;
        Draggable._dragging = false;
      }
    });
    function simplify(points, tolerance) {
      if (!tolerance || !points.length) {
        return points.slice();
      }
      var sqTolerance = tolerance * tolerance;
      points = _reducePoints(points, sqTolerance);
      points = _simplifyDP(points, sqTolerance);
      return points;
    }
    function pointToSegmentDistance(p2, p1, p22) {
      return Math.sqrt(_sqClosestPointOnSegment(p2, p1, p22, true));
    }
    function closestPointOnSegment(p2, p1, p22) {
      return _sqClosestPointOnSegment(p2, p1, p22);
    }
    function _simplifyDP(points, sqTolerance) {
      var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
      markers[0] = markers[len - 1] = 1;
      _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
      var i, newPoints = [];
      for (i = 0; i < len; i++) {
        if (markers[i]) {
          newPoints.push(points[i]);
        }
      }
      return newPoints;
    }
    function _simplifyDPStep(points, markers, sqTolerance, first, last) {
      var maxSqDist = 0, index2, i, sqDist;
      for (i = first + 1; i <= last - 1; i++) {
        sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
        if (sqDist > maxSqDist) {
          index2 = i;
          maxSqDist = sqDist;
        }
      }
      if (maxSqDist > sqTolerance) {
        markers[index2] = 1;
        _simplifyDPStep(points, markers, sqTolerance, first, index2);
        _simplifyDPStep(points, markers, sqTolerance, index2, last);
      }
    }
    function _reducePoints(points, sqTolerance) {
      var reducedPoints = [points[0]];
      for (var i = 1, prev = 0, len = points.length; i < len; i++) {
        if (_sqDist(points[i], points[prev]) > sqTolerance) {
          reducedPoints.push(points[i]);
          prev = i;
        }
      }
      if (prev < len - 1) {
        reducedPoints.push(points[len - 1]);
      }
      return reducedPoints;
    }
    var _lastCode;
    function clipSegment(a, b, bounds, useLastCode, round) {
      var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p2, newCode;
      _lastCode = codeB;
      while (true) {
        if (!(codeA | codeB)) {
          return [a, b];
        }
        if (codeA & codeB) {
          return false;
        }
        codeOut = codeA || codeB;
        p2 = _getEdgeIntersection(a, b, codeOut, bounds, round);
        newCode = _getBitCode(p2, bounds);
        if (codeOut === codeA) {
          a = p2;
          codeA = newCode;
        } else {
          b = p2;
          codeB = newCode;
        }
      }
    }
    function _getEdgeIntersection(a, b, code, bounds, round) {
      var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
      if (code & 8) {
        x = a.x + dx * (max.y - a.y) / dy;
        y = max.y;
      } else if (code & 4) {
        x = a.x + dx * (min.y - a.y) / dy;
        y = min.y;
      } else if (code & 2) {
        x = max.x;
        y = a.y + dy * (max.x - a.x) / dx;
      } else if (code & 1) {
        x = min.x;
        y = a.y + dy * (min.x - a.x) / dx;
      }
      return new Point(x, y, round);
    }
    function _getBitCode(p2, bounds) {
      var code = 0;
      if (p2.x < bounds.min.x) {
        code |= 1;
      } else if (p2.x > bounds.max.x) {
        code |= 2;
      }
      if (p2.y < bounds.min.y) {
        code |= 4;
      } else if (p2.y > bounds.max.y) {
        code |= 8;
      }
      return code;
    }
    function _sqDist(p1, p2) {
      var dx = p2.x - p1.x, dy = p2.y - p1.y;
      return dx * dx + dy * dy;
    }
    function _sqClosestPointOnSegment(p2, p1, p22, sqDist) {
      var x = p1.x, y = p1.y, dx = p22.x - x, dy = p22.y - y, dot = dx * dx + dy * dy, t;
      if (dot > 0) {
        t = ((p2.x - x) * dx + (p2.y - y) * dy) / dot;
        if (t > 1) {
          x = p22.x;
          y = p22.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }
      dx = p2.x - x;
      dy = p2.y - y;
      return sqDist ? dx * dx + dy * dy : new Point(x, y);
    }
    function isFlat(latlngs) {
      return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
    }
    function _flat(latlngs) {
      console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
      return isFlat(latlngs);
    }
    var LineUtil = {
      simplify,
      pointToSegmentDistance,
      closestPointOnSegment,
      clipSegment,
      _getEdgeIntersection,
      _getBitCode,
      _sqClosestPointOnSegment,
      isFlat,
      _flat
    };
    function clipPolygon(points, bounds, round) {
      var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p2;
      for (i = 0, len = points.length; i < len; i++) {
        points[i]._code = _getBitCode(points[i], bounds);
      }
      for (k = 0; k < 4; k++) {
        edge2 = edges[k];
        clippedPoints = [];
        for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
          a = points[i];
          b = points[j];
          if (!(a._code & edge2)) {
            if (b._code & edge2) {
              p2 = _getEdgeIntersection(b, a, edge2, bounds, round);
              p2._code = _getBitCode(p2, bounds);
              clippedPoints.push(p2);
            }
            clippedPoints.push(a);
          } else if (!(b._code & edge2)) {
            p2 = _getEdgeIntersection(b, a, edge2, bounds, round);
            p2._code = _getBitCode(p2, bounds);
            clippedPoints.push(p2);
          }
        }
        points = clippedPoints;
      }
      return points;
    }
    var PolyUtil = {
      clipPolygon
    };
    var LonLat = {
      project: function(latlng) {
        return new Point(latlng.lng, latlng.lat);
      },
      unproject: function(point) {
        return new LatLng(point.y, point.x);
      },
      bounds: new Bounds([-180, -90], [180, 90])
    };
    var Mercator = {
      R: 6378137,
      R_MINOR: 6356752314245179e-9,
      bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
      project: function(latlng) {
        var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
        var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
        y = -r * Math.log(Math.max(ts, 1e-10));
        return new Point(latlng.lng * d * r, y);
      },
      unproject: function(point) {
        var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
        for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
          con = e * Math.sin(phi);
          con = Math.pow((1 - con) / (1 + con), e / 2);
          dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
          phi += dphi;
        }
        return new LatLng(phi * d, point.x * d / r);
      }
    };
    var index = {
      LonLat,
      Mercator,
      SphericalMercator
    };
    var EPSG3395 = extend({}, Earth, {
      code: "EPSG:3395",
      projection: Mercator,
      transformation: function() {
        var scale2 = 0.5 / (Math.PI * Mercator.R);
        return toTransformation(scale2, 0.5, -scale2, 0.5);
      }()
    });
    var EPSG4326 = extend({}, Earth, {
      code: "EPSG:4326",
      projection: LonLat,
      transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
    });
    var Simple = extend({}, CRS, {
      projection: LonLat,
      transformation: toTransformation(1, 0, -1, 0),
      scale: function(zoom2) {
        return Math.pow(2, zoom2);
      },
      zoom: function(scale2) {
        return Math.log(scale2) / Math.LN2;
      },
      distance: function(latlng1, latlng2) {
        var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
        return Math.sqrt(dx * dx + dy * dy);
      },
      infinite: true
    });
    CRS.Earth = Earth;
    CRS.EPSG3395 = EPSG3395;
    CRS.EPSG3857 = EPSG3857;
    CRS.EPSG900913 = EPSG900913;
    CRS.EPSG4326 = EPSG4326;
    CRS.Simple = Simple;
    var Layer = Evented.extend({
      options: {
        pane: "overlayPane",
        attribution: null,
        bubblingMouseEvents: true
      },
      addTo: function(map) {
        map.addLayer(this);
        return this;
      },
      remove: function() {
        return this.removeFrom(this._map || this._mapToAdd);
      },
      removeFrom: function(obj) {
        if (obj) {
          obj.removeLayer(this);
        }
        return this;
      },
      getPane: function(name) {
        return this._map.getPane(name ? this.options[name] || name : this.options.pane);
      },
      addInteractiveTarget: function(targetEl) {
        this._map._targets[stamp(targetEl)] = this;
        return this;
      },
      removeInteractiveTarget: function(targetEl) {
        delete this._map._targets[stamp(targetEl)];
        return this;
      },
      getAttribution: function() {
        return this.options.attribution;
      },
      _layerAdd: function(e) {
        var map = e.target;
        if (!map.hasLayer(this)) {
          return;
        }
        this._map = map;
        this._zoomAnimated = map._zoomAnimated;
        if (this.getEvents) {
          var events2 = this.getEvents();
          map.on(events2, this);
          this.once("remove", function() {
            map.off(events2, this);
          }, this);
        }
        this.onAdd(map);
        if (this.getAttribution && map.attributionControl) {
          map.attributionControl.addAttribution(this.getAttribution());
        }
        this.fire("add");
        map.fire("layeradd", { layer: this });
      }
    });
    Map2.include({
      addLayer: function(layer) {
        if (!layer._layerAdd) {
          throw new Error("The provided object is not a Layer.");
        }
        var id = stamp(layer);
        if (this._layers[id]) {
          return this;
        }
        this._layers[id] = layer;
        layer._mapToAdd = this;
        if (layer.beforeAdd) {
          layer.beforeAdd(this);
        }
        this.whenReady(layer._layerAdd, layer);
        return this;
      },
      removeLayer: function(layer) {
        var id = stamp(layer);
        if (!this._layers[id]) {
          return this;
        }
        if (this._loaded) {
          layer.onRemove(this);
        }
        if (layer.getAttribution && this.attributionControl) {
          this.attributionControl.removeAttribution(layer.getAttribution());
        }
        delete this._layers[id];
        if (this._loaded) {
          this.fire("layerremove", { layer });
          layer.fire("remove");
        }
        layer._map = layer._mapToAdd = null;
        return this;
      },
      hasLayer: function(layer) {
        return !!layer && stamp(layer) in this._layers;
      },
      eachLayer: function(method, context) {
        for (var i in this._layers) {
          method.call(context, this._layers[i]);
        }
        return this;
      },
      _addLayers: function(layers2) {
        layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
        for (var i = 0, len = layers2.length; i < len; i++) {
          this.addLayer(layers2[i]);
        }
      },
      _addZoomLimit: function(layer) {
        if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
          this._zoomBoundLayers[stamp(layer)] = layer;
          this._updateZoomLevels();
        }
      },
      _removeZoomLimit: function(layer) {
        var id = stamp(layer);
        if (this._zoomBoundLayers[id]) {
          delete this._zoomBoundLayers[id];
          this._updateZoomLevels();
        }
      },
      _updateZoomLevels: function() {
        var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
        for (var i in this._zoomBoundLayers) {
          var options = this._zoomBoundLayers[i].options;
          minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
          maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
        }
        this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
        this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
        if (oldZoomSpan !== this._getZoomSpan()) {
          this.fire("zoomlevelschange");
        }
        if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
          this.setZoom(this._layersMaxZoom);
        }
        if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
          this.setZoom(this._layersMinZoom);
        }
      }
    });
    var LayerGroup = Layer.extend({
      initialize: function(layers2, options) {
        setOptions(this, options);
        this._layers = {};
        var i, len;
        if (layers2) {
          for (i = 0, len = layers2.length; i < len; i++) {
            this.addLayer(layers2[i]);
          }
        }
      },
      addLayer: function(layer) {
        var id = this.getLayerId(layer);
        this._layers[id] = layer;
        if (this._map) {
          this._map.addLayer(layer);
        }
        return this;
      },
      removeLayer: function(layer) {
        var id = layer in this._layers ? layer : this.getLayerId(layer);
        if (this._map && this._layers[id]) {
          this._map.removeLayer(this._layers[id]);
        }
        delete this._layers[id];
        return this;
      },
      hasLayer: function(layer) {
        if (!layer) {
          return false;
        }
        var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
        return layerId in this._layers;
      },
      clearLayers: function() {
        return this.eachLayer(this.removeLayer, this);
      },
      invoke: function(methodName) {
        var args = Array.prototype.slice.call(arguments, 1), i, layer;
        for (i in this._layers) {
          layer = this._layers[i];
          if (layer[methodName]) {
            layer[methodName].apply(layer, args);
          }
        }
        return this;
      },
      onAdd: function(map) {
        this.eachLayer(map.addLayer, map);
      },
      onRemove: function(map) {
        this.eachLayer(map.removeLayer, map);
      },
      eachLayer: function(method, context) {
        for (var i in this._layers) {
          method.call(context, this._layers[i]);
        }
        return this;
      },
      getLayer: function(id) {
        return this._layers[id];
      },
      getLayers: function() {
        var layers2 = [];
        this.eachLayer(layers2.push, layers2);
        return layers2;
      },
      setZIndex: function(zIndex) {
        return this.invoke("setZIndex", zIndex);
      },
      getLayerId: function(layer) {
        return stamp(layer);
      }
    });
    var layerGroup = function(layers2, options) {
      return new LayerGroup(layers2, options);
    };
    var FeatureGroup = LayerGroup.extend({
      addLayer: function(layer) {
        if (this.hasLayer(layer)) {
          return this;
        }
        layer.addEventParent(this);
        LayerGroup.prototype.addLayer.call(this, layer);
        return this.fire("layeradd", { layer });
      },
      removeLayer: function(layer) {
        if (!this.hasLayer(layer)) {
          return this;
        }
        if (layer in this._layers) {
          layer = this._layers[layer];
        }
        layer.removeEventParent(this);
        LayerGroup.prototype.removeLayer.call(this, layer);
        return this.fire("layerremove", { layer });
      },
      setStyle: function(style) {
        return this.invoke("setStyle", style);
      },
      bringToFront: function() {
        return this.invoke("bringToFront");
      },
      bringToBack: function() {
        return this.invoke("bringToBack");
      },
      getBounds: function() {
        var bounds = new LatLngBounds();
        for (var id in this._layers) {
          var layer = this._layers[id];
          bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
        }
        return bounds;
      }
    });
    var featureGroup = function(layers2, options) {
      return new FeatureGroup(layers2, options);
    };
    var Icon = Class.extend({
      options: {
        popupAnchor: [0, 0],
        tooltipAnchor: [0, 0]
      },
      initialize: function(options) {
        setOptions(this, options);
      },
      createIcon: function(oldIcon) {
        return this._createIcon("icon", oldIcon);
      },
      createShadow: function(oldIcon) {
        return this._createIcon("shadow", oldIcon);
      },
      _createIcon: function(name, oldIcon) {
        var src = this._getIconUrl(name);
        if (!src) {
          if (name === "icon") {
            throw new Error("iconUrl not set in Icon options (see the docs).");
          }
          return null;
        }
        var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
        this._setIconStyles(img, name);
        return img;
      },
      _setIconStyles: function(img, name) {
        var options = this.options;
        var sizeOption = options[name + "Size"];
        if (typeof sizeOption === "number") {
          sizeOption = [sizeOption, sizeOption];
        }
        var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
        img.className = "leaflet-marker-" + name + " " + (options.className || "");
        if (anchor) {
          img.style.marginLeft = -anchor.x + "px";
          img.style.marginTop = -anchor.y + "px";
        }
        if (size) {
          img.style.width = size.x + "px";
          img.style.height = size.y + "px";
        }
      },
      _createImg: function(src, el) {
        el = el || document.createElement("img");
        el.src = src;
        return el;
      },
      _getIconUrl: function(name) {
        return retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
      }
    });
    function icon(options) {
      return new Icon(options);
    }
    var IconDefault = Icon.extend({
      options: {
        iconUrl: "marker-icon.png",
        iconRetinaUrl: "marker-icon-2x.png",
        shadowUrl: "marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function(name) {
        if (!IconDefault.imagePath) {
          IconDefault.imagePath = this._detectIconPath();
        }
        return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
      },
      _detectIconPath: function() {
        var el = create$1("div", "leaflet-default-icon-path", document.body);
        var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
        document.body.removeChild(el);
        if (path === null || path.indexOf("url") !== 0) {
          path = "";
        } else {
          path = path.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, "");
        }
        return path;
      }
    });
    var MarkerDrag = Handler.extend({
      initialize: function(marker2) {
        this._marker = marker2;
      },
      addHooks: function() {
        var icon2 = this._marker._icon;
        if (!this._draggable) {
          this._draggable = new Draggable(icon2, icon2, true);
        }
        this._draggable.on({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable();
        addClass(icon2, "leaflet-marker-draggable");
      },
      removeHooks: function() {
        this._draggable.off({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable();
        if (this._marker._icon) {
          removeClass(this._marker._icon, "leaflet-marker-draggable");
        }
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      _adjustPan: function(e) {
        var marker2 = this._marker, map = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
        var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
        if (!panBounds.contains(iconPos)) {
          var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
          map.panBy(movement, { animate: false });
          this._draggable._newPos._add(movement);
          this._draggable._startPos._add(movement);
          setPosition(marker2._icon, this._draggable._newPos);
          this._onDrag(e);
          this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
        }
      },
      _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng();
        this._marker.closePopup && this._marker.closePopup();
        this._marker.fire("movestart").fire("dragstart");
      },
      _onPreDrag: function(e) {
        if (this._marker.options.autoPan) {
          cancelAnimFrame(this._panRequest);
          this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
        }
      },
      _onDrag: function(e) {
        var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
        if (shadow) {
          setPosition(shadow, iconPos);
        }
        marker2._latlng = latlng;
        e.latlng = latlng;
        e.oldLatLng = this._oldLatLng;
        marker2.fire("move", e).fire("drag", e);
      },
      _onDragEnd: function(e) {
        cancelAnimFrame(this._panRequest);
        delete this._oldLatLng;
        this._marker.fire("moveend").fire("dragend", e);
      }
    });
    var Marker = Layer.extend({
      options: {
        icon: new IconDefault(),
        interactive: true,
        keyboard: true,
        title: "",
        alt: "",
        zIndexOffset: 0,
        opacity: 1,
        riseOnHover: false,
        riseOffset: 250,
        pane: "markerPane",
        shadowPane: "shadowPane",
        bubblingMouseEvents: false,
        draggable: false,
        autoPan: false,
        autoPanPadding: [50, 50],
        autoPanSpeed: 10
      },
      initialize: function(latlng, options) {
        setOptions(this, options);
        this._latlng = toLatLng(latlng);
      },
      onAdd: function(map) {
        this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
        if (this._zoomAnimated) {
          map.on("zoomanim", this._animateZoom, this);
        }
        this._initIcon();
        this.update();
      },
      onRemove: function(map) {
        if (this.dragging && this.dragging.enabled()) {
          this.options.draggable = true;
          this.dragging.removeHooks();
        }
        delete this.dragging;
        if (this._zoomAnimated) {
          map.off("zoomanim", this._animateZoom, this);
        }
        this._removeIcon();
        this._removeShadow();
      },
      getEvents: function() {
        return {
          zoom: this.update,
          viewreset: this.update
        };
      },
      getLatLng: function() {
        return this._latlng;
      },
      setLatLng: function(latlng) {
        var oldLatLng = this._latlng;
        this._latlng = toLatLng(latlng);
        this.update();
        return this.fire("move", { oldLatLng, latlng: this._latlng });
      },
      setZIndexOffset: function(offset) {
        this.options.zIndexOffset = offset;
        return this.update();
      },
      getIcon: function() {
        return this.options.icon;
      },
      setIcon: function(icon2) {
        this.options.icon = icon2;
        if (this._map) {
          this._initIcon();
          this.update();
        }
        if (this._popup) {
          this.bindPopup(this._popup, this._popup.options);
        }
        return this;
      },
      getElement: function() {
        return this._icon;
      },
      update: function() {
        if (this._icon && this._map) {
          var pos = this._map.latLngToLayerPoint(this._latlng).round();
          this._setPos(pos);
        }
        return this;
      },
      _initIcon: function() {
        var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        var icon2 = options.icon.createIcon(this._icon), addIcon = false;
        if (icon2 !== this._icon) {
          if (this._icon) {
            this._removeIcon();
          }
          addIcon = true;
          if (options.title) {
            icon2.title = options.title;
          }
          if (icon2.tagName === "IMG") {
            icon2.alt = options.alt || "";
          }
        }
        addClass(icon2, classToAdd);
        if (options.keyboard) {
          icon2.tabIndex = "0";
        }
        this._icon = icon2;
        if (options.riseOnHover) {
          this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }
        var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
        if (newShadow !== this._shadow) {
          this._removeShadow();
          addShadow = true;
        }
        if (newShadow) {
          addClass(newShadow, classToAdd);
          newShadow.alt = "";
        }
        this._shadow = newShadow;
        if (options.opacity < 1) {
          this._updateOpacity();
        }
        if (addIcon) {
          this.getPane().appendChild(this._icon);
        }
        this._initInteraction();
        if (newShadow && addShadow) {
          this.getPane(options.shadowPane).appendChild(this._shadow);
        }
      },
      _removeIcon: function() {
        if (this.options.riseOnHover) {
          this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }
        remove(this._icon);
        this.removeInteractiveTarget(this._icon);
        this._icon = null;
      },
      _removeShadow: function() {
        if (this._shadow) {
          remove(this._shadow);
        }
        this._shadow = null;
      },
      _setPos: function(pos) {
        if (this._icon) {
          setPosition(this._icon, pos);
        }
        if (this._shadow) {
          setPosition(this._shadow, pos);
        }
        this._zIndex = pos.y + this.options.zIndexOffset;
        this._resetZIndex();
      },
      _updateZIndex: function(offset) {
        if (this._icon) {
          this._icon.style.zIndex = this._zIndex + offset;
        }
      },
      _animateZoom: function(opt) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
        this._setPos(pos);
      },
      _initInteraction: function() {
        if (!this.options.interactive) {
          return;
        }
        addClass(this._icon, "leaflet-interactive");
        this.addInteractiveTarget(this._icon);
        if (MarkerDrag) {
          var draggable = this.options.draggable;
          if (this.dragging) {
            draggable = this.dragging.enabled();
            this.dragging.disable();
          }
          this.dragging = new MarkerDrag(this);
          if (draggable) {
            this.dragging.enable();
          }
        }
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._map) {
          this._updateOpacity();
        }
        return this;
      },
      _updateOpacity: function() {
        var opacity = this.options.opacity;
        if (this._icon) {
          setOpacity(this._icon, opacity);
        }
        if (this._shadow) {
          setOpacity(this._shadow, opacity);
        }
      },
      _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset);
      },
      _resetZIndex: function() {
        this._updateZIndex(0);
      },
      _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor;
      },
      _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor;
      }
    });
    function marker(latlng, options) {
      return new Marker(latlng, options);
    }
    var Path = Layer.extend({
      options: {
        stroke: true,
        color: "#3388ff",
        weight: 3,
        opacity: 1,
        lineCap: "round",
        lineJoin: "round",
        dashArray: null,
        dashOffset: null,
        fill: false,
        fillColor: null,
        fillOpacity: 0.2,
        fillRule: "evenodd",
        interactive: true,
        bubblingMouseEvents: true
      },
      beforeAdd: function(map) {
        this._renderer = map.getRenderer(this);
      },
      onAdd: function() {
        this._renderer._initPath(this);
        this._reset();
        this._renderer._addPath(this);
      },
      onRemove: function() {
        this._renderer._removePath(this);
      },
      redraw: function() {
        if (this._map) {
          this._renderer._updatePath(this);
        }
        return this;
      },
      setStyle: function(style) {
        setOptions(this, style);
        if (this._renderer) {
          this._renderer._updateStyle(this);
          if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, "weight")) {
            this._updateBounds();
          }
        }
        return this;
      },
      bringToFront: function() {
        if (this._renderer) {
          this._renderer._bringToFront(this);
        }
        return this;
      },
      bringToBack: function() {
        if (this._renderer) {
          this._renderer._bringToBack(this);
        }
        return this;
      },
      getElement: function() {
        return this._path;
      },
      _reset: function() {
        this._project();
        this._update();
      },
      _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
      }
    });
    var CircleMarker = Path.extend({
      options: {
        fill: true,
        radius: 10
      },
      initialize: function(latlng, options) {
        setOptions(this, options);
        this._latlng = toLatLng(latlng);
        this._radius = this.options.radius;
      },
      setLatLng: function(latlng) {
        var oldLatLng = this._latlng;
        this._latlng = toLatLng(latlng);
        this.redraw();
        return this.fire("move", { oldLatLng, latlng: this._latlng });
      },
      getLatLng: function() {
        return this._latlng;
      },
      setRadius: function(radius2) {
        this.options.radius = this._radius = radius2;
        return this.redraw();
      },
      getRadius: function() {
        return this._radius;
      },
      setStyle: function(options) {
        var radius2 = options && options.radius || this._radius;
        Path.prototype.setStyle.call(this, options);
        this.setRadius(radius2);
        return this;
      },
      _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._updateBounds();
      },
      _updateBounds: function() {
        var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p2 = [r + w, r2 + w];
        this._pxBounds = new Bounds(this._point.subtract(p2), this._point.add(p2));
      },
      _update: function() {
        if (this._map) {
          this._updatePath();
        }
      },
      _updatePath: function() {
        this._renderer._updateCircle(this);
      },
      _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      },
      _containsPoint: function(p2) {
        return p2.distanceTo(this._point) <= this._radius + this._clickTolerance();
      }
    });
    function circleMarker(latlng, options) {
      return new CircleMarker(latlng, options);
    }
    var Circle = CircleMarker.extend({
      initialize: function(latlng, options, legacyOptions) {
        if (typeof options === "number") {
          options = extend({}, legacyOptions, { radius: options });
        }
        setOptions(this, options);
        this._latlng = toLatLng(latlng);
        if (isNaN(this.options.radius)) {
          throw new Error("Circle radius cannot be NaN");
        }
        this._mRadius = this.options.radius;
      },
      setRadius: function(radius2) {
        this._mRadius = radius2;
        return this.redraw();
      },
      getRadius: function() {
        return this._mRadius;
      },
      getBounds: function() {
        var half = [this._radius, this._radiusY || this._radius];
        return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
      },
      setStyle: Path.prototype.setStyle,
      _project: function() {
        var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
        if (crs.distance === Earth.distance) {
          var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p2 = top.add(bottom).divideBy(2), lat2 = map.unproject(p2).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
          if (isNaN(lngR) || lngR === 0) {
            lngR = latR / Math.cos(Math.PI / 180 * lat);
          }
          this._point = p2.subtract(map.getPixelOrigin());
          this._radius = isNaN(lngR) ? 0 : p2.x - map.project([lat2, lng - lngR]).x;
          this._radiusY = p2.y - top.y;
        } else {
          var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
          this._point = map.latLngToLayerPoint(this._latlng);
          this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
        }
        this._updateBounds();
      }
    });
    function circle(latlng, options, legacyOptions) {
      return new Circle(latlng, options, legacyOptions);
    }
    var Polyline = Path.extend({
      options: {
        smoothFactor: 1,
        noClip: false
      },
      initialize: function(latlngs, options) {
        setOptions(this, options);
        this._setLatLngs(latlngs);
      },
      getLatLngs: function() {
        return this._latlngs;
      },
      setLatLngs: function(latlngs) {
        this._setLatLngs(latlngs);
        return this.redraw();
      },
      isEmpty: function() {
        return !this._latlngs.length;
      },
      closestLayerPoint: function(p2) {
        var minDistance = Infinity, minPoint = null, closest2 = _sqClosestPointOnSegment, p1, p22;
        for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
          var points = this._parts[j];
          for (var i = 1, len = points.length; i < len; i++) {
            p1 = points[i - 1];
            p22 = points[i];
            var sqDist = closest2(p2, p1, p22, true);
            if (sqDist < minDistance) {
              minDistance = sqDist;
              minPoint = closest2(p2, p1, p22);
            }
          }
        }
        if (minPoint) {
          minPoint.distance = Math.sqrt(minDistance);
        }
        return minPoint;
      },
      getCenter: function() {
        if (!this._map) {
          throw new Error("Must add layer to map before using getCenter()");
        }
        var i, halfDist, segDist, dist2, p1, p2, ratio, points = this._rings[0], len = points.length;
        if (!len) {
          return null;
        }
        for (i = 0, halfDist = 0; i < len - 1; i++) {
          halfDist += points[i].distanceTo(points[i + 1]) / 2;
        }
        if (halfDist === 0) {
          return this._map.layerPointToLatLng(points[0]);
        }
        for (i = 0, dist2 = 0; i < len - 1; i++) {
          p1 = points[i];
          p2 = points[i + 1];
          segDist = p1.distanceTo(p2);
          dist2 += segDist;
          if (dist2 > halfDist) {
            ratio = (dist2 - halfDist) / segDist;
            return this._map.layerPointToLatLng([
              p2.x - ratio * (p2.x - p1.x),
              p2.y - ratio * (p2.y - p1.y)
            ]);
          }
        }
      },
      getBounds: function() {
        return this._bounds;
      },
      addLatLng: function(latlng, latlngs) {
        latlngs = latlngs || this._defaultShape();
        latlng = toLatLng(latlng);
        latlngs.push(latlng);
        this._bounds.extend(latlng);
        return this.redraw();
      },
      _setLatLngs: function(latlngs) {
        this._bounds = new LatLngBounds();
        this._latlngs = this._convertLatLngs(latlngs);
      },
      _defaultShape: function() {
        return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
      },
      _convertLatLngs: function(latlngs) {
        var result = [], flat = isFlat(latlngs);
        for (var i = 0, len = latlngs.length; i < len; i++) {
          if (flat) {
            result[i] = toLatLng(latlngs[i]);
            this._bounds.extend(result[i]);
          } else {
            result[i] = this._convertLatLngs(latlngs[i]);
          }
        }
        return result;
      },
      _project: function() {
        var pxBounds = new Bounds();
        this._rings = [];
        this._projectLatlngs(this._latlngs, this._rings, pxBounds);
        if (this._bounds.isValid() && pxBounds.isValid()) {
          this._rawPxBounds = pxBounds;
          this._updateBounds();
        }
      },
      _updateBounds: function() {
        var w = this._clickTolerance(), p2 = new Point(w, w);
        this._pxBounds = new Bounds([
          this._rawPxBounds.min.subtract(p2),
          this._rawPxBounds.max.add(p2)
        ]);
      },
      _projectLatlngs: function(latlngs, result, projectedBounds) {
        var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
        if (flat) {
          ring = [];
          for (i = 0; i < len; i++) {
            ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
            projectedBounds.extend(ring[i]);
          }
          result.push(ring);
        } else {
          for (i = 0; i < len; i++) {
            this._projectLatlngs(latlngs[i], result, projectedBounds);
          }
        }
      },
      _clipPoints: function() {
        var bounds = this._renderer._bounds;
        this._parts = [];
        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }
        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }
        var parts = this._parts, i, j, k, len, len2, segment, points;
        for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
          points = this._rings[i];
          for (j = 0, len2 = points.length; j < len2 - 1; j++) {
            segment = clipSegment(points[j], points[j + 1], bounds, j, true);
            if (!segment) {
              continue;
            }
            parts[k] = parts[k] || [];
            parts[k].push(segment[0]);
            if (segment[1] !== points[j + 1] || j === len2 - 2) {
              parts[k].push(segment[1]);
              k++;
            }
          }
        }
      },
      _simplifyPoints: function() {
        var parts = this._parts, tolerance = this.options.smoothFactor;
        for (var i = 0, len = parts.length; i < len; i++) {
          parts[i] = simplify(parts[i], tolerance);
        }
      },
      _update: function() {
        if (!this._map) {
          return;
        }
        this._clipPoints();
        this._simplifyPoints();
        this._updatePath();
      },
      _updatePath: function() {
        this._renderer._updatePoly(this);
      },
      _containsPoint: function(p2, closed) {
        var i, j, k, len, len2, part, w = this._clickTolerance();
        if (!this._pxBounds || !this._pxBounds.contains(p2)) {
          return false;
        }
        for (i = 0, len = this._parts.length; i < len; i++) {
          part = this._parts[i];
          for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
            if (!closed && j === 0) {
              continue;
            }
            if (pointToSegmentDistance(p2, part[k], part[j]) <= w) {
              return true;
            }
          }
        }
        return false;
      }
    });
    function polyline(latlngs, options) {
      return new Polyline(latlngs, options);
    }
    Polyline._flat = _flat;
    var Polygon = Polyline.extend({
      options: {
        fill: true
      },
      isEmpty: function() {
        return !this._latlngs.length || !this._latlngs[0].length;
      },
      getCenter: function() {
        if (!this._map) {
          throw new Error("Must add layer to map before using getCenter()");
        }
        var i, j, p1, p2, f, area, x, y, center, points = this._rings[0], len = points.length;
        if (!len) {
          return null;
        }
        area = x = y = 0;
        for (i = 0, j = len - 1; i < len; j = i++) {
          p1 = points[i];
          p2 = points[j];
          f = p1.y * p2.x - p2.y * p1.x;
          x += (p1.x + p2.x) * f;
          y += (p1.y + p2.y) * f;
          area += f * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x / area, y / area];
        }
        return this._map.layerPointToLatLng(center);
      },
      _convertLatLngs: function(latlngs) {
        var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
        if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
          result.pop();
        }
        return result;
      },
      _setLatLngs: function(latlngs) {
        Polyline.prototype._setLatLngs.call(this, latlngs);
        if (isFlat(this._latlngs)) {
          this._latlngs = [this._latlngs];
        }
      },
      _defaultShape: function() {
        return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
      },
      _clipPoints: function() {
        var bounds = this._renderer._bounds, w = this.options.weight, p2 = new Point(w, w);
        bounds = new Bounds(bounds.min.subtract(p2), bounds.max.add(p2));
        this._parts = [];
        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }
        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }
        for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
          clipped = clipPolygon(this._rings[i], bounds, true);
          if (clipped.length) {
            this._parts.push(clipped);
          }
        }
      },
      _updatePath: function() {
        this._renderer._updatePoly(this, true);
      },
      _containsPoint: function(p2) {
        var inside = false, part, p1, p22, i, j, k, len, len2;
        if (!this._pxBounds || !this._pxBounds.contains(p2)) {
          return false;
        }
        for (i = 0, len = this._parts.length; i < len; i++) {
          part = this._parts[i];
          for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
            p1 = part[j];
            p22 = part[k];
            if (p1.y > p2.y !== p22.y > p2.y && p2.x < (p22.x - p1.x) * (p2.y - p1.y) / (p22.y - p1.y) + p1.x) {
              inside = !inside;
            }
          }
        }
        return inside || Polyline.prototype._containsPoint.call(this, p2, true);
      }
    });
    function polygon(latlngs, options) {
      return new Polygon(latlngs, options);
    }
    var GeoJSON = FeatureGroup.extend({
      initialize: function(geojson, options) {
        setOptions(this, options);
        this._layers = {};
        if (geojson) {
          this.addData(geojson);
        }
      },
      addData: function(geojson) {
        var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
        if (features) {
          for (i = 0, len = features.length; i < len; i++) {
            feature = features[i];
            if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
              this.addData(feature);
            }
          }
          return this;
        }
        var options = this.options;
        if (options.filter && !options.filter(geojson)) {
          return this;
        }
        var layer = geometryToLayer(geojson, options);
        if (!layer) {
          return this;
        }
        layer.feature = asFeature(geojson);
        layer.defaultOptions = layer.options;
        this.resetStyle(layer);
        if (options.onEachFeature) {
          options.onEachFeature(geojson, layer);
        }
        return this.addLayer(layer);
      },
      resetStyle: function(layer) {
        if (layer === void 0) {
          return this.eachLayer(this.resetStyle, this);
        }
        layer.options = extend({}, layer.defaultOptions);
        this._setLayerStyle(layer, this.options.style);
        return this;
      },
      setStyle: function(style) {
        return this.eachLayer(function(layer) {
          this._setLayerStyle(layer, style);
        }, this);
      },
      _setLayerStyle: function(layer, style) {
        if (layer.setStyle) {
          if (typeof style === "function") {
            style = style(layer.feature);
          }
          layer.setStyle(style);
        }
      }
    });
    function geometryToLayer(geojson, options) {
      var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
      if (!coords && !geometry) {
        return null;
      }
      switch (geometry.type) {
        case "Point":
          latlng = _coordsToLatLng(coords);
          return _pointToLayer(pointToLayer, geojson, latlng, options);
        case "MultiPoint":
          for (i = 0, len = coords.length; i < len; i++) {
            latlng = _coordsToLatLng(coords[i]);
            layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
          }
          return new FeatureGroup(layers2);
        case "LineString":
        case "MultiLineString":
          latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
          return new Polyline(latlngs, options);
        case "Polygon":
        case "MultiPolygon":
          latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
          return new Polygon(latlngs, options);
        case "GeometryCollection":
          for (i = 0, len = geometry.geometries.length; i < len; i++) {
            var layer = geometryToLayer({
              geometry: geometry.geometries[i],
              type: "Feature",
              properties: geojson.properties
            }, options);
            if (layer) {
              layers2.push(layer);
            }
          }
          return new FeatureGroup(layers2);
        default:
          throw new Error("Invalid GeoJSON object.");
      }
    }
    function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
      return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
    }
    function coordsToLatLng(coords) {
      return new LatLng(coords[1], coords[0], coords[2]);
    }
    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
      var latlngs = [];
      for (var i = 0, len = coords.length, latlng; i < len; i++) {
        latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
        latlngs.push(latlng);
      }
      return latlngs;
    }
    function latLngToCoords(latlng, precision) {
      precision = typeof precision === "number" ? precision : 6;
      return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
    }
    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
      var coords = [];
      for (var i = 0, len = latlngs.length; i < len; i++) {
        coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
      }
      if (!levelsDeep && closed) {
        coords.push(coords[0]);
      }
      return coords;
    }
    function getFeature(layer, newGeometry) {
      return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
    }
    function asFeature(geojson) {
      if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
        return geojson;
      }
      return {
        type: "Feature",
        properties: {},
        geometry: geojson
      };
    }
    var PointToGeoJSON = {
      toGeoJSON: function(precision) {
        return getFeature(this, {
          type: "Point",
          coordinates: latLngToCoords(this.getLatLng(), precision)
        });
      }
    };
    Marker.include(PointToGeoJSON);
    Circle.include(PointToGeoJSON);
    CircleMarker.include(PointToGeoJSON);
    Polyline.include({
      toGeoJSON: function(precision) {
        var multi = !isFlat(this._latlngs);
        var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
        return getFeature(this, {
          type: (multi ? "Multi" : "") + "LineString",
          coordinates: coords
        });
      }
    });
    Polygon.include({
      toGeoJSON: function(precision) {
        var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
        var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
        if (!holes) {
          coords = [coords];
        }
        return getFeature(this, {
          type: (multi ? "Multi" : "") + "Polygon",
          coordinates: coords
        });
      }
    });
    LayerGroup.include({
      toMultiPoint: function(precision) {
        var coords = [];
        this.eachLayer(function(layer) {
          coords.push(layer.toGeoJSON(precision).geometry.coordinates);
        });
        return getFeature(this, {
          type: "MultiPoint",
          coordinates: coords
        });
      },
      toGeoJSON: function(precision) {
        var type2 = this.feature && this.feature.geometry && this.feature.geometry.type;
        if (type2 === "MultiPoint") {
          return this.toMultiPoint(precision);
        }
        var isGeometryCollection = type2 === "GeometryCollection", jsons = [];
        this.eachLayer(function(layer) {
          if (layer.toGeoJSON) {
            var json = layer.toGeoJSON(precision);
            if (isGeometryCollection) {
              jsons.push(json.geometry);
            } else {
              var feature = asFeature(json);
              if (feature.type === "FeatureCollection") {
                jsons.push.apply(jsons, feature.features);
              } else {
                jsons.push(feature);
              }
            }
          }
        });
        if (isGeometryCollection) {
          return getFeature(this, {
            geometries: jsons,
            type: "GeometryCollection"
          });
        }
        return {
          type: "FeatureCollection",
          features: jsons
        };
      }
    });
    function geoJSON(geojson, options) {
      return new GeoJSON(geojson, options);
    }
    var geoJson = geoJSON;
    var ImageOverlay = Layer.extend({
      options: {
        opacity: 1,
        alt: "",
        interactive: false,
        crossOrigin: false,
        errorOverlayUrl: "",
        zIndex: 1,
        className: ""
      },
      initialize: function(url, bounds, options) {
        this._url = url;
        this._bounds = toLatLngBounds(bounds);
        setOptions(this, options);
      },
      onAdd: function() {
        if (!this._image) {
          this._initImage();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
        }
        if (this.options.interactive) {
          addClass(this._image, "leaflet-interactive");
          this.addInteractiveTarget(this._image);
        }
        this.getPane().appendChild(this._image);
        this._reset();
      },
      onRemove: function() {
        remove(this._image);
        if (this.options.interactive) {
          this.removeInteractiveTarget(this._image);
        }
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._image) {
          this._updateOpacity();
        }
        return this;
      },
      setStyle: function(styleOpts) {
        if (styleOpts.opacity) {
          this.setOpacity(styleOpts.opacity);
        }
        return this;
      },
      bringToFront: function() {
        if (this._map) {
          toFront(this._image);
        }
        return this;
      },
      bringToBack: function() {
        if (this._map) {
          toBack(this._image);
        }
        return this;
      },
      setUrl: function(url) {
        this._url = url;
        if (this._image) {
          this._image.src = url;
        }
        return this;
      },
      setBounds: function(bounds) {
        this._bounds = toLatLngBounds(bounds);
        if (this._map) {
          this._reset();
        }
        return this;
      },
      getEvents: function() {
        var events2 = {
          zoom: this._reset,
          viewreset: this._reset
        };
        if (this._zoomAnimated) {
          events2.zoomanim = this._animateZoom;
        }
        return events2;
      },
      setZIndex: function(value) {
        this.options.zIndex = value;
        this._updateZIndex();
        return this;
      },
      getBounds: function() {
        return this._bounds;
      },
      getElement: function() {
        return this._image;
      },
      _initImage: function() {
        var wasElementSupplied = this._url.tagName === "IMG";
        var img = this._image = wasElementSupplied ? this._url : create$1("img");
        addClass(img, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(img, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(img, this.options.className);
        }
        img.onselectstart = falseFn;
        img.onmousemove = falseFn;
        img.onload = bind2(this.fire, this, "load");
        img.onerror = bind2(this._overlayOnError, this, "error");
        if (this.options.crossOrigin || this.options.crossOrigin === "") {
          img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
        }
        if (this.options.zIndex) {
          this._updateZIndex();
        }
        if (wasElementSupplied) {
          this._url = img.src;
          return;
        }
        img.src = this._url;
        img.alt = this.options.alt;
      },
      _animateZoom: function(e) {
        var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
        setTransform(this._image, offset, scale2);
      },
      _reset: function() {
        var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
        setPosition(image, bounds.min);
        image.style.width = size.x + "px";
        image.style.height = size.y + "px";
      },
      _updateOpacity: function() {
        setOpacity(this._image, this.options.opacity);
      },
      _updateZIndex: function() {
        if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
          this._image.style.zIndex = this.options.zIndex;
        }
      },
      _overlayOnError: function() {
        this.fire("error");
        var errorUrl = this.options.errorOverlayUrl;
        if (errorUrl && this._url !== errorUrl) {
          this._url = errorUrl;
          this._image.src = errorUrl;
        }
      }
    });
    var imageOverlay = function(url, bounds, options) {
      return new ImageOverlay(url, bounds, options);
    };
    var VideoOverlay = ImageOverlay.extend({
      options: {
        autoplay: true,
        loop: true,
        keepAspectRatio: true,
        muted: false
      },
      _initImage: function() {
        var wasElementSupplied = this._url.tagName === "VIDEO";
        var vid = this._image = wasElementSupplied ? this._url : create$1("video");
        addClass(vid, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(vid, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(vid, this.options.className);
        }
        vid.onselectstart = falseFn;
        vid.onmousemove = falseFn;
        vid.onloadeddata = bind2(this.fire, this, "load");
        if (wasElementSupplied) {
          var sourceElements = vid.getElementsByTagName("source");
          var sources = [];
          for (var j = 0; j < sourceElements.length; j++) {
            sources.push(sourceElements[j].src);
          }
          this._url = sourceElements.length > 0 ? sources : [vid.src];
          return;
        }
        if (!isArray(this._url)) {
          this._url = [this._url];
        }
        if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
          vid.style["objectFit"] = "fill";
        }
        vid.autoplay = !!this.options.autoplay;
        vid.loop = !!this.options.loop;
        vid.muted = !!this.options.muted;
        for (var i = 0; i < this._url.length; i++) {
          var source = create$1("source");
          source.src = this._url[i];
          vid.appendChild(source);
        }
      }
    });
    function videoOverlay(video, bounds, options) {
      return new VideoOverlay(video, bounds, options);
    }
    var SVGOverlay = ImageOverlay.extend({
      _initImage: function() {
        var el = this._image = this._url;
        addClass(el, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(el, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(el, this.options.className);
        }
        el.onselectstart = falseFn;
        el.onmousemove = falseFn;
      }
    });
    function svgOverlay(el, bounds, options) {
      return new SVGOverlay(el, bounds, options);
    }
    var DivOverlay = Layer.extend({
      options: {
        offset: [0, 7],
        className: "",
        pane: "popupPane"
      },
      initialize: function(options, source) {
        setOptions(this, options);
        this._source = source;
      },
      onAdd: function(map) {
        this._zoomAnimated = map._zoomAnimated;
        if (!this._container) {
          this._initLayout();
        }
        if (map._fadeAnimated) {
          setOpacity(this._container, 0);
        }
        clearTimeout(this._removeTimeout);
        this.getPane().appendChild(this._container);
        this.update();
        if (map._fadeAnimated) {
          setOpacity(this._container, 1);
        }
        this.bringToFront();
      },
      onRemove: function(map) {
        if (map._fadeAnimated) {
          setOpacity(this._container, 0);
          this._removeTimeout = setTimeout(bind2(remove, void 0, this._container), 200);
        } else {
          remove(this._container);
        }
      },
      getLatLng: function() {
        return this._latlng;
      },
      setLatLng: function(latlng) {
        this._latlng = toLatLng(latlng);
        if (this._map) {
          this._updatePosition();
          this._adjustPan();
        }
        return this;
      },
      getContent: function() {
        return this._content;
      },
      setContent: function(content) {
        this._content = content;
        this.update();
        return this;
      },
      getElement: function() {
        return this._container;
      },
      update: function() {
        if (!this._map) {
          return;
        }
        this._container.style.visibility = "hidden";
        this._updateContent();
        this._updateLayout();
        this._updatePosition();
        this._container.style.visibility = "";
        this._adjustPan();
      },
      getEvents: function() {
        var events2 = {
          zoom: this._updatePosition,
          viewreset: this._updatePosition
        };
        if (this._zoomAnimated) {
          events2.zoomanim = this._animateZoom;
        }
        return events2;
      },
      isOpen: function() {
        return !!this._map && this._map.hasLayer(this);
      },
      bringToFront: function() {
        if (this._map) {
          toFront(this._container);
        }
        return this;
      },
      bringToBack: function() {
        if (this._map) {
          toBack(this._container);
        }
        return this;
      },
      _prepareOpen: function(parent, layer, latlng) {
        if (!(layer instanceof Layer)) {
          latlng = layer;
          layer = parent;
        }
        if (layer instanceof FeatureGroup) {
          for (var id in parent._layers) {
            layer = parent._layers[id];
            break;
          }
        }
        if (!latlng) {
          if (layer.getCenter) {
            latlng = layer.getCenter();
          } else if (layer.getLatLng) {
            latlng = layer.getLatLng();
          } else {
            throw new Error("Unable to get source layer LatLng.");
          }
        }
        this._source = layer;
        this.update();
        return latlng;
      },
      _updateContent: function() {
        if (!this._content) {
          return;
        }
        var node = this._contentNode;
        var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
        if (typeof content === "string") {
          node.innerHTML = content;
        } else {
          while (node.hasChildNodes()) {
            node.removeChild(node.firstChild);
          }
          node.appendChild(content);
        }
        this.fire("contentupdate");
      },
      _updatePosition: function() {
        if (!this._map) {
          return;
        }
        var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
        if (this._zoomAnimated) {
          setPosition(this._container, pos.add(anchor));
        } else {
          offset = offset.add(pos).add(anchor);
        }
        var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
        this._container.style.bottom = bottom + "px";
        this._container.style.left = left + "px";
      },
      _getAnchor: function() {
        return [0, 0];
      }
    });
    var Popup = DivOverlay.extend({
      options: {
        maxWidth: 300,
        minWidth: 50,
        maxHeight: null,
        autoPan: true,
        autoPanPaddingTopLeft: null,
        autoPanPaddingBottomRight: null,
        autoPanPadding: [5, 5],
        keepInView: false,
        closeButton: true,
        autoClose: true,
        closeOnEscapeKey: true,
        className: ""
      },
      openOn: function(map) {
        map.openPopup(this);
        return this;
      },
      onAdd: function(map) {
        DivOverlay.prototype.onAdd.call(this, map);
        map.fire("popupopen", { popup: this });
        if (this._source) {
          this._source.fire("popupopen", { popup: this }, true);
          if (!(this._source instanceof Path)) {
            this._source.on("preclick", stopPropagation);
          }
        }
      },
      onRemove: function(map) {
        DivOverlay.prototype.onRemove.call(this, map);
        map.fire("popupclose", { popup: this });
        if (this._source) {
          this._source.fire("popupclose", { popup: this }, true);
          if (!(this._source instanceof Path)) {
            this._source.off("preclick", stopPropagation);
          }
        }
      },
      getEvents: function() {
        var events2 = DivOverlay.prototype.getEvents.call(this);
        if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
          events2.preclick = this._close;
        }
        if (this.options.keepInView) {
          events2.moveend = this._adjustPan;
        }
        return events2;
      },
      _close: function() {
        if (this._map) {
          this._map.closePopup(this);
        }
      },
      _initLayout: function() {
        var prefix = "leaflet-popup", container = this._container = create$1("div", prefix + " " + (this.options.className || "") + " leaflet-zoom-animated");
        var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
        this._contentNode = create$1("div", prefix + "-content", wrapper);
        disableClickPropagation(container);
        disableScrollPropagation(this._contentNode);
        on(container, "contextmenu", stopPropagation);
        this._tipContainer = create$1("div", prefix + "-tip-container", container);
        this._tip = create$1("div", prefix + "-tip", this._tipContainer);
        if (this.options.closeButton) {
          var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
          closeButton.href = "#close";
          closeButton.innerHTML = "&#215;";
          on(closeButton, "click", this._onCloseButtonClick, this);
        }
      },
      _updateLayout: function() {
        var container = this._contentNode, style = container.style;
        style.width = "";
        style.whiteSpace = "nowrap";
        var width = container.offsetWidth;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);
        style.width = width + 1 + "px";
        style.whiteSpace = "";
        style.height = "";
        var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
        if (maxHeight && height > maxHeight) {
          style.height = maxHeight + "px";
          addClass(container, scrolledClass);
        } else {
          removeClass(container, scrolledClass);
        }
        this._containerWidth = this._container.offsetWidth;
      },
      _animateZoom: function(e) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
        setPosition(this._container, pos.add(anchor));
      },
      _adjustPan: function() {
        if (!this.options.autoPan) {
          return;
        }
        if (this._map._panAnim) {
          this._map._panAnim.stop();
        }
        var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
        layerPos._add(getPosition(this._container));
        var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
        if (containerPos.x + containerWidth + paddingBR.x > size.x) {
          dx = containerPos.x + containerWidth - size.x + paddingBR.x;
        }
        if (containerPos.x - dx - paddingTL.x < 0) {
          dx = containerPos.x - paddingTL.x;
        }
        if (containerPos.y + containerHeight + paddingBR.y > size.y) {
          dy = containerPos.y + containerHeight - size.y + paddingBR.y;
        }
        if (containerPos.y - dy - paddingTL.y < 0) {
          dy = containerPos.y - paddingTL.y;
        }
        if (dx || dy) {
          map.fire("autopanstart").panBy([dx, dy]);
        }
      },
      _onCloseButtonClick: function(e) {
        this._close();
        stop(e);
      },
      _getAnchor: function() {
        return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
      }
    });
    var popup = function(options, source) {
      return new Popup(options, source);
    };
    Map2.mergeOptions({
      closePopupOnClick: true
    });
    Map2.include({
      openPopup: function(popup2, latlng, options) {
        if (!(popup2 instanceof Popup)) {
          popup2 = new Popup(options).setContent(popup2);
        }
        if (latlng) {
          popup2.setLatLng(latlng);
        }
        if (this.hasLayer(popup2)) {
          return this;
        }
        if (this._popup && this._popup.options.autoClose) {
          this.closePopup();
        }
        this._popup = popup2;
        return this.addLayer(popup2);
      },
      closePopup: function(popup2) {
        if (!popup2 || popup2 === this._popup) {
          popup2 = this._popup;
          this._popup = null;
        }
        if (popup2) {
          this.removeLayer(popup2);
        }
        return this;
      }
    });
    Layer.include({
      bindPopup: function(content, options) {
        if (content instanceof Popup) {
          setOptions(content, options);
          this._popup = content;
          content._source = this;
        } else {
          if (!this._popup || options) {
            this._popup = new Popup(options, this);
          }
          this._popup.setContent(content);
        }
        if (!this._popupHandlersAdded) {
          this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          });
          this._popupHandlersAdded = true;
        }
        return this;
      },
      unbindPopup: function() {
        if (this._popup) {
          this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          });
          this._popupHandlersAdded = false;
          this._popup = null;
        }
        return this;
      },
      openPopup: function(layer, latlng) {
        if (this._popup && this._map) {
          latlng = this._popup._prepareOpen(this, layer, latlng);
          this._map.openPopup(this._popup, latlng);
        }
        return this;
      },
      closePopup: function() {
        if (this._popup) {
          this._popup._close();
        }
        return this;
      },
      togglePopup: function(target) {
        if (this._popup) {
          if (this._popup._map) {
            this.closePopup();
          } else {
            this.openPopup(target);
          }
        }
        return this;
      },
      isPopupOpen: function() {
        return this._popup ? this._popup.isOpen() : false;
      },
      setPopupContent: function(content) {
        if (this._popup) {
          this._popup.setContent(content);
        }
        return this;
      },
      getPopup: function() {
        return this._popup;
      },
      _openPopup: function(e) {
        var layer = e.layer || e.target;
        if (!this._popup) {
          return;
        }
        if (!this._map) {
          return;
        }
        stop(e);
        if (layer instanceof Path) {
          this.openPopup(e.layer || e.target, e.latlng);
          return;
        }
        if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
          this.closePopup();
        } else {
          this.openPopup(layer, e.latlng);
        }
      },
      _movePopup: function(e) {
        this._popup.setLatLng(e.latlng);
      },
      _onKeyPress: function(e) {
        if (e.originalEvent.keyCode === 13) {
          this._openPopup(e);
        }
      }
    });
    var Tooltip = DivOverlay.extend({
      options: {
        pane: "tooltipPane",
        offset: [0, 0],
        direction: "auto",
        permanent: false,
        sticky: false,
        interactive: false,
        opacity: 0.9
      },
      onAdd: function(map) {
        DivOverlay.prototype.onAdd.call(this, map);
        this.setOpacity(this.options.opacity);
        map.fire("tooltipopen", { tooltip: this });
        if (this._source) {
          this._source.fire("tooltipopen", { tooltip: this }, true);
        }
      },
      onRemove: function(map) {
        DivOverlay.prototype.onRemove.call(this, map);
        map.fire("tooltipclose", { tooltip: this });
        if (this._source) {
          this._source.fire("tooltipclose", { tooltip: this }, true);
        }
      },
      getEvents: function() {
        var events2 = DivOverlay.prototype.getEvents.call(this);
        if (touch && !this.options.permanent) {
          events2.preclick = this._close;
        }
        return events2;
      },
      _close: function() {
        if (this._map) {
          this._map.closeTooltip(this);
        }
      },
      _initLayout: function() {
        var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        this._contentNode = this._container = create$1("div", className);
      },
      _updateLayout: function() {
      },
      _adjustPan: function() {
      },
      _setPosition: function(pos) {
        var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
        if (direction === "top") {
          subX = tooltipWidth / 2;
          subY = tooltipHeight;
        } else if (direction === "bottom") {
          subX = tooltipWidth / 2;
          subY = 0;
        } else if (direction === "center") {
          subX = tooltipWidth / 2;
          subY = tooltipHeight / 2;
        } else if (direction === "right") {
          subX = 0;
          subY = tooltipHeight / 2;
        } else if (direction === "left") {
          subX = tooltipWidth;
          subY = tooltipHeight / 2;
        } else if (tooltipPoint.x < centerPoint.x) {
          direction = "right";
          subX = 0;
          subY = tooltipHeight / 2;
        } else {
          direction = "left";
          subX = tooltipWidth + (offset.x + anchor.x) * 2;
          subY = tooltipHeight / 2;
        }
        pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
        removeClass(container, "leaflet-tooltip-right");
        removeClass(container, "leaflet-tooltip-left");
        removeClass(container, "leaflet-tooltip-top");
        removeClass(container, "leaflet-tooltip-bottom");
        addClass(container, "leaflet-tooltip-" + direction);
        setPosition(container, pos);
      },
      _updatePosition: function() {
        var pos = this._map.latLngToLayerPoint(this._latlng);
        this._setPosition(pos);
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._container) {
          setOpacity(this._container, opacity);
        }
      },
      _animateZoom: function(e) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
        this._setPosition(pos);
      },
      _getAnchor: function() {
        return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
      }
    });
    var tooltip = function(options, source) {
      return new Tooltip(options, source);
    };
    Map2.include({
      openTooltip: function(tooltip2, latlng, options) {
        if (!(tooltip2 instanceof Tooltip)) {
          tooltip2 = new Tooltip(options).setContent(tooltip2);
        }
        if (latlng) {
          tooltip2.setLatLng(latlng);
        }
        if (this.hasLayer(tooltip2)) {
          return this;
        }
        return this.addLayer(tooltip2);
      },
      closeTooltip: function(tooltip2) {
        if (tooltip2) {
          this.removeLayer(tooltip2);
        }
        return this;
      }
    });
    Layer.include({
      bindTooltip: function(content, options) {
        if (content instanceof Tooltip) {
          setOptions(content, options);
          this._tooltip = content;
          content._source = this;
        } else {
          if (!this._tooltip || options) {
            this._tooltip = new Tooltip(options, this);
          }
          this._tooltip.setContent(content);
        }
        this._initTooltipInteractions();
        if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
          this.openTooltip();
        }
        return this;
      },
      unbindTooltip: function() {
        if (this._tooltip) {
          this._initTooltipInteractions(true);
          this.closeTooltip();
          this._tooltip = null;
        }
        return this;
      },
      _initTooltipInteractions: function(remove$$1) {
        if (!remove$$1 && this._tooltipHandlersAdded) {
          return;
        }
        var onOff = remove$$1 ? "off" : "on", events2 = {
          remove: this.closeTooltip,
          move: this._moveTooltip
        };
        if (!this._tooltip.options.permanent) {
          events2.mouseover = this._openTooltip;
          events2.mouseout = this.closeTooltip;
          if (this._tooltip.options.sticky) {
            events2.mousemove = this._moveTooltip;
          }
          if (touch) {
            events2.click = this._openTooltip;
          }
        } else {
          events2.add = this._openTooltip;
        }
        this[onOff](events2);
        this._tooltipHandlersAdded = !remove$$1;
      },
      openTooltip: function(layer, latlng) {
        if (this._tooltip && this._map) {
          latlng = this._tooltip._prepareOpen(this, layer, latlng);
          this._map.openTooltip(this._tooltip, latlng);
          if (this._tooltip.options.interactive && this._tooltip._container) {
            addClass(this._tooltip._container, "leaflet-clickable");
            this.addInteractiveTarget(this._tooltip._container);
          }
        }
        return this;
      },
      closeTooltip: function() {
        if (this._tooltip) {
          this._tooltip._close();
          if (this._tooltip.options.interactive && this._tooltip._container) {
            removeClass(this._tooltip._container, "leaflet-clickable");
            this.removeInteractiveTarget(this._tooltip._container);
          }
        }
        return this;
      },
      toggleTooltip: function(target) {
        if (this._tooltip) {
          if (this._tooltip._map) {
            this.closeTooltip();
          } else {
            this.openTooltip(target);
          }
        }
        return this;
      },
      isTooltipOpen: function() {
        return this._tooltip.isOpen();
      },
      setTooltipContent: function(content) {
        if (this._tooltip) {
          this._tooltip.setContent(content);
        }
        return this;
      },
      getTooltip: function() {
        return this._tooltip;
      },
      _openTooltip: function(e) {
        var layer = e.layer || e.target;
        if (!this._tooltip || !this._map) {
          return;
        }
        this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : void 0);
      },
      _moveTooltip: function(e) {
        var latlng = e.latlng, containerPoint, layerPoint;
        if (this._tooltip.options.sticky && e.originalEvent) {
          containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
          layerPoint = this._map.containerPointToLayerPoint(containerPoint);
          latlng = this._map.layerPointToLatLng(layerPoint);
        }
        this._tooltip.setLatLng(latlng);
      }
    });
    var DivIcon = Icon.extend({
      options: {
        iconSize: [12, 12],
        html: false,
        bgPos: null,
        className: "leaflet-div-icon"
      },
      createIcon: function(oldIcon) {
        var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
        if (options.html instanceof Element) {
          empty2(div);
          div.appendChild(options.html);
        } else {
          div.innerHTML = options.html !== false ? options.html : "";
        }
        if (options.bgPos) {
          var bgPos = toPoint(options.bgPos);
          div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
        }
        this._setIconStyles(div, "icon");
        return div;
      },
      createShadow: function() {
        return null;
      }
    });
    function divIcon(options) {
      return new DivIcon(options);
    }
    Icon.Default = IconDefault;
    var GridLayer = Layer.extend({
      options: {
        tileSize: 256,
        opacity: 1,
        updateWhenIdle: mobile,
        updateWhenZooming: true,
        updateInterval: 200,
        zIndex: 1,
        bounds: null,
        minZoom: 0,
        maxZoom: void 0,
        maxNativeZoom: void 0,
        minNativeZoom: void 0,
        noWrap: false,
        pane: "tilePane",
        className: "",
        keepBuffer: 2
      },
      initialize: function(options) {
        setOptions(this, options);
      },
      onAdd: function() {
        this._initContainer();
        this._levels = {};
        this._tiles = {};
        this._resetView();
        this._update();
      },
      beforeAdd: function(map) {
        map._addZoomLimit(this);
      },
      onRemove: function(map) {
        this._removeAllTiles();
        remove(this._container);
        map._removeZoomLimit(this);
        this._container = null;
        this._tileZoom = void 0;
      },
      bringToFront: function() {
        if (this._map) {
          toFront(this._container);
          this._setAutoZIndex(Math.max);
        }
        return this;
      },
      bringToBack: function() {
        if (this._map) {
          toBack(this._container);
          this._setAutoZIndex(Math.min);
        }
        return this;
      },
      getContainer: function() {
        return this._container;
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        this._updateOpacity();
        return this;
      },
      setZIndex: function(zIndex) {
        this.options.zIndex = zIndex;
        this._updateZIndex();
        return this;
      },
      isLoading: function() {
        return this._loading;
      },
      redraw: function() {
        if (this._map) {
          this._removeAllTiles();
          this._update();
        }
        return this;
      },
      getEvents: function() {
        var events2 = {
          viewprereset: this._invalidateAll,
          viewreset: this._resetView,
          zoom: this._resetView,
          moveend: this._onMoveEnd
        };
        if (!this.options.updateWhenIdle) {
          if (!this._onMove) {
            this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
          }
          events2.move = this._onMove;
        }
        if (this._zoomAnimated) {
          events2.zoomanim = this._animateZoom;
        }
        return events2;
      },
      createTile: function() {
        return document.createElement("div");
      },
      getTileSize: function() {
        var s = this.options.tileSize;
        return s instanceof Point ? s : new Point(s, s);
      },
      _updateZIndex: function() {
        if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
          this._container.style.zIndex = this.options.zIndex;
        }
      },
      _setAutoZIndex: function(compare) {
        var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
        for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
          zIndex = layers2[i].style.zIndex;
          if (layers2[i] !== this._container && zIndex) {
            edgeZIndex = compare(edgeZIndex, +zIndex);
          }
        }
        if (isFinite(edgeZIndex)) {
          this.options.zIndex = edgeZIndex + compare(-1, 1);
          this._updateZIndex();
        }
      },
      _updateOpacity: function() {
        if (!this._map) {
          return;
        }
        if (ielt9) {
          return;
        }
        setOpacity(this._container, this.options.opacity);
        var now2 = +new Date(), nextFrame = false, willPrune = false;
        for (var key in this._tiles) {
          var tile = this._tiles[key];
          if (!tile.current || !tile.loaded) {
            continue;
          }
          var fade2 = Math.min(1, (now2 - tile.loaded) / 200);
          setOpacity(tile.el, fade2);
          if (fade2 < 1) {
            nextFrame = true;
          } else {
            if (tile.active) {
              willPrune = true;
            } else {
              this._onOpaqueTile(tile);
            }
            tile.active = true;
          }
        }
        if (willPrune && !this._noPrune) {
          this._pruneTiles();
        }
        if (nextFrame) {
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        }
      },
      _onOpaqueTile: falseFn,
      _initContainer: function() {
        if (this._container) {
          return;
        }
        this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
        this._updateZIndex();
        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
        this.getPane().appendChild(this._container);
      },
      _updateLevels: function() {
        var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
        if (zoom2 === void 0) {
          return void 0;
        }
        for (var z in this._levels) {
          z = Number(z);
          if (this._levels[z].el.children.length || z === zoom2) {
            this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
            this._onUpdateLevel(z);
          } else {
            remove(this._levels[z].el);
            this._removeTilesAtZoom(z);
            this._onRemoveLevel(z);
            delete this._levels[z];
          }
        }
        var level = this._levels[zoom2], map = this._map;
        if (!level) {
          level = this._levels[zoom2] = {};
          level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
          level.el.style.zIndex = maxZoom;
          level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
          level.zoom = zoom2;
          this._setZoomTransform(level, map.getCenter(), map.getZoom());
          falseFn(level.el.offsetWidth);
          this._onCreateLevel(level);
        }
        this._level = level;
        return level;
      },
      _onUpdateLevel: falseFn,
      _onRemoveLevel: falseFn,
      _onCreateLevel: falseFn,
      _pruneTiles: function() {
        if (!this._map) {
          return;
        }
        var key, tile;
        var zoom2 = this._map.getZoom();
        if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
          this._removeAllTiles();
          return;
        }
        for (key in this._tiles) {
          tile = this._tiles[key];
          tile.retain = tile.current;
        }
        for (key in this._tiles) {
          tile = this._tiles[key];
          if (tile.current && !tile.active) {
            var coords = tile.coords;
            if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
              this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
            }
          }
        }
        for (key in this._tiles) {
          if (!this._tiles[key].retain) {
            this._removeTile(key);
          }
        }
      },
      _removeTilesAtZoom: function(zoom2) {
        for (var key in this._tiles) {
          if (this._tiles[key].coords.z !== zoom2) {
            continue;
          }
          this._removeTile(key);
        }
      },
      _removeAllTiles: function() {
        for (var key in this._tiles) {
          this._removeTile(key);
        }
      },
      _invalidateAll: function() {
        for (var z in this._levels) {
          remove(this._levels[z].el);
          this._onRemoveLevel(Number(z));
          delete this._levels[z];
        }
        this._removeAllTiles();
        this._tileZoom = void 0;
      },
      _retainParent: function(x, y, z, minZoom) {
        var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
        coords2.z = +z2;
        var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
        if (tile && tile.active) {
          tile.retain = true;
          return true;
        } else if (tile && tile.loaded) {
          tile.retain = true;
        }
        if (z2 > minZoom) {
          return this._retainParent(x2, y2, z2, minZoom);
        }
        return false;
      },
      _retainChildren: function(x, y, z, maxZoom) {
        for (var i = 2 * x; i < 2 * x + 2; i++) {
          for (var j = 2 * y; j < 2 * y + 2; j++) {
            var coords = new Point(i, j);
            coords.z = z + 1;
            var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              continue;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z + 1 < maxZoom) {
              this._retainChildren(i, j, z + 1, maxZoom);
            }
          }
        }
      },
      _resetView: function(e) {
        var animating = e && (e.pinch || e.flyTo);
        this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
      },
      _animateZoom: function(e) {
        this._setView(e.center, e.zoom, true, e.noUpdate);
      },
      _clampZoom: function(zoom2) {
        var options = this.options;
        if (options.minNativeZoom !== void 0 && zoom2 < options.minNativeZoom) {
          return options.minNativeZoom;
        }
        if (options.maxNativeZoom !== void 0 && options.maxNativeZoom < zoom2) {
          return options.maxNativeZoom;
        }
        return zoom2;
      },
      _setView: function(center, zoom2, noPrune, noUpdate) {
        var tileZoom = Math.round(zoom2);
        if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
          tileZoom = void 0;
        } else {
          tileZoom = this._clampZoom(tileZoom);
        }
        var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
        if (!noUpdate || tileZoomChanged) {
          this._tileZoom = tileZoom;
          if (this._abortLoading) {
            this._abortLoading();
          }
          this._updateLevels();
          this._resetGrid();
          if (tileZoom !== void 0) {
            this._update(center);
          }
          if (!noPrune) {
            this._pruneTiles();
          }
          this._noPrune = !!noPrune;
        }
        this._setZoomTransforms(center, zoom2);
      },
      _setZoomTransforms: function(center, zoom2) {
        for (var i in this._levels) {
          this._setZoomTransform(this._levels[i], center, zoom2);
        }
      },
      _setZoomTransform: function(level, center, zoom2) {
        var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
        if (any3d) {
          setTransform(level.el, translate, scale2);
        } else {
          setPosition(level.el, translate);
        }
      },
      _resetGrid: function() {
        var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
        var bounds = this._map.getPixelWorldBounds(this._tileZoom);
        if (bounds) {
          this._globalTileRange = this._pxBoundsToTileRange(bounds);
        }
        this._wrapX = crs.wrapLng && !this.options.noWrap && [
          Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
          Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
        ];
        this._wrapY = crs.wrapLat && !this.options.noWrap && [
          Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
          Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
        ];
      },
      _onMoveEnd: function() {
        if (!this._map || this._map._animatingZoom) {
          return;
        }
        this._update();
      },
      _getTiledPixelBounds: function(center) {
        var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale2 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale2 * 2);
        return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
      },
      _update: function(center) {
        var map = this._map;
        if (!map) {
          return;
        }
        var zoom2 = this._clampZoom(map.getZoom());
        if (center === void 0) {
          center = map.getCenter();
        }
        if (this._tileZoom === void 0) {
          return;
        }
        var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));
        if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
          throw new Error("Attempted to load an infinite number of tiles");
        }
        for (var key in this._tiles) {
          var c = this._tiles[key].coords;
          if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
            this._tiles[key].current = false;
          }
        }
        if (Math.abs(zoom2 - this._tileZoom) > 1) {
          this._setView(center, zoom2);
          return;
        }
        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
          for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
            var coords = new Point(i, j);
            coords.z = this._tileZoom;
            if (!this._isValidTile(coords)) {
              continue;
            }
            var tile = this._tiles[this._tileCoordsToKey(coords)];
            if (tile) {
              tile.current = true;
            } else {
              queue.push(coords);
            }
          }
        }
        queue.sort(function(a, b) {
          return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
        });
        if (queue.length !== 0) {
          if (!this._loading) {
            this._loading = true;
            this.fire("loading");
          }
          var fragment = document.createDocumentFragment();
          for (i = 0; i < queue.length; i++) {
            this._addTile(queue[i], fragment);
          }
          this._level.el.appendChild(fragment);
        }
      },
      _isValidTile: function(coords) {
        var crs = this._map.options.crs;
        if (!crs.infinite) {
          var bounds = this._globalTileRange;
          if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
            return false;
          }
        }
        if (!this.options.bounds) {
          return true;
        }
        var tileBounds = this._tileCoordsToBounds(coords);
        return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
      },
      _keyToBounds: function(key) {
        return this._tileCoordsToBounds(this._keyToTileCoords(key));
      },
      _tileCoordsToNwSe: function(coords) {
        var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
        return [nw, se];
      },
      _tileCoordsToBounds: function(coords) {
        var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
        if (!this.options.noWrap) {
          bounds = this._map.wrapLatLngBounds(bounds);
        }
        return bounds;
      },
      _tileCoordsToKey: function(coords) {
        return coords.x + ":" + coords.y + ":" + coords.z;
      },
      _keyToTileCoords: function(key) {
        var k = key.split(":"), coords = new Point(+k[0], +k[1]);
        coords.z = +k[2];
        return coords;
      },
      _removeTile: function(key) {
        var tile = this._tiles[key];
        if (!tile) {
          return;
        }
        remove(tile.el);
        delete this._tiles[key];
        this.fire("tileunload", {
          tile: tile.el,
          coords: this._keyToTileCoords(key)
        });
      },
      _initTile: function(tile) {
        addClass(tile, "leaflet-tile");
        var tileSize = this.getTileSize();
        tile.style.width = tileSize.x + "px";
        tile.style.height = tileSize.y + "px";
        tile.onselectstart = falseFn;
        tile.onmousemove = falseFn;
        if (ielt9 && this.options.opacity < 1) {
          setOpacity(tile, this.options.opacity);
        }
        if (android && !android23) {
          tile.style.WebkitBackfaceVisibility = "hidden";
        }
      },
      _addTile: function(coords, container) {
        var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
        var tile = this.createTile(this._wrapCoords(coords), bind2(this._tileReady, this, coords));
        this._initTile(tile);
        if (this.createTile.length < 2) {
          requestAnimFrame(bind2(this._tileReady, this, coords, null, tile));
        }
        setPosition(tile, tilePos);
        this._tiles[key] = {
          el: tile,
          coords,
          current: true
        };
        container.appendChild(tile);
        this.fire("tileloadstart", {
          tile,
          coords
        });
      },
      _tileReady: function(coords, err, tile) {
        if (err) {
          this.fire("tileerror", {
            error: err,
            tile,
            coords
          });
        }
        var key = this._tileCoordsToKey(coords);
        tile = this._tiles[key];
        if (!tile) {
          return;
        }
        tile.loaded = +new Date();
        if (this._map._fadeAnimated) {
          setOpacity(tile.el, 0);
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        } else {
          tile.active = true;
          this._pruneTiles();
        }
        if (!err) {
          addClass(tile.el, "leaflet-tile-loaded");
          this.fire("tileload", {
            tile: tile.el,
            coords
          });
        }
        if (this._noTilesToLoad()) {
          this._loading = false;
          this.fire("load");
          if (ielt9 || !this._map._fadeAnimated) {
            requestAnimFrame(this._pruneTiles, this);
          } else {
            setTimeout(bind2(this._pruneTiles, this), 250);
          }
        }
      },
      _getTilePos: function(coords) {
        return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
      },
      _wrapCoords: function(coords) {
        var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
        newCoords.z = coords.z;
        return newCoords;
      },
      _pxBoundsToTileRange: function(bounds) {
        var tileSize = this.getTileSize();
        return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
      },
      _noTilesToLoad: function() {
        for (var key in this._tiles) {
          if (!this._tiles[key].loaded) {
            return false;
          }
        }
        return true;
      }
    });
    function gridLayer(options) {
      return new GridLayer(options);
    }
    var TileLayer = GridLayer.extend({
      options: {
        minZoom: 0,
        maxZoom: 18,
        subdomains: "abc",
        errorTileUrl: "",
        zoomOffset: 0,
        tms: false,
        zoomReverse: false,
        detectRetina: false,
        crossOrigin: false
      },
      initialize: function(url, options) {
        this._url = url;
        options = setOptions(this, options);
        if (options.detectRetina && retina && options.maxZoom > 0) {
          options.tileSize = Math.floor(options.tileSize / 2);
          if (!options.zoomReverse) {
            options.zoomOffset++;
            options.maxZoom--;
          } else {
            options.zoomOffset--;
            options.minZoom++;
          }
          options.minZoom = Math.max(0, options.minZoom);
        }
        if (typeof options.subdomains === "string") {
          options.subdomains = options.subdomains.split("");
        }
        if (!android) {
          this.on("tileunload", this._onTileRemove);
        }
      },
      setUrl: function(url, noRedraw) {
        if (this._url === url && noRedraw === void 0) {
          noRedraw = true;
        }
        this._url = url;
        if (!noRedraw) {
          this.redraw();
        }
        return this;
      },
      createTile: function(coords, done) {
        var tile = document.createElement("img");
        on(tile, "load", bind2(this._tileOnLoad, this, done, tile));
        on(tile, "error", bind2(this._tileOnError, this, done, tile));
        if (this.options.crossOrigin || this.options.crossOrigin === "") {
          tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
        }
        tile.alt = "";
        tile.setAttribute("role", "presentation");
        tile.src = this.getTileUrl(coords);
        return tile;
      },
      getTileUrl: function(coords) {
        var data = {
          r: retina ? "@2x" : "",
          s: this._getSubdomain(coords),
          x: coords.x,
          y: coords.y,
          z: this._getZoomForUrl()
        };
        if (this._map && !this._map.options.crs.infinite) {
          var invertedY = this._globalTileRange.max.y - coords.y;
          if (this.options.tms) {
            data["y"] = invertedY;
          }
          data["-y"] = invertedY;
        }
        return template(this._url, extend(data, this.options));
      },
      _tileOnLoad: function(done, tile) {
        if (ielt9) {
          setTimeout(bind2(done, this, null, tile), 0);
        } else {
          done(null, tile);
        }
      },
      _tileOnError: function(done, tile, e) {
        var errorUrl = this.options.errorTileUrl;
        if (errorUrl && tile.getAttribute("src") !== errorUrl) {
          tile.src = errorUrl;
        }
        done(e, tile);
      },
      _onTileRemove: function(e) {
        e.tile.onload = null;
      },
      _getZoomForUrl: function() {
        var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
        if (zoomReverse) {
          zoom2 = maxZoom - zoom2;
        }
        return zoom2 + zoomOffset;
      },
      _getSubdomain: function(tilePoint) {
        var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
        return this.options.subdomains[index2];
      },
      _abortLoading: function() {
        var i, tile;
        for (i in this._tiles) {
          if (this._tiles[i].coords.z !== this._tileZoom) {
            tile = this._tiles[i].el;
            tile.onload = falseFn;
            tile.onerror = falseFn;
            if (!tile.complete) {
              tile.src = emptyImageUrl;
              remove(tile);
              delete this._tiles[i];
            }
          }
        }
      },
      _removeTile: function(key) {
        var tile = this._tiles[key];
        if (!tile) {
          return;
        }
        if (!androidStock) {
          tile.el.setAttribute("src", emptyImageUrl);
        }
        return GridLayer.prototype._removeTile.call(this, key);
      },
      _tileReady: function(coords, err, tile) {
        if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
          return;
        }
        return GridLayer.prototype._tileReady.call(this, coords, err, tile);
      }
    });
    function tileLayer(url, options) {
      return new TileLayer(url, options);
    }
    var TileLayerWMS = TileLayer.extend({
      defaultWmsParams: {
        service: "WMS",
        request: "GetMap",
        layers: "",
        styles: "",
        format: "image/jpeg",
        transparent: false,
        version: "1.1.1"
      },
      options: {
        crs: null,
        uppercase: false
      },
      initialize: function(url, options) {
        this._url = url;
        var wmsParams = extend({}, this.defaultWmsParams);
        for (var i in options) {
          if (!(i in this.options)) {
            wmsParams[i] = options[i];
          }
        }
        options = setOptions(this, options);
        var realRetina = options.detectRetina && retina ? 2 : 1;
        var tileSize = this.getTileSize();
        wmsParams.width = tileSize.x * realRetina;
        wmsParams.height = tileSize.y * realRetina;
        this.wmsParams = wmsParams;
      },
      onAdd: function(map) {
        this._crs = this.options.crs || map.options.crs;
        this._wmsVersion = parseFloat(this.wmsParams.version);
        var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
        this.wmsParams[projectionKey] = this._crs.code;
        TileLayer.prototype.onAdd.call(this, map);
      },
      getTileUrl: function(coords) {
        var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
        return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
      },
      setParams: function(params2, noRedraw) {
        extend(this.wmsParams, params2);
        if (!noRedraw) {
          this.redraw();
        }
        return this;
      }
    });
    function tileLayerWMS(url, options) {
      return new TileLayerWMS(url, options);
    }
    TileLayer.WMS = TileLayerWMS;
    tileLayer.wms = tileLayerWMS;
    var Renderer = Layer.extend({
      options: {
        padding: 0.1,
        tolerance: 0
      },
      initialize: function(options) {
        setOptions(this, options);
        stamp(this);
        this._layers = this._layers || {};
      },
      onAdd: function() {
        if (!this._container) {
          this._initContainer();
          if (this._zoomAnimated) {
            addClass(this._container, "leaflet-zoom-animated");
          }
        }
        this.getPane().appendChild(this._container);
        this._update();
        this.on("update", this._updatePaths, this);
      },
      onRemove: function() {
        this.off("update", this._updatePaths, this);
        this._destroyContainer();
      },
      getEvents: function() {
        var events2 = {
          viewreset: this._reset,
          zoom: this._onZoom,
          moveend: this._update,
          zoomend: this._onZoomEnd
        };
        if (this._zoomAnimated) {
          events2.zoomanim = this._onAnimZoom;
        }
        return events2;
      },
      _onAnimZoom: function(ev) {
        this._updateTransform(ev.center, ev.zoom);
      },
      _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom());
      },
      _updateTransform: function(center, zoom2) {
        var scale2 = this._map.getZoomScale(zoom2, this._zoom), position = getPosition(this._container), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), destCenterPoint = this._map.project(center, zoom2), centerOffset = destCenterPoint.subtract(currentCenterPoint), topLeftOffset = viewHalf.multiplyBy(-scale2).add(position).add(viewHalf).subtract(centerOffset);
        if (any3d) {
          setTransform(this._container, topLeftOffset, scale2);
        } else {
          setPosition(this._container, topLeftOffset);
        }
      },
      _reset: function() {
        this._update();
        this._updateTransform(this._center, this._zoom);
        for (var id in this._layers) {
          this._layers[id]._reset();
        }
      },
      _onZoomEnd: function() {
        for (var id in this._layers) {
          this._layers[id]._project();
        }
      },
      _updatePaths: function() {
        for (var id in this._layers) {
          this._layers[id]._update();
        }
      },
      _update: function() {
        var p2 = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p2)).round();
        this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p2 * 2)).round());
        this._center = this._map.getCenter();
        this._zoom = this._map.getZoom();
      }
    });
    var Canvas = Renderer.extend({
      getEvents: function() {
        var events2 = Renderer.prototype.getEvents.call(this);
        events2.viewprereset = this._onViewPreReset;
        return events2;
      },
      _onViewPreReset: function() {
        this._postponeUpdatePaths = true;
      },
      onAdd: function() {
        Renderer.prototype.onAdd.call(this);
        this._draw();
      },
      _initContainer: function() {
        var container = this._container = document.createElement("canvas");
        on(container, "mousemove", this._onMouseMove, this);
        on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
        on(container, "mouseout", this._handleMouseOut, this);
        this._ctx = container.getContext("2d");
      },
      _destroyContainer: function() {
        cancelAnimFrame(this._redrawRequest);
        delete this._ctx;
        remove(this._container);
        off(this._container);
        delete this._container;
      },
      _updatePaths: function() {
        if (this._postponeUpdatePaths) {
          return;
        }
        var layer;
        this._redrawBounds = null;
        for (var id in this._layers) {
          layer = this._layers[id];
          layer._update();
        }
        this._redraw();
      },
      _update: function() {
        if (this._map._animatingZoom && this._bounds) {
          return;
        }
        Renderer.prototype._update.call(this);
        var b = this._bounds, container = this._container, size = b.getSize(), m = retina ? 2 : 1;
        setPosition(container, b.min);
        container.width = m * size.x;
        container.height = m * size.y;
        container.style.width = size.x + "px";
        container.style.height = size.y + "px";
        if (retina) {
          this._ctx.scale(2, 2);
        }
        this._ctx.translate(-b.min.x, -b.min.y);
        this.fire("update");
      },
      _reset: function() {
        Renderer.prototype._reset.call(this);
        if (this._postponeUpdatePaths) {
          this._postponeUpdatePaths = false;
          this._updatePaths();
        }
      },
      _initPath: function(layer) {
        this._updateDashArray(layer);
        this._layers[stamp(layer)] = layer;
        var order = layer._order = {
          layer,
          prev: this._drawLast,
          next: null
        };
        if (this._drawLast) {
          this._drawLast.next = order;
        }
        this._drawLast = order;
        this._drawFirst = this._drawFirst || this._drawLast;
      },
      _addPath: function(layer) {
        this._requestRedraw(layer);
      },
      _removePath: function(layer) {
        var order = layer._order;
        var next = order.next;
        var prev = order.prev;
        if (next) {
          next.prev = prev;
        } else {
          this._drawLast = prev;
        }
        if (prev) {
          prev.next = next;
        } else {
          this._drawFirst = next;
        }
        delete layer._order;
        delete this._layers[stamp(layer)];
        this._requestRedraw(layer);
      },
      _updatePath: function(layer) {
        this._extendRedrawBounds(layer);
        layer._project();
        layer._update();
        this._requestRedraw(layer);
      },
      _updateStyle: function(layer) {
        this._updateDashArray(layer);
        this._requestRedraw(layer);
      },
      _updateDashArray: function(layer) {
        if (typeof layer.options.dashArray === "string") {
          var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
          for (i = 0; i < parts.length; i++) {
            dashValue = Number(parts[i]);
            if (isNaN(dashValue)) {
              return;
            }
            dashArray.push(dashValue);
          }
          layer.options._dashArray = dashArray;
        } else {
          layer.options._dashArray = layer.options.dashArray;
        }
      },
      _requestRedraw: function(layer) {
        if (!this._map) {
          return;
        }
        this._extendRedrawBounds(layer);
        this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
      },
      _extendRedrawBounds: function(layer) {
        if (layer._pxBounds) {
          var padding = (layer.options.weight || 0) + 1;
          this._redrawBounds = this._redrawBounds || new Bounds();
          this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
          this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
        }
      },
      _redraw: function() {
        this._redrawRequest = null;
        if (this._redrawBounds) {
          this._redrawBounds.min._floor();
          this._redrawBounds.max._ceil();
        }
        this._clear();
        this._draw();
        this._redrawBounds = null;
      },
      _clear: function() {
        var bounds = this._redrawBounds;
        if (bounds) {
          var size = bounds.getSize();
          this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
        } else {
          this._ctx.save();
          this._ctx.setTransform(1, 0, 0, 1, 0, 0);
          this._ctx.clearRect(0, 0, this._container.width, this._container.height);
          this._ctx.restore();
        }
      },
      _draw: function() {
        var layer, bounds = this._redrawBounds;
        this._ctx.save();
        if (bounds) {
          var size = bounds.getSize();
          this._ctx.beginPath();
          this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
          this._ctx.clip();
        }
        this._drawing = true;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
            layer._updatePath();
          }
        }
        this._drawing = false;
        this._ctx.restore();
      },
      _updatePoly: function(layer, closed) {
        if (!this._drawing) {
          return;
        }
        var i, j, len2, p2, parts = layer._parts, len = parts.length, ctx = this._ctx;
        if (!len) {
          return;
        }
        ctx.beginPath();
        for (i = 0; i < len; i++) {
          for (j = 0, len2 = parts[i].length; j < len2; j++) {
            p2 = parts[i][j];
            ctx[j ? "lineTo" : "moveTo"](p2.x, p2.y);
          }
          if (closed) {
            ctx.closePath();
          }
        }
        this._fillStroke(ctx, layer);
      },
      _updateCircle: function(layer) {
        if (!this._drawing || layer._empty()) {
          return;
        }
        var p2 = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
        if (s !== 1) {
          ctx.save();
          ctx.scale(1, s);
        }
        ctx.beginPath();
        ctx.arc(p2.x, p2.y / s, r, 0, Math.PI * 2, false);
        if (s !== 1) {
          ctx.restore();
        }
        this._fillStroke(ctx, layer);
      },
      _fillStroke: function(ctx, layer) {
        var options = layer.options;
        if (options.fill) {
          ctx.globalAlpha = options.fillOpacity;
          ctx.fillStyle = options.fillColor || options.color;
          ctx.fill(options.fillRule || "evenodd");
        }
        if (options.stroke && options.weight !== 0) {
          if (ctx.setLineDash) {
            ctx.setLineDash(layer.options && layer.options._dashArray || []);
          }
          ctx.globalAlpha = options.opacity;
          ctx.lineWidth = options.weight;
          ctx.strokeStyle = options.color;
          ctx.lineCap = options.lineCap;
          ctx.lineJoin = options.lineJoin;
          ctx.stroke();
        }
      },
      _onClick: function(e) {
        var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (layer.options.interactive && layer._containsPoint(point)) {
            if (!(e.type === "click" || e.type !== "preclick") || !this._map._draggableMoved(layer)) {
              clickedLayer = layer;
            }
          }
        }
        if (clickedLayer) {
          fakeStop(e);
          this._fireEvent([clickedLayer], e);
        }
      },
      _onMouseMove: function(e) {
        if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
          return;
        }
        var point = this._map.mouseEventToLayerPoint(e);
        this._handleMouseHover(e, point);
      },
      _handleMouseOut: function(e) {
        var layer = this._hoveredLayer;
        if (layer) {
          removeClass(this._container, "leaflet-interactive");
          this._fireEvent([layer], e, "mouseout");
          this._hoveredLayer = null;
          this._mouseHoverThrottled = false;
        }
      },
      _handleMouseHover: function(e, point) {
        if (this._mouseHoverThrottled) {
          return;
        }
        var layer, candidateHoveredLayer;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (layer.options.interactive && layer._containsPoint(point)) {
            candidateHoveredLayer = layer;
          }
        }
        if (candidateHoveredLayer !== this._hoveredLayer) {
          this._handleMouseOut(e);
          if (candidateHoveredLayer) {
            addClass(this._container, "leaflet-interactive");
            this._fireEvent([candidateHoveredLayer], e, "mouseover");
            this._hoveredLayer = candidateHoveredLayer;
          }
        }
        if (this._hoveredLayer) {
          this._fireEvent([this._hoveredLayer], e);
        }
        this._mouseHoverThrottled = true;
        setTimeout(bind2(function() {
          this._mouseHoverThrottled = false;
        }, this), 32);
      },
      _fireEvent: function(layers2, e, type2) {
        this._map._fireDOMEvent(e, type2 || e.type, layers2);
      },
      _bringToFront: function(layer) {
        var order = layer._order;
        if (!order) {
          return;
        }
        var next = order.next;
        var prev = order.prev;
        if (next) {
          next.prev = prev;
        } else {
          return;
        }
        if (prev) {
          prev.next = next;
        } else if (next) {
          this._drawFirst = next;
        }
        order.prev = this._drawLast;
        this._drawLast.next = order;
        order.next = null;
        this._drawLast = order;
        this._requestRedraw(layer);
      },
      _bringToBack: function(layer) {
        var order = layer._order;
        if (!order) {
          return;
        }
        var next = order.next;
        var prev = order.prev;
        if (prev) {
          prev.next = next;
        } else {
          return;
        }
        if (next) {
          next.prev = prev;
        } else if (prev) {
          this._drawLast = prev;
        }
        order.prev = null;
        order.next = this._drawFirst;
        this._drawFirst.prev = order;
        this._drawFirst = order;
        this._requestRedraw(layer);
      }
    });
    function canvas$1(options) {
      return canvas ? new Canvas(options) : null;
    }
    var vmlCreate = function() {
      try {
        document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
        return function(name) {
          return document.createElement("<lvml:" + name + ' class="lvml">');
        };
      } catch (e) {
        return function(name) {
          return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }
    }();
    var vmlMixin = {
      _initContainer: function() {
        this._container = create$1("div", "leaflet-vml-container");
      },
      _update: function() {
        if (this._map._animatingZoom) {
          return;
        }
        Renderer.prototype._update.call(this);
        this.fire("update");
      },
      _initPath: function(layer) {
        var container = layer._container = vmlCreate("shape");
        addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
        container.coordsize = "1 1";
        layer._path = vmlCreate("path");
        container.appendChild(layer._path);
        this._updateStyle(layer);
        this._layers[stamp(layer)] = layer;
      },
      _addPath: function(layer) {
        var container = layer._container;
        this._container.appendChild(container);
        if (layer.options.interactive) {
          layer.addInteractiveTarget(container);
        }
      },
      _removePath: function(layer) {
        var container = layer._container;
        remove(container);
        layer.removeInteractiveTarget(container);
        delete this._layers[stamp(layer)];
      },
      _updateStyle: function(layer) {
        var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
        container.stroked = !!options.stroke;
        container.filled = !!options.fill;
        if (options.stroke) {
          if (!stroke) {
            stroke = layer._stroke = vmlCreate("stroke");
          }
          container.appendChild(stroke);
          stroke.weight = options.weight + "px";
          stroke.color = options.color;
          stroke.opacity = options.opacity;
          if (options.dashArray) {
            stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
          } else {
            stroke.dashStyle = "";
          }
          stroke.endcap = options.lineCap.replace("butt", "flat");
          stroke.joinstyle = options.lineJoin;
        } else if (stroke) {
          container.removeChild(stroke);
          layer._stroke = null;
        }
        if (options.fill) {
          if (!fill) {
            fill = layer._fill = vmlCreate("fill");
          }
          container.appendChild(fill);
          fill.color = options.fillColor || options.color;
          fill.opacity = options.fillOpacity;
        } else if (fill) {
          container.removeChild(fill);
          layer._fill = null;
        }
      },
      _updateCircle: function(layer) {
        var p2 = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
        this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p2.x + "," + p2.y + " " + r + "," + r2 + " 0," + 65535 * 360);
      },
      _setPath: function(layer, path) {
        layer._path.v = path;
      },
      _bringToFront: function(layer) {
        toFront(layer._container);
      },
      _bringToBack: function(layer) {
        toBack(layer._container);
      }
    };
    var create$2 = vml ? vmlCreate : svgCreate;
    var SVG = Renderer.extend({
      getEvents: function() {
        var events2 = Renderer.prototype.getEvents.call(this);
        events2.zoomstart = this._onZoomStart;
        return events2;
      },
      _initContainer: function() {
        this._container = create$2("svg");
        this._container.setAttribute("pointer-events", "none");
        this._rootGroup = create$2("g");
        this._container.appendChild(this._rootGroup);
      },
      _destroyContainer: function() {
        remove(this._container);
        off(this._container);
        delete this._container;
        delete this._rootGroup;
        delete this._svgSize;
      },
      _onZoomStart: function() {
        this._update();
      },
      _update: function() {
        if (this._map._animatingZoom && this._bounds) {
          return;
        }
        Renderer.prototype._update.call(this);
        var b = this._bounds, size = b.getSize(), container = this._container;
        if (!this._svgSize || !this._svgSize.equals(size)) {
          this._svgSize = size;
          container.setAttribute("width", size.x);
          container.setAttribute("height", size.y);
        }
        setPosition(container, b.min);
        container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
        this.fire("update");
      },
      _initPath: function(layer) {
        var path = layer._path = create$2("path");
        if (layer.options.className) {
          addClass(path, layer.options.className);
        }
        if (layer.options.interactive) {
          addClass(path, "leaflet-interactive");
        }
        this._updateStyle(layer);
        this._layers[stamp(layer)] = layer;
      },
      _addPath: function(layer) {
        if (!this._rootGroup) {
          this._initContainer();
        }
        this._rootGroup.appendChild(layer._path);
        layer.addInteractiveTarget(layer._path);
      },
      _removePath: function(layer) {
        remove(layer._path);
        layer.removeInteractiveTarget(layer._path);
        delete this._layers[stamp(layer)];
      },
      _updatePath: function(layer) {
        layer._project();
        layer._update();
      },
      _updateStyle: function(layer) {
        var path = layer._path, options = layer.options;
        if (!path) {
          return;
        }
        if (options.stroke) {
          path.setAttribute("stroke", options.color);
          path.setAttribute("stroke-opacity", options.opacity);
          path.setAttribute("stroke-width", options.weight);
          path.setAttribute("stroke-linecap", options.lineCap);
          path.setAttribute("stroke-linejoin", options.lineJoin);
          if (options.dashArray) {
            path.setAttribute("stroke-dasharray", options.dashArray);
          } else {
            path.removeAttribute("stroke-dasharray");
          }
          if (options.dashOffset) {
            path.setAttribute("stroke-dashoffset", options.dashOffset);
          } else {
            path.removeAttribute("stroke-dashoffset");
          }
        } else {
          path.setAttribute("stroke", "none");
        }
        if (options.fill) {
          path.setAttribute("fill", options.fillColor || options.color);
          path.setAttribute("fill-opacity", options.fillOpacity);
          path.setAttribute("fill-rule", options.fillRule || "evenodd");
        } else {
          path.setAttribute("fill", "none");
        }
      },
      _updatePoly: function(layer, closed) {
        this._setPath(layer, pointsToPath(layer._parts, closed));
      },
      _updateCircle: function(layer) {
        var p2 = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
        var d = layer._empty() ? "M0 0" : "M" + (p2.x - r) + "," + p2.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
        this._setPath(layer, d);
      },
      _setPath: function(layer, path) {
        layer._path.setAttribute("d", path);
      },
      _bringToFront: function(layer) {
        toFront(layer._path);
      },
      _bringToBack: function(layer) {
        toBack(layer._path);
      }
    });
    if (vml) {
      SVG.include(vmlMixin);
    }
    function svg$1(options) {
      return svg || vml ? new SVG(options) : null;
    }
    Map2.include({
      getRenderer: function(layer) {
        var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
        if (!renderer) {
          renderer = this._renderer = this._createRenderer();
        }
        if (!this.hasLayer(renderer)) {
          this.addLayer(renderer);
        }
        return renderer;
      },
      _getPaneRenderer: function(name) {
        if (name === "overlayPane" || name === void 0) {
          return false;
        }
        var renderer = this._paneRenderers[name];
        if (renderer === void 0) {
          renderer = this._createRenderer({ pane: name });
          this._paneRenderers[name] = renderer;
        }
        return renderer;
      },
      _createRenderer: function(options) {
        return this.options.preferCanvas && canvas$1(options) || svg$1(options);
      }
    });
    var Rectangle = Polygon.extend({
      initialize: function(latLngBounds, options) {
        Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
      },
      setBounds: function(latLngBounds) {
        return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
      },
      _boundsToLatLngs: function(latLngBounds) {
        latLngBounds = toLatLngBounds(latLngBounds);
        return [
          latLngBounds.getSouthWest(),
          latLngBounds.getNorthWest(),
          latLngBounds.getNorthEast(),
          latLngBounds.getSouthEast()
        ];
      }
    });
    function rectangle(latLngBounds, options) {
      return new Rectangle(latLngBounds, options);
    }
    SVG.create = create$2;
    SVG.pointsToPath = pointsToPath;
    GeoJSON.geometryToLayer = geometryToLayer;
    GeoJSON.coordsToLatLng = coordsToLatLng;
    GeoJSON.coordsToLatLngs = coordsToLatLngs;
    GeoJSON.latLngToCoords = latLngToCoords;
    GeoJSON.latLngsToCoords = latLngsToCoords;
    GeoJSON.getFeature = getFeature;
    GeoJSON.asFeature = asFeature;
    Map2.mergeOptions({
      boxZoom: true
    });
    var BoxZoom = Handler.extend({
      initialize: function(map) {
        this._map = map;
        this._container = map._container;
        this._pane = map._panes.overlayPane;
        this._resetStateTimeout = 0;
        map.on("unload", this._destroy, this);
      },
      addHooks: function() {
        on(this._container, "mousedown", this._onMouseDown, this);
      },
      removeHooks: function() {
        off(this._container, "mousedown", this._onMouseDown, this);
      },
      moved: function() {
        return this._moved;
      },
      _destroy: function() {
        remove(this._pane);
        delete this._pane;
      },
      _resetState: function() {
        this._resetStateTimeout = 0;
        this._moved = false;
      },
      _clearDeferredResetState: function() {
        if (this._resetStateTimeout !== 0) {
          clearTimeout(this._resetStateTimeout);
          this._resetStateTimeout = 0;
        }
      },
      _onMouseDown: function(e) {
        if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
          return false;
        }
        this._clearDeferredResetState();
        this._resetState();
        disableTextSelection();
        disableImageDrag();
        this._startPoint = this._map.mouseEventToContainerPoint(e);
        on(document, {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseMove: function(e) {
        if (!this._moved) {
          this._moved = true;
          this._box = create$1("div", "leaflet-zoom-box", this._container);
          addClass(this._container, "leaflet-crosshair");
          this._map.fire("boxzoomstart");
        }
        this._point = this._map.mouseEventToContainerPoint(e);
        var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
        setPosition(this._box, bounds.min);
        this._box.style.width = size.x + "px";
        this._box.style.height = size.y + "px";
      },
      _finish: function() {
        if (this._moved) {
          remove(this._box);
          removeClass(this._container, "leaflet-crosshair");
        }
        enableTextSelection();
        enableImageDrag();
        off(document, {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseUp: function(e) {
        if (e.which !== 1 && e.button !== 1) {
          return;
        }
        this._finish();
        if (!this._moved) {
          return;
        }
        this._clearDeferredResetState();
        this._resetStateTimeout = setTimeout(bind2(this._resetState, this), 0);
        var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
        this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
      },
      _onKeyDown: function(e) {
        if (e.keyCode === 27) {
          this._finish();
        }
      }
    });
    Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
    Map2.mergeOptions({
      doubleClickZoom: true
    });
    var DoubleClickZoom = Handler.extend({
      addHooks: function() {
        this._map.on("dblclick", this._onDoubleClick, this);
      },
      removeHooks: function() {
        this._map.off("dblclick", this._onDoubleClick, this);
      },
      _onDoubleClick: function(e) {
        var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
        if (map.options.doubleClickZoom === "center") {
          map.setZoom(zoom2);
        } else {
          map.setZoomAround(e.containerPoint, zoom2);
        }
      }
    });
    Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
    Map2.mergeOptions({
      dragging: true,
      inertia: !android23,
      inertiaDeceleration: 3400,
      inertiaMaxSpeed: Infinity,
      easeLinearity: 0.2,
      worldCopyJump: false,
      maxBoundsViscosity: 0
    });
    var Drag = Handler.extend({
      addHooks: function() {
        if (!this._draggable) {
          var map = this._map;
          this._draggable = new Draggable(map._mapPane, map._container);
          this._draggable.on({
            dragstart: this._onDragStart,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this);
          this._draggable.on("predrag", this._onPreDragLimit, this);
          if (map.options.worldCopyJump) {
            this._draggable.on("predrag", this._onPreDragWrap, this);
            map.on("zoomend", this._onZoomEnd, this);
            map.whenReady(this._onZoomEnd, this);
          }
        }
        addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
        this._draggable.enable();
        this._positions = [];
        this._times = [];
      },
      removeHooks: function() {
        removeClass(this._map._container, "leaflet-grab");
        removeClass(this._map._container, "leaflet-touch-drag");
        this._draggable.disable();
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      moving: function() {
        return this._draggable && this._draggable._moving;
      },
      _onDragStart: function() {
        var map = this._map;
        map._stop();
        if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
          var bounds = toLatLngBounds(this._map.options.maxBounds);
          this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
          this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
        } else {
          this._offsetLimit = null;
        }
        map.fire("movestart").fire("dragstart");
        if (map.options.inertia) {
          this._positions = [];
          this._times = [];
        }
      },
      _onDrag: function(e) {
        if (this._map.options.inertia) {
          var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
          this._positions.push(pos);
          this._times.push(time);
          this._prunePositions(time);
        }
        this._map.fire("move", e).fire("drag", e);
      },
      _prunePositions: function(time) {
        while (this._positions.length > 1 && time - this._times[0] > 50) {
          this._positions.shift();
          this._times.shift();
        }
      },
      _onZoomEnd: function() {
        var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
        this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
        this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
      },
      _viscousLimit: function(value, threshold) {
        return value - (value - threshold) * this._viscosity;
      },
      _onPreDragLimit: function() {
        if (!this._viscosity || !this._offsetLimit) {
          return;
        }
        var offset = this._draggable._newPos.subtract(this._draggable._startPos);
        var limit = this._offsetLimit;
        if (offset.x < limit.min.x) {
          offset.x = this._viscousLimit(offset.x, limit.min.x);
        }
        if (offset.y < limit.min.y) {
          offset.y = this._viscousLimit(offset.y, limit.min.y);
        }
        if (offset.x > limit.max.x) {
          offset.x = this._viscousLimit(offset.x, limit.max.x);
        }
        if (offset.y > limit.max.y) {
          offset.y = this._viscousLimit(offset.y, limit.max.y);
        }
        this._draggable._newPos = this._draggable._startPos.add(offset);
      },
      _onPreDragWrap: function() {
        var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
        this._draggable._absPos = this._draggable._newPos.clone();
        this._draggable._newPos.x = newX;
      },
      _onDragEnd: function(e) {
        var map = this._map, options = map.options, noInertia = !options.inertia || this._times.length < 2;
        map.fire("dragend", e);
        if (noInertia) {
          map.fire("moveend");
        } else {
          this._prunePositions(+new Date());
          var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
          if (!offset.x && !offset.y) {
            map.fire("moveend");
          } else {
            offset = map._limitOffset(offset, map.options.maxBounds);
            requestAnimFrame(function() {
              map.panBy(offset, {
                duration: decelerationDuration,
                easeLinearity: ease,
                noMoveStart: true,
                animate: true
              });
            });
          }
        }
      }
    });
    Map2.addInitHook("addHandler", "dragging", Drag);
    Map2.mergeOptions({
      keyboard: true,
      keyboardPanDelta: 80
    });
    var Keyboard = Handler.extend({
      keyCodes: {
        left: [37],
        right: [39],
        down: [40],
        up: [38],
        zoomIn: [187, 107, 61, 171],
        zoomOut: [189, 109, 54, 173]
      },
      initialize: function(map) {
        this._map = map;
        this._setPanDelta(map.options.keyboardPanDelta);
        this._setZoomDelta(map.options.zoomDelta);
      },
      addHooks: function() {
        var container = this._map._container;
        if (container.tabIndex <= 0) {
          container.tabIndex = "0";
        }
        on(container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this);
        this._map.on({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      removeHooks: function() {
        this._removeHooks();
        off(this._map._container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this);
        this._map.off({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      _onMouseDown: function() {
        if (this._focused) {
          return;
        }
        var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
        this._map._container.focus();
        window.scrollTo(left, top);
      },
      _onFocus: function() {
        this._focused = true;
        this._map.fire("focus");
      },
      _onBlur: function() {
        this._focused = false;
        this._map.fire("blur");
      },
      _setPanDelta: function(panDelta) {
        var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
        for (i = 0, len = codes.left.length; i < len; i++) {
          keys[codes.left[i]] = [-1 * panDelta, 0];
        }
        for (i = 0, len = codes.right.length; i < len; i++) {
          keys[codes.right[i]] = [panDelta, 0];
        }
        for (i = 0, len = codes.down.length; i < len; i++) {
          keys[codes.down[i]] = [0, panDelta];
        }
        for (i = 0, len = codes.up.length; i < len; i++) {
          keys[codes.up[i]] = [0, -1 * panDelta];
        }
      },
      _setZoomDelta: function(zoomDelta) {
        var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
        for (i = 0, len = codes.zoomIn.length; i < len; i++) {
          keys[codes.zoomIn[i]] = zoomDelta;
        }
        for (i = 0, len = codes.zoomOut.length; i < len; i++) {
          keys[codes.zoomOut[i]] = -zoomDelta;
        }
      },
      _addHooks: function() {
        on(document, "keydown", this._onKeyDown, this);
      },
      _removeHooks: function() {
        off(document, "keydown", this._onKeyDown, this);
      },
      _onKeyDown: function(e) {
        if (e.altKey || e.ctrlKey || e.metaKey) {
          return;
        }
        var key = e.keyCode, map = this._map, offset;
        if (key in this._panKeys) {
          if (!map._panAnim || !map._panAnim._inProgress) {
            offset = this._panKeys[key];
            if (e.shiftKey) {
              offset = toPoint(offset).multiplyBy(3);
            }
            map.panBy(offset);
            if (map.options.maxBounds) {
              map.panInsideBounds(map.options.maxBounds);
            }
          }
        } else if (key in this._zoomKeys) {
          map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
        } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
          map.closePopup();
        } else {
          return;
        }
        stop(e);
      }
    });
    Map2.addInitHook("addHandler", "keyboard", Keyboard);
    Map2.mergeOptions({
      scrollWheelZoom: true,
      wheelDebounceTime: 40,
      wheelPxPerZoomLevel: 60
    });
    var ScrollWheelZoom = Handler.extend({
      addHooks: function() {
        on(this._map._container, "wheel", this._onWheelScroll, this);
        this._delta = 0;
      },
      removeHooks: function() {
        off(this._map._container, "wheel", this._onWheelScroll, this);
      },
      _onWheelScroll: function(e) {
        var delta = getWheelDelta(e);
        var debounce = this._map.options.wheelDebounceTime;
        this._delta += delta;
        this._lastMousePos = this._map.mouseEventToContainerPoint(e);
        if (!this._startTime) {
          this._startTime = +new Date();
        }
        var left = Math.max(debounce - (+new Date() - this._startTime), 0);
        clearTimeout(this._timer);
        this._timer = setTimeout(bind2(this._performZoom, this), left);
        stop(e);
      },
      _performZoom: function() {
        var map = this._map, zoom2 = map.getZoom(), snap = this._map.options.zoomSnap || 0;
        map._stop();
        var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
        this._delta = 0;
        this._startTime = null;
        if (!delta) {
          return;
        }
        if (map.options.scrollWheelZoom === "center") {
          map.setZoom(zoom2 + delta);
        } else {
          map.setZoomAround(this._lastMousePos, zoom2 + delta);
        }
      }
    });
    Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
    Map2.mergeOptions({
      tap: true,
      tapTolerance: 15
    });
    var Tap = Handler.extend({
      addHooks: function() {
        on(this._map._container, "touchstart", this._onDown, this);
      },
      removeHooks: function() {
        off(this._map._container, "touchstart", this._onDown, this);
      },
      _onDown: function(e) {
        if (!e.touches) {
          return;
        }
        preventDefault(e);
        this._fireClick = true;
        if (e.touches.length > 1) {
          this._fireClick = false;
          clearTimeout(this._holdTimeout);
          return;
        }
        var first = e.touches[0], el = first.target;
        this._startPos = this._newPos = new Point(first.clientX, first.clientY);
        if (el.tagName && el.tagName.toLowerCase() === "a") {
          addClass(el, "leaflet-active");
        }
        this._holdTimeout = setTimeout(bind2(function() {
          if (this._isTapValid()) {
            this._fireClick = false;
            this._onUp();
            this._simulateEvent("contextmenu", first);
          }
        }, this), 1e3);
        this._simulateEvent("mousedown", first);
        on(document, {
          touchmove: this._onMove,
          touchend: this._onUp
        }, this);
      },
      _onUp: function(e) {
        clearTimeout(this._holdTimeout);
        off(document, {
          touchmove: this._onMove,
          touchend: this._onUp
        }, this);
        if (this._fireClick && e && e.changedTouches) {
          var first = e.changedTouches[0], el = first.target;
          if (el && el.tagName && el.tagName.toLowerCase() === "a") {
            removeClass(el, "leaflet-active");
          }
          this._simulateEvent("mouseup", first);
          if (this._isTapValid()) {
            this._simulateEvent("click", first);
          }
        }
      },
      _isTapValid: function() {
        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
      },
      _onMove: function(e) {
        var first = e.touches[0];
        this._newPos = new Point(first.clientX, first.clientY);
        this._simulateEvent("mousemove", first);
      },
      _simulateEvent: function(type2, e) {
        var simulatedEvent = document.createEvent("MouseEvents");
        simulatedEvent._simulated = true;
        e.target._simulatedClick = true;
        simulatedEvent.initMouseEvent(type2, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
        e.target.dispatchEvent(simulatedEvent);
      }
    });
    if (touch && (!pointer || safari)) {
      Map2.addInitHook("addHandler", "tap", Tap);
    }
    Map2.mergeOptions({
      touchZoom: touch && !android23,
      bounceAtZoomLimits: true
    });
    var TouchZoom = Handler.extend({
      addHooks: function() {
        addClass(this._map._container, "leaflet-touch-zoom");
        on(this._map._container, "touchstart", this._onTouchStart, this);
      },
      removeHooks: function() {
        removeClass(this._map._container, "leaflet-touch-zoom");
        off(this._map._container, "touchstart", this._onTouchStart, this);
      },
      _onTouchStart: function(e) {
        var map = this._map;
        if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
          return;
        }
        var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
        this._centerPoint = map.getSize()._divideBy(2);
        this._startLatLng = map.containerPointToLatLng(this._centerPoint);
        if (map.options.touchZoom !== "center") {
          this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
        }
        this._startDist = p1.distanceTo(p2);
        this._startZoom = map.getZoom();
        this._moved = false;
        this._zooming = true;
        map._stop();
        on(document, "touchmove", this._onTouchMove, this);
        on(document, "touchend", this._onTouchEnd, this);
        preventDefault(e);
      },
      _onTouchMove: function(e) {
        if (!e.touches || e.touches.length !== 2 || !this._zooming) {
          return;
        }
        var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
        this._zoom = map.getScaleZoom(scale2, this._startZoom);
        if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
          this._zoom = map._limitZoom(this._zoom);
        }
        if (map.options.touchZoom === "center") {
          this._center = this._startLatLng;
          if (scale2 === 1) {
            return;
          }
        } else {
          var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
          if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
            return;
          }
          this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
        }
        if (!this._moved) {
          map._moveStart(true, false);
          this._moved = true;
        }
        cancelAnimFrame(this._animRequest);
        var moveFn = bind2(map._move, map, this._center, this._zoom, { pinch: true, round: false });
        this._animRequest = requestAnimFrame(moveFn, this, true);
        preventDefault(e);
      },
      _onTouchEnd: function() {
        if (!this._moved || !this._zooming) {
          this._zooming = false;
          return;
        }
        this._zooming = false;
        cancelAnimFrame(this._animRequest);
        off(document, "touchmove", this._onTouchMove, this);
        off(document, "touchend", this._onTouchEnd, this);
        if (this._map.options.zoomAnimation) {
          this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
        } else {
          this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      }
    });
    Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
    Map2.BoxZoom = BoxZoom;
    Map2.DoubleClickZoom = DoubleClickZoom;
    Map2.Drag = Drag;
    Map2.Keyboard = Keyboard;
    Map2.ScrollWheelZoom = ScrollWheelZoom;
    Map2.Tap = Tap;
    Map2.TouchZoom = TouchZoom;
    exports2.version = version;
    exports2.Control = Control;
    exports2.control = control;
    exports2.Browser = Browser;
    exports2.Evented = Evented;
    exports2.Mixin = Mixin;
    exports2.Util = Util;
    exports2.Class = Class;
    exports2.Handler = Handler;
    exports2.extend = extend;
    exports2.bind = bind2;
    exports2.stamp = stamp;
    exports2.setOptions = setOptions;
    exports2.DomEvent = DomEvent;
    exports2.DomUtil = DomUtil;
    exports2.PosAnimation = PosAnimation;
    exports2.Draggable = Draggable;
    exports2.LineUtil = LineUtil;
    exports2.PolyUtil = PolyUtil;
    exports2.Point = Point;
    exports2.point = toPoint;
    exports2.Bounds = Bounds;
    exports2.bounds = toBounds;
    exports2.Transformation = Transformation;
    exports2.transformation = toTransformation;
    exports2.Projection = index;
    exports2.LatLng = LatLng;
    exports2.latLng = toLatLng;
    exports2.LatLngBounds = LatLngBounds;
    exports2.latLngBounds = toLatLngBounds;
    exports2.CRS = CRS;
    exports2.GeoJSON = GeoJSON;
    exports2.geoJSON = geoJSON;
    exports2.geoJson = geoJson;
    exports2.Layer = Layer;
    exports2.LayerGroup = LayerGroup;
    exports2.layerGroup = layerGroup;
    exports2.FeatureGroup = FeatureGroup;
    exports2.featureGroup = featureGroup;
    exports2.ImageOverlay = ImageOverlay;
    exports2.imageOverlay = imageOverlay;
    exports2.VideoOverlay = VideoOverlay;
    exports2.videoOverlay = videoOverlay;
    exports2.SVGOverlay = SVGOverlay;
    exports2.svgOverlay = svgOverlay;
    exports2.DivOverlay = DivOverlay;
    exports2.Popup = Popup;
    exports2.popup = popup;
    exports2.Tooltip = Tooltip;
    exports2.tooltip = tooltip;
    exports2.Icon = Icon;
    exports2.icon = icon;
    exports2.DivIcon = DivIcon;
    exports2.divIcon = divIcon;
    exports2.Marker = Marker;
    exports2.marker = marker;
    exports2.TileLayer = TileLayer;
    exports2.tileLayer = tileLayer;
    exports2.GridLayer = GridLayer;
    exports2.gridLayer = gridLayer;
    exports2.SVG = SVG;
    exports2.svg = svg$1;
    exports2.Renderer = Renderer;
    exports2.Canvas = Canvas;
    exports2.canvas = canvas$1;
    exports2.Path = Path;
    exports2.CircleMarker = CircleMarker;
    exports2.circleMarker = circleMarker;
    exports2.Circle = Circle;
    exports2.circle = circle;
    exports2.Polyline = Polyline;
    exports2.polyline = polyline;
    exports2.Polygon = Polygon;
    exports2.polygon = polygon;
    exports2.Rectangle = Rectangle;
    exports2.rectangle = rectangle;
    exports2.Map = Map2;
    exports2.map = createMap;
    var oldL = window.L;
    exports2.noConflict = function() {
      window.L = oldL;
      return this;
    };
    window.L = exports2;
  });
})(leafletSrc, leafletSrc.exports);
var L$1 = leafletSrc.exports;
function create_if_block$a(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "mdc-button__touch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$7(ctx) {
  let div;
  let t;
  let if_block_anchor;
  let current;
  const default_slot_template = ctx[27].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[29], null);
  let if_block = ctx[6] && create_if_block$a();
  return {
    c() {
      div = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "mdc-button__ripple");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 536870912)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[29], !current ? get_all_dirty_from_scope(ctx2[29]) : get_slot_changes(default_slot_template, ctx2[29], dirty, null), null);
        }
      }
      if (ctx2[6]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$a();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$k(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        [
          Ripple,
          {
            ripple: ctx[3],
            unbounded: false,
            color: ctx[4],
            disabled: !!ctx[22].disabled,
            addClass: ctx[18],
            removeClass: ctx[19],
            addStyle: ctx[20]
          }
        ],
        ctx[16],
        ...ctx[0]
      ]
    },
    {
      class: classMap(__spreadValues({
        [ctx[1]]: true,
        "mdc-button": true,
        "mdc-button--raised": ctx[5] === "raised",
        "mdc-button--unelevated": ctx[5] === "unelevated",
        "mdc-button--outlined": ctx[5] === "outlined",
        "smui-button--color-secondary": ctx[4] === "secondary",
        "mdc-button--touch": ctx[6],
        "mdc-card__action": ctx[17] === "card:action",
        "mdc-card__action--button": ctx[17] === "card:action",
        "mdc-dialog__button": ctx[17] === "dialog:action",
        "mdc-top-app-bar__navigation-icon": ctx[17] === "top-app-bar:navigation",
        "mdc-top-app-bar__action-item": ctx[17] === "top-app-bar:action",
        "mdc-snackbar__action": ctx[17] === "snackbar:actions",
        "mdc-banner__secondary-action": ctx[17] === "banner" && ctx[8],
        "mdc-banner__primary-action": ctx[17] === "banner" && !ctx[8],
        "mdc-tooltip__action": ctx[17] === "tooltip:rich-actions"
      }, ctx[11]))
    },
    {
      style: Object.entries(ctx[12]).map(func$5).concat([ctx[2]]).join(" ")
    },
    ctx[15],
    ctx[14],
    ctx[13],
    { href: ctx[7] },
    ctx[22]
  ];
  var switch_value = ctx[9];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    ctx[28](switch_instance);
    switch_instance.$on("click", ctx[21]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 6289919 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 6094873 && {
          use: [
            [
              Ripple,
              {
                ripple: ctx2[3],
                unbounded: false,
                color: ctx2[4],
                disabled: !!ctx2[22].disabled,
                addClass: ctx2[18],
                removeClass: ctx2[19],
                addStyle: ctx2[20]
              }
            ],
            ctx2[16],
            ...ctx2[0]
          ]
        },
        dirty & 133490 && {
          class: classMap(__spreadValues({
            [ctx2[1]]: true,
            "mdc-button": true,
            "mdc-button--raised": ctx2[5] === "raised",
            "mdc-button--unelevated": ctx2[5] === "unelevated",
            "mdc-button--outlined": ctx2[5] === "outlined",
            "smui-button--color-secondary": ctx2[4] === "secondary",
            "mdc-button--touch": ctx2[6],
            "mdc-card__action": ctx2[17] === "card:action",
            "mdc-card__action--button": ctx2[17] === "card:action",
            "mdc-dialog__button": ctx2[17] === "dialog:action",
            "mdc-top-app-bar__navigation-icon": ctx2[17] === "top-app-bar:navigation",
            "mdc-top-app-bar__action-item": ctx2[17] === "top-app-bar:action",
            "mdc-snackbar__action": ctx2[17] === "snackbar:actions",
            "mdc-banner__secondary-action": ctx2[17] === "banner" && ctx2[8],
            "mdc-banner__primary-action": ctx2[17] === "banner" && !ctx2[8],
            "mdc-tooltip__action": ctx2[17] === "tooltip:rich-actions"
          }, ctx2[11]))
        },
        dirty & 4100 && {
          style: Object.entries(ctx2[12]).map(func$5).concat([ctx2[2]]).join(" ")
        },
        dirty & 32768 && get_spread_object(ctx2[15]),
        dirty & 16384 && get_spread_object(ctx2[14]),
        dirty & 8192 && get_spread_object(ctx2[13]),
        dirty & 128 && { href: ctx2[7] },
        dirty & 4194304 && get_spread_object(ctx2[22])
      ]) : {};
      if (dirty & 536870976) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[9])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          ctx2[28](switch_instance);
          switch_instance.$on("click", ctx2[21]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[28](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
const func$5 = ([name, value]) => `${name}: ${value};`;
function instance$d($$self, $$props, $$invalidate) {
  let actionProp;
  let defaultProp;
  let secondaryProp;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "color",
    "variant",
    "touch",
    "href",
    "action",
    "defaultAction",
    "secondary",
    "component",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { color = "primary" } = $$props;
  let { variant = "text" } = $$props;
  let { touch = false } = $$props;
  let { href = void 0 } = $$props;
  let { action = "close" } = $$props;
  let { defaultAction = false } = $$props;
  let { secondary = false } = $$props;
  let element2;
  let internalClasses = {};
  let internalStyles = {};
  let context = getContext("SMUI:button:context");
  let { component = href == null ? Button : A } = $$props;
  let previousDisabled = $$restProps.disabled;
  setContext("SMUI:label:context", "button");
  setContext("SMUI:icon:context", "button");
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(12, internalStyles);
      } else {
        $$invalidate(12, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function handleClick() {
    if (context === "banner") {
      dispatch(getElement(), secondary ? "SMUIBannerButton:secondaryActionClick" : "SMUIBannerButton:primaryActionClick");
    }
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(10, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("variant" in $$new_props)
      $$invalidate(5, variant = $$new_props.variant);
    if ("touch" in $$new_props)
      $$invalidate(6, touch = $$new_props.touch);
    if ("href" in $$new_props)
      $$invalidate(7, href = $$new_props.href);
    if ("action" in $$new_props)
      $$invalidate(23, action = $$new_props.action);
    if ("defaultAction" in $$new_props)
      $$invalidate(24, defaultAction = $$new_props.defaultAction);
    if ("secondary" in $$new_props)
      $$invalidate(8, secondary = $$new_props.secondary);
    if ("component" in $$new_props)
      $$invalidate(9, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(15, actionProp = context === "dialog:action" && action != null ? { "data-mdc-dialog-action": action } : { action: $$props.action });
    $$invalidate(14, defaultProp = context === "dialog:action" && defaultAction ? { "data-mdc-dialog-button-default": "" } : { default: $$props.default });
    $$invalidate(13, secondaryProp = context === "banner" ? {} : { secondary: $$props.secondary });
    if (previousDisabled !== $$restProps.disabled) {
      getElement().blur();
      $$invalidate(26, previousDisabled = $$restProps.disabled);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    className,
    style,
    ripple,
    color,
    variant,
    touch,
    href,
    secondary,
    component,
    element2,
    internalClasses,
    internalStyles,
    secondaryProp,
    defaultProp,
    actionProp,
    forwardEvents,
    context,
    addClass,
    removeClass,
    addStyle,
    handleClick,
    $$restProps,
    action,
    defaultAction,
    getElement,
    previousDisabled,
    slots,
    switch_instance_binding,
    $$scope
  ];
}
class Button_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$k, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      ripple: 3,
      color: 4,
      variant: 5,
      touch: 6,
      href: 7,
      action: 23,
      defaultAction: 24,
      secondary: 8,
      component: 9,
      getElement: 25
    });
  }
  get getElement() {
    return this.$$.ctx[25];
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$5 = {
  LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
  LABEL_REQUIRED: "mdc-floating-label--required",
  LABEL_SHAKE: "mdc-floating-label--shake",
  ROOT: "mdc-floating-label"
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFloatingLabelFoundation = function(_super) {
  __extends(MDCFloatingLabelFoundation2, _super);
  function MDCFloatingLabelFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation2.defaultAdapter), adapter)) || this;
    _this.shakeAnimationEndHandler = function() {
      _this.handleShakeAnimationEnd();
    };
    return _this;
  }
  Object.defineProperty(MDCFloatingLabelFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$5;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFloatingLabelFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        getWidth: function() {
          return 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCFloatingLabelFoundation2.prototype.init = function() {
    this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler);
  };
  MDCFloatingLabelFoundation2.prototype.destroy = function() {
    this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler);
  };
  MDCFloatingLabelFoundation2.prototype.getWidth = function() {
    return this.adapter.getWidth();
  };
  MDCFloatingLabelFoundation2.prototype.shake = function(shouldShake) {
    var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
    if (shouldShake) {
      this.adapter.addClass(LABEL_SHAKE);
    } else {
      this.adapter.removeClass(LABEL_SHAKE);
    }
  };
  MDCFloatingLabelFoundation2.prototype.float = function(shouldFloat) {
    var _a2 = MDCFloatingLabelFoundation2.cssClasses, LABEL_FLOAT_ABOVE = _a2.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a2.LABEL_SHAKE;
    if (shouldFloat) {
      this.adapter.addClass(LABEL_FLOAT_ABOVE);
    } else {
      this.adapter.removeClass(LABEL_FLOAT_ABOVE);
      this.adapter.removeClass(LABEL_SHAKE);
    }
  };
  MDCFloatingLabelFoundation2.prototype.setRequired = function(isRequired) {
    var LABEL_REQUIRED = MDCFloatingLabelFoundation2.cssClasses.LABEL_REQUIRED;
    if (isRequired) {
      this.adapter.addClass(LABEL_REQUIRED);
    } else {
      this.adapter.removeClass(LABEL_REQUIRED);
    }
  };
  MDCFloatingLabelFoundation2.prototype.handleShakeAnimationEnd = function() {
    var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
    this.adapter.removeClass(LABEL_SHAKE);
  };
  return MDCFloatingLabelFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$4 = {
  LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
  LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCLineRippleFoundation = function(_super) {
  __extends(MDCLineRippleFoundation2, _super);
  function MDCLineRippleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation2.defaultAdapter), adapter)) || this;
    _this.transitionEndHandler = function(evt) {
      _this.handleTransitionEnd(evt);
    };
    return _this;
  }
  Object.defineProperty(MDCLineRippleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCLineRippleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        setStyle: function() {
          return void 0;
        },
        registerEventHandler: function() {
          return void 0;
        },
        deregisterEventHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCLineRippleFoundation2.prototype.init = function() {
    this.adapter.registerEventHandler("transitionend", this.transitionEndHandler);
  };
  MDCLineRippleFoundation2.prototype.destroy = function() {
    this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler);
  };
  MDCLineRippleFoundation2.prototype.activate = function() {
    this.adapter.removeClass(cssClasses$4.LINE_RIPPLE_DEACTIVATING);
    this.adapter.addClass(cssClasses$4.LINE_RIPPLE_ACTIVE);
  };
  MDCLineRippleFoundation2.prototype.setRippleCenter = function(xCoordinate) {
    this.adapter.setStyle("transform-origin", xCoordinate + "px center");
  };
  MDCLineRippleFoundation2.prototype.deactivate = function() {
    this.adapter.addClass(cssClasses$4.LINE_RIPPLE_DEACTIVATING);
  };
  MDCLineRippleFoundation2.prototype.handleTransitionEnd = function(evt) {
    var isDeactivating = this.adapter.hasClass(cssClasses$4.LINE_RIPPLE_DEACTIVATING);
    if (evt.propertyName === "opacity") {
      if (isDeactivating) {
        this.adapter.removeClass(cssClasses$4.LINE_RIPPLE_ACTIVE);
        this.adapter.removeClass(cssClasses$4.LINE_RIPPLE_DEACTIVATING);
      }
    }
  };
  return MDCLineRippleFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$3 = {
  NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
};
var numbers$2 = {
  NOTCH_ELEMENT_PADDING: 8
};
var cssClasses$3 = {
  NO_LABEL: "mdc-notched-outline--no-label",
  OUTLINE_NOTCHED: "mdc-notched-outline--notched",
  OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCNotchedOutlineFoundation = function(_super) {
  __extends(MDCNotchedOutlineFoundation2, _super);
  function MDCNotchedOutlineFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCNotchedOutlineFoundation2, "strings", {
    get: function() {
      return strings$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "numbers", {
    get: function() {
      return numbers$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        setNotchWidthProperty: function() {
          return void 0;
        },
        removeNotchWidthProperty: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCNotchedOutlineFoundation2.prototype.notch = function(notchWidth) {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
    if (notchWidth > 0) {
      notchWidth += numbers$2.NOTCH_ELEMENT_PADDING;
    }
    this.adapter.setNotchWidthProperty(notchWidth);
    this.adapter.addClass(OUTLINE_NOTCHED);
  };
  MDCNotchedOutlineFoundation2.prototype.closeNotch = function() {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
    this.adapter.removeClass(OUTLINE_NOTCHED);
    this.adapter.removeNotchWidthProperty();
  };
  return MDCNotchedOutlineFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$2 = {
  ARIA_CONTROLS: "aria-controls",
  ARIA_DESCRIBEDBY: "aria-describedby",
  INPUT_SELECTOR: ".mdc-text-field__input",
  LABEL_SELECTOR: ".mdc-floating-label",
  LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
  LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
  OUTLINE_SELECTOR: ".mdc-notched-outline",
  PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
  SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
  TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
};
var cssClasses$2 = {
  DISABLED: "mdc-text-field--disabled",
  FOCUSED: "mdc-text-field--focused",
  HELPER_LINE: "mdc-text-field-helper-line",
  INVALID: "mdc-text-field--invalid",
  LABEL_FLOATING: "mdc-text-field--label-floating",
  NO_LABEL: "mdc-text-field--no-label",
  OUTLINED: "mdc-text-field--outlined",
  ROOT: "mdc-text-field",
  TEXTAREA: "mdc-text-field--textarea",
  WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
  WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon",
  WITH_INTERNAL_COUNTER: "mdc-text-field--with-internal-counter"
};
var numbers$1 = {
  LABEL_SCALE: 0.75
};
var VALIDATION_ATTR_WHITELIST = [
  "pattern",
  "min",
  "max",
  "required",
  "step",
  "minlength",
  "maxlength"
];
var ALWAYS_FLOAT_TYPES = [
  "color",
  "date",
  "datetime-local",
  "month",
  "range",
  "time",
  "week"
];
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var POINTERDOWN_EVENTS = ["mousedown", "touchstart"];
var INTERACTION_EVENTS = ["click", "keydown"];
var MDCTextFieldFoundation = function(_super) {
  __extends(MDCTextFieldFoundation2, _super);
  function MDCTextFieldFoundation2(adapter, foundationMap) {
    if (foundationMap === void 0) {
      foundationMap = {};
    }
    var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation2.defaultAdapter), adapter)) || this;
    _this.isFocused = false;
    _this.receivedUserInput = false;
    _this.valid = true;
    _this.useNativeValidation = true;
    _this.validateOnValueChange = true;
    _this.helperText = foundationMap.helperText;
    _this.characterCounter = foundationMap.characterCounter;
    _this.leadingIcon = foundationMap.leadingIcon;
    _this.trailingIcon = foundationMap.trailingIcon;
    _this.inputFocusHandler = function() {
      _this.activateFocus();
    };
    _this.inputBlurHandler = function() {
      _this.deactivateFocus();
    };
    _this.inputInputHandler = function() {
      _this.handleInput();
    };
    _this.setPointerXOffset = function(evt) {
      _this.setTransformOrigin(evt);
    };
    _this.textFieldInteractionHandler = function() {
      _this.handleTextFieldInteraction();
    };
    _this.validationAttributeChangeHandler = function(attributesList) {
      _this.handleValidationAttributeChange(attributesList);
    };
    return _this;
  }
  Object.defineProperty(MDCTextFieldFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "strings", {
    get: function() {
      return strings$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "numbers", {
    get: function() {
      return numbers$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldAlwaysFloat", {
    get: function() {
      var type2 = this.getNativeInput().type;
      return ALWAYS_FLOAT_TYPES.indexOf(type2) >= 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldFloat", {
    get: function() {
      return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() || this.isBadInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldShake", {
    get: function() {
      return !this.isFocused && !this.isValid() && !!this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return true;
        },
        setInputAttr: function() {
          return void 0;
        },
        removeInputAttr: function() {
          return void 0;
        },
        registerTextFieldInteractionHandler: function() {
          return void 0;
        },
        deregisterTextFieldInteractionHandler: function() {
          return void 0;
        },
        registerInputInteractionHandler: function() {
          return void 0;
        },
        deregisterInputInteractionHandler: function() {
          return void 0;
        },
        registerValidationAttributeChangeHandler: function() {
          return new MutationObserver(function() {
            return void 0;
          });
        },
        deregisterValidationAttributeChangeHandler: function() {
          return void 0;
        },
        getNativeInput: function() {
          return null;
        },
        isFocused: function() {
          return false;
        },
        activateLineRipple: function() {
          return void 0;
        },
        deactivateLineRipple: function() {
          return void 0;
        },
        setLineRippleTransformOrigin: function() {
          return void 0;
        },
        shakeLabel: function() {
          return void 0;
        },
        floatLabel: function() {
          return void 0;
        },
        setLabelRequired: function() {
          return void 0;
        },
        hasLabel: function() {
          return false;
        },
        getLabelWidth: function() {
          return 0;
        },
        hasOutline: function() {
          return false;
        },
        notchOutline: function() {
          return void 0;
        },
        closeOutline: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldFoundation2.prototype.init = function() {
    var e_1, _a2, e_2, _b2;
    if (this.adapter.hasLabel() && this.getNativeInput().required) {
      this.adapter.setLabelRequired(true);
    }
    if (this.adapter.isFocused()) {
      this.inputFocusHandler();
    } else if (this.adapter.hasLabel() && this.shouldFloat) {
      this.notchOutline(true);
      this.adapter.floatLabel(true);
      this.styleFloating(true);
    }
    this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler);
    this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler);
    this.adapter.registerInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var POINTERDOWN_EVENTS_1 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next(); !POINTERDOWN_EVENTS_1_1.done; POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next()) {
        var evtType = POINTERDOWN_EVENTS_1_1.value;
        this.adapter.registerInputInteractionHandler(evtType, this.setPointerXOffset);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (POINTERDOWN_EVENTS_1_1 && !POINTERDOWN_EVENTS_1_1.done && (_a2 = POINTERDOWN_EVENTS_1.return))
          _a2.call(POINTERDOWN_EVENTS_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    try {
      for (var INTERACTION_EVENTS_1 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
        var evtType = INTERACTION_EVENTS_1_1.value;
        this.adapter.registerTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_b2 = INTERACTION_EVENTS_1.return))
          _b2.call(INTERACTION_EVENTS_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    this.validationObserver = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler);
    this.setcharacterCounter(this.getValue().length);
  };
  MDCTextFieldFoundation2.prototype.destroy = function() {
    var e_3, _a2, e_4, _b2;
    this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler);
    this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler);
    this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var POINTERDOWN_EVENTS_2 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next(); !POINTERDOWN_EVENTS_2_1.done; POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next()) {
        var evtType = POINTERDOWN_EVENTS_2_1.value;
        this.adapter.deregisterInputInteractionHandler(evtType, this.setPointerXOffset);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (POINTERDOWN_EVENTS_2_1 && !POINTERDOWN_EVENTS_2_1.done && (_a2 = POINTERDOWN_EVENTS_2.return))
          _a2.call(POINTERDOWN_EVENTS_2);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    try {
      for (var INTERACTION_EVENTS_2 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
        var evtType = INTERACTION_EVENTS_2_1.value;
        this.adapter.deregisterTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_b2 = INTERACTION_EVENTS_2.return))
          _b2.call(INTERACTION_EVENTS_2);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
  };
  MDCTextFieldFoundation2.prototype.handleTextFieldInteraction = function() {
    var nativeInput = this.adapter.getNativeInput();
    if (nativeInput && nativeInput.disabled) {
      return;
    }
    this.receivedUserInput = true;
  };
  MDCTextFieldFoundation2.prototype.handleValidationAttributeChange = function(attributesList) {
    var _this = this;
    attributesList.some(function(attributeName) {
      if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
        _this.styleValidity(true);
        _this.adapter.setLabelRequired(_this.getNativeInput().required);
        return true;
      }
      return false;
    });
    if (attributesList.indexOf("maxlength") > -1) {
      this.setcharacterCounter(this.getValue().length);
    }
  };
  MDCTextFieldFoundation2.prototype.notchOutline = function(openNotch) {
    if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
      return;
    }
    if (openNotch) {
      var labelWidth = this.adapter.getLabelWidth() * numbers$1.LABEL_SCALE;
      this.adapter.notchOutline(labelWidth);
    } else {
      this.adapter.closeOutline();
    }
  };
  MDCTextFieldFoundation2.prototype.activateFocus = function() {
    this.isFocused = true;
    this.styleFocused(this.isFocused);
    this.adapter.activateLineRipple();
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      this.adapter.shakeLabel(this.shouldShake);
    }
    if (this.helperText && (this.helperText.isPersistent() || !this.helperText.isValidation() || !this.valid)) {
      this.helperText.showToScreenReader();
    }
  };
  MDCTextFieldFoundation2.prototype.setTransformOrigin = function(evt) {
    if (this.isDisabled() || this.adapter.hasOutline()) {
      return;
    }
    var touches = evt.touches;
    var targetEvent = touches ? touches[0] : evt;
    var targetClientRect = targetEvent.target.getBoundingClientRect();
    var normalizedX = targetEvent.clientX - targetClientRect.left;
    this.adapter.setLineRippleTransformOrigin(normalizedX);
  };
  MDCTextFieldFoundation2.prototype.handleInput = function() {
    this.autoCompleteFocus();
    this.setcharacterCounter(this.getValue().length);
  };
  MDCTextFieldFoundation2.prototype.autoCompleteFocus = function() {
    if (!this.receivedUserInput) {
      this.activateFocus();
    }
  };
  MDCTextFieldFoundation2.prototype.deactivateFocus = function() {
    this.isFocused = false;
    this.adapter.deactivateLineRipple();
    var isValid = this.isValid();
    this.styleValidity(isValid);
    this.styleFocused(this.isFocused);
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      this.adapter.shakeLabel(this.shouldShake);
    }
    if (!this.shouldFloat) {
      this.receivedUserInput = false;
    }
  };
  MDCTextFieldFoundation2.prototype.getValue = function() {
    return this.getNativeInput().value;
  };
  MDCTextFieldFoundation2.prototype.setValue = function(value) {
    if (this.getValue() !== value) {
      this.getNativeInput().value = value;
    }
    this.setcharacterCounter(value.length);
    if (this.validateOnValueChange) {
      var isValid = this.isValid();
      this.styleValidity(isValid);
    }
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      if (this.validateOnValueChange) {
        this.adapter.shakeLabel(this.shouldShake);
      }
    }
  };
  MDCTextFieldFoundation2.prototype.isValid = function() {
    return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
  };
  MDCTextFieldFoundation2.prototype.setValid = function(isValid) {
    this.valid = isValid;
    this.styleValidity(isValid);
    var shouldShake = !isValid && !this.isFocused && !!this.getValue();
    if (this.adapter.hasLabel()) {
      this.adapter.shakeLabel(shouldShake);
    }
  };
  MDCTextFieldFoundation2.prototype.setValidateOnValueChange = function(shouldValidate) {
    this.validateOnValueChange = shouldValidate;
  };
  MDCTextFieldFoundation2.prototype.getValidateOnValueChange = function() {
    return this.validateOnValueChange;
  };
  MDCTextFieldFoundation2.prototype.setUseNativeValidation = function(useNativeValidation) {
    this.useNativeValidation = useNativeValidation;
  };
  MDCTextFieldFoundation2.prototype.isDisabled = function() {
    return this.getNativeInput().disabled;
  };
  MDCTextFieldFoundation2.prototype.setDisabled = function(disabled) {
    this.getNativeInput().disabled = disabled;
    this.styleDisabled(disabled);
  };
  MDCTextFieldFoundation2.prototype.setHelperTextContent = function(content) {
    if (this.helperText) {
      this.helperText.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
    if (this.leadingIcon) {
      this.leadingIcon.setAriaLabel(label);
    }
  };
  MDCTextFieldFoundation2.prototype.setLeadingIconContent = function(content) {
    if (this.leadingIcon) {
      this.leadingIcon.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setTrailingIconAriaLabel = function(label) {
    if (this.trailingIcon) {
      this.trailingIcon.setAriaLabel(label);
    }
  };
  MDCTextFieldFoundation2.prototype.setTrailingIconContent = function(content) {
    if (this.trailingIcon) {
      this.trailingIcon.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setcharacterCounter = function(currentLength) {
    if (!this.characterCounter) {
      return;
    }
    var maxLength = this.getNativeInput().maxLength;
    if (maxLength === -1) {
      throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
    }
    this.characterCounter.setCounterValue(currentLength, maxLength);
  };
  MDCTextFieldFoundation2.prototype.isBadInput = function() {
    return this.getNativeInput().validity.badInput || false;
  };
  MDCTextFieldFoundation2.prototype.isNativeInputValid = function() {
    return this.getNativeInput().validity.valid;
  };
  MDCTextFieldFoundation2.prototype.styleValidity = function(isValid) {
    var INVALID = MDCTextFieldFoundation2.cssClasses.INVALID;
    if (isValid) {
      this.adapter.removeClass(INVALID);
    } else {
      this.adapter.addClass(INVALID);
    }
    if (this.helperText) {
      this.helperText.setValidity(isValid);
      var helperTextValidation = this.helperText.isValidation();
      if (!helperTextValidation) {
        return;
      }
      var helperTextVisible = this.helperText.isVisible();
      var helperTextId = this.helperText.getId();
      if (helperTextVisible && helperTextId) {
        this.adapter.setInputAttr(strings$2.ARIA_DESCRIBEDBY, helperTextId);
      } else {
        this.adapter.removeInputAttr(strings$2.ARIA_DESCRIBEDBY);
      }
    }
  };
  MDCTextFieldFoundation2.prototype.styleFocused = function(isFocused) {
    var FOCUSED = MDCTextFieldFoundation2.cssClasses.FOCUSED;
    if (isFocused) {
      this.adapter.addClass(FOCUSED);
    } else {
      this.adapter.removeClass(FOCUSED);
    }
  };
  MDCTextFieldFoundation2.prototype.styleDisabled = function(isDisabled) {
    var _a2 = MDCTextFieldFoundation2.cssClasses, DISABLED = _a2.DISABLED, INVALID = _a2.INVALID;
    if (isDisabled) {
      this.adapter.addClass(DISABLED);
      this.adapter.removeClass(INVALID);
    } else {
      this.adapter.removeClass(DISABLED);
    }
    if (this.leadingIcon) {
      this.leadingIcon.setDisabled(isDisabled);
    }
    if (this.trailingIcon) {
      this.trailingIcon.setDisabled(isDisabled);
    }
  };
  MDCTextFieldFoundation2.prototype.styleFloating = function(isFloating) {
    var LABEL_FLOATING = MDCTextFieldFoundation2.cssClasses.LABEL_FLOATING;
    if (isFloating) {
      this.adapter.addClass(LABEL_FLOATING);
    } else {
      this.adapter.removeClass(LABEL_FLOATING);
    }
  };
  MDCTextFieldFoundation2.prototype.getNativeInput = function() {
    var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
    return nativeInput || {
      disabled: false,
      maxLength: -1,
      required: false,
      type: "input",
      validity: {
        badInput: false,
        valid: true
      },
      value: ""
    };
  };
  return MDCTextFieldFoundation2;
}(MDCFoundation);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$1 = {
  HELPER_TEXT_PERSISTENT: "mdc-text-field-helper-text--persistent",
  HELPER_TEXT_VALIDATION_MSG: "mdc-text-field-helper-text--validation-msg",
  ROOT: "mdc-text-field-helper-text"
};
var strings$1 = {
  ARIA_HIDDEN: "aria-hidden",
  ROLE: "role",
  ROOT_SELECTOR: "." + cssClasses$1.ROOT
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTextFieldHelperTextFoundation = function(_super) {
  __extends(MDCTextFieldHelperTextFoundation2, _super);
  function MDCTextFieldHelperTextFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCTextFieldHelperTextFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCTextFieldHelperTextFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldHelperTextFoundation2, "strings", {
    get: function() {
      return strings$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldHelperTextFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        getAttr: function() {
          return null;
        },
        setAttr: function() {
          return void 0;
        },
        removeAttr: function() {
          return void 0;
        },
        setContent: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldHelperTextFoundation2.prototype.getId = function() {
    return this.adapter.getAttr("id");
  };
  MDCTextFieldHelperTextFoundation2.prototype.isVisible = function() {
    return this.adapter.getAttr(strings$1.ARIA_HIDDEN) !== "true";
  };
  MDCTextFieldHelperTextFoundation2.prototype.setContent = function(content) {
    this.adapter.setContent(content);
  };
  MDCTextFieldHelperTextFoundation2.prototype.isPersistent = function() {
    return this.adapter.hasClass(cssClasses$1.HELPER_TEXT_PERSISTENT);
  };
  MDCTextFieldHelperTextFoundation2.prototype.setPersistent = function(isPersistent) {
    if (isPersistent) {
      this.adapter.addClass(cssClasses$1.HELPER_TEXT_PERSISTENT);
    } else {
      this.adapter.removeClass(cssClasses$1.HELPER_TEXT_PERSISTENT);
    }
  };
  MDCTextFieldHelperTextFoundation2.prototype.isValidation = function() {
    return this.adapter.hasClass(cssClasses$1.HELPER_TEXT_VALIDATION_MSG);
  };
  MDCTextFieldHelperTextFoundation2.prototype.setValidation = function(isValidation) {
    if (isValidation) {
      this.adapter.addClass(cssClasses$1.HELPER_TEXT_VALIDATION_MSG);
    } else {
      this.adapter.removeClass(cssClasses$1.HELPER_TEXT_VALIDATION_MSG);
    }
  };
  MDCTextFieldHelperTextFoundation2.prototype.showToScreenReader = function() {
    this.adapter.removeAttr(strings$1.ARIA_HIDDEN);
  };
  MDCTextFieldHelperTextFoundation2.prototype.setValidity = function(inputIsValid) {
    var helperTextIsPersistent = this.adapter.hasClass(cssClasses$1.HELPER_TEXT_PERSISTENT);
    var helperTextIsValidationMsg = this.adapter.hasClass(cssClasses$1.HELPER_TEXT_VALIDATION_MSG);
    var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
    if (validationMsgNeedsDisplay) {
      this.showToScreenReader();
      if (this.adapter.getAttr(strings$1.ROLE) === "alert") {
        this.refreshAlertRole();
      } else {
        this.adapter.setAttr(strings$1.ROLE, "alert");
      }
    } else {
      this.adapter.removeAttr(strings$1.ROLE);
    }
    if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
      this.hide();
    }
  };
  MDCTextFieldHelperTextFoundation2.prototype.hide = function() {
    this.adapter.setAttr(strings$1.ARIA_HIDDEN, "true");
  };
  MDCTextFieldHelperTextFoundation2.prototype.refreshAlertRole = function() {
    var _this = this;
    this.adapter.removeAttr(strings$1.ROLE);
    requestAnimationFrame(function() {
      _this.adapter.setAttr(strings$1.ROLE, "alert");
    });
  };
  return MDCTextFieldHelperTextFoundation2;
}(MDCFoundation);
function create_else_block$2(ctx) {
  let label;
  let label_class_value;
  let label_style_value;
  let label_for_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let label_levels = [
    {
      class: label_class_value = classMap(__spreadValues({
        [ctx[3]]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": ctx[0],
        "mdc-floating-label--required": ctx[1]
      }, ctx[8]))
    },
    {
      style: label_style_value = Object.entries(ctx[9]).map(func_1$1).concat([ctx[4]]).join(" ")
    },
    {
      for: label_for_value = ctx[5] || (ctx[11] ? ctx[11].id : void 0)
    },
    ctx[12]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[24](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, label, ctx[2])),
          action_destroyer(ctx[10].call(null, label))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & 267 && label_class_value !== (label_class_value = classMap(__spreadValues({
          [ctx2[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx2[0],
          "mdc-floating-label--required": ctx2[1]
        }, ctx2[8])))) && { class: label_class_value },
        (!current || dirty & 528 && label_style_value !== (label_style_value = Object.entries(ctx2[9]).map(func_1$1).concat([ctx2[4]]).join(" "))) && { style: label_style_value },
        (!current || dirty & 32 && label_for_value !== (label_for_value = ctx2[5] || (ctx2[11] ? ctx2[11].id : void 0))) && { for: label_for_value },
        dirty & 4096 && ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 4)
        useActions_action.update.call(null, ctx2[2]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(label);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$9(ctx) {
  let span;
  let span_class_value;
  let span_style_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let span_levels = [
    {
      class: span_class_value = classMap(__spreadValues({
        [ctx[3]]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": ctx[0],
        "mdc-floating-label--required": ctx[1]
      }, ctx[8]))
    },
    {
      style: span_style_value = Object.entries(ctx[9]).map(func$4).concat([ctx[4]]).join(" ")
    },
    ctx[12]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[23](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, span, ctx[2])),
          action_destroyer(ctx[10].call(null, span))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & 267 && span_class_value !== (span_class_value = classMap(__spreadValues({
          [ctx2[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx2[0],
          "mdc-floating-label--required": ctx2[1]
        }, ctx2[8])))) && { class: span_class_value },
        (!current || dirty & 528 && span_style_value !== (span_style_value = Object.entries(ctx2[9]).map(func$4).concat([ctx2[4]]).join(" "))) && { style: span_style_value },
        dirty & 4096 && ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 4)
        useActions_action.update.call(null, ctx2[2]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$j(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$9, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
const func$4 = ([name, value]) => `${name}: ${value};`;
const func_1$1 = ([name, value]) => `${name}: ${value};`;
function instance_1$5($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "for",
    "floatAbove",
    "required",
    "wrapped",
    "shake",
    "float",
    "setRequired",
    "getWidth",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a2;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { for: forId = void 0 } = $$props;
  let { floatAbove = false } = $$props;
  let { required = false } = $$props;
  let { wrapped = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let inputProps = (_a2 = getContext("SMUI:generic:input:props")) !== null && _a2 !== void 0 ? _a2 : {};
  let previousFloatAbove = floatAbove;
  let previousRequired = required;
  onMount(() => {
    $$invalidate(18, instance2 = new MDCFloatingLabelFoundation({
      addClass,
      removeClass,
      getWidth: () => {
        var _a3, _b2;
        const el = getElement();
        const clone = el.cloneNode(true);
        (_a3 = el.parentNode) === null || _a3 === void 0 ? void 0 : _a3.appendChild(clone);
        clone.classList.add("smui-floating-label--remove-transition");
        clone.classList.add("smui-floating-label--force-size");
        clone.classList.remove("mdc-floating-label--float-above");
        const scrollWidth = clone.scrollWidth;
        (_b2 = el.parentNode) === null || _b2 === void 0 ? void 0 : _b2.removeChild(clone);
        return scrollWidth;
      },
      registerInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      addStyle,
      removeStyle
    };
    dispatch(element2, "SMUIFloatingLabel:mount", accessor);
    instance2.init();
    return () => {
      dispatch(element2, "SMUIFloatingLabel:unmount", accessor);
      instance2.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(9, internalStyles);
      } else {
        $$invalidate(9, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function removeStyle(name) {
    if (name in internalStyles) {
      delete internalStyles[name];
      $$invalidate(9, internalStyles);
    }
  }
  function shake(shouldShake) {
    instance2.shake(shouldShake);
  }
  function float(shouldFloat) {
    $$invalidate(0, floatAbove = shouldFloat);
  }
  function setRequired(isRequired) {
    $$invalidate(1, required = isRequired);
  }
  function getWidth() {
    return instance2.getWidth();
  }
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("for" in $$new_props)
      $$invalidate(5, forId = $$new_props.for);
    if ("floatAbove" in $$new_props)
      $$invalidate(0, floatAbove = $$new_props.floatAbove);
    if ("required" in $$new_props)
      $$invalidate(1, required = $$new_props.required);
    if ("wrapped" in $$new_props)
      $$invalidate(6, wrapped = $$new_props.wrapped);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 786433) {
      if (instance2 && previousFloatAbove !== floatAbove) {
        $$invalidate(19, previousFloatAbove = floatAbove);
        instance2.float(floatAbove);
      }
    }
    if ($$self.$$.dirty & 1310722) {
      if (instance2 && previousRequired !== required) {
        $$invalidate(20, previousRequired = required);
        instance2.setRequired(required);
      }
    }
  };
  return [
    floatAbove,
    required,
    use,
    className,
    style,
    forId,
    wrapped,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    inputProps,
    $$restProps,
    shake,
    float,
    setRequired,
    getWidth,
    getElement,
    instance2,
    previousFloatAbove,
    previousRequired,
    $$scope,
    slots,
    span_binding,
    label_binding
  ];
}
class FloatingLabel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$5, create_fragment$j, safe_not_equal, {
      use: 2,
      class: 3,
      style: 4,
      for: 5,
      floatAbove: 0,
      required: 1,
      wrapped: 6,
      shake: 13,
      float: 14,
      setRequired: 15,
      getWidth: 16,
      getElement: 17
    });
  }
  get shake() {
    return this.$$.ctx[13];
  }
  get float() {
    return this.$$.ctx[14];
  }
  get setRequired() {
    return this.$$.ctx[15];
  }
  get getWidth() {
    return this.$$.ctx[16];
  }
  get getElement() {
    return this.$$.ctx[17];
  }
}
function create_fragment$i(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let useActions_action;
  let mounted;
  let dispose;
  let div_levels = [
    {
      class: div_class_value = classMap(__spreadValues({
        [ctx[1]]: true,
        "mdc-line-ripple": true,
        "mdc-line-ripple--active": ctx[3]
      }, ctx[5]))
    },
    {
      style: div_style_value = Object.entries(ctx[6]).map(func$3).concat([ctx[2]]).join(" ")
    },
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[13](div);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(ctx[7].call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 42 && div_class_value !== (div_class_value = classMap(__spreadValues({
          [ctx2[1]]: true,
          "mdc-line-ripple": true,
          "mdc-line-ripple--active": ctx2[3]
        }, ctx2[5]))) && { class: div_class_value },
        dirty & 68 && div_style_value !== (div_style_value = Object.entries(ctx2[6]).map(func$3).concat([ctx2[2]]).join(" ")) && { style: div_style_value },
        dirty & 256 && ctx2[8]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const func$3 = ([name, value]) => `${name}: ${value};`;
function instance_1$4($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "active",
    "activate",
    "deactivate",
    "setRippleCenter",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { active: active2 = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  onMount(() => {
    instance2 = new MDCLineRippleFoundation({
      addClass,
      removeClass,
      hasClass,
      setStyle: addStyle,
      registerEventHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterEventHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    });
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(6, internalStyles);
      } else {
        $$invalidate(6, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function activate() {
    instance2.activate();
  }
  function deactivate() {
    instance2.deactivate();
  }
  function setRippleCenter(xCoordinate) {
    instance2.setRippleCenter(xCoordinate);
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("active" in $$new_props)
      $$invalidate(3, active2 = $$new_props.active);
  };
  return [
    use,
    className,
    style,
    active2,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    $$restProps,
    activate,
    deactivate,
    setRippleCenter,
    getElement,
    div_binding
  ];
}
class LineRipple extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$4, create_fragment$i, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      active: 3,
      activate: 9,
      deactivate: 10,
      setRippleCenter: 11,
      getElement: 12
    });
  }
  get activate() {
    return this.$$.ctx[9];
  }
  get deactivate() {
    return this.$$.ctx[10];
  }
  get setRippleCenter() {
    return this.$$.ctx[11];
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
function create_if_block$8(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "mdc-notched-outline__notch");
      attr(div, "style", div_style_value = Object.entries(ctx[7]).map(func$2).join(" "));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null), null);
        }
      }
      if (!current || dirty & 128 && div_style_value !== (div_style_value = Object.entries(ctx2[7]).map(func$2).join(" "))) {
        attr(div, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$h(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let div2_class_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[3] && create_if_block$8(ctx);
  let div2_levels = [
    {
      class: div2_class_value = classMap(__spreadValues({
        [ctx[1]]: true,
        "mdc-notched-outline": true,
        "mdc-notched-outline--notched": ctx[2],
        "mdc-notched-outline--no-label": ctx[3]
      }, ctx[6]))
    },
    ctx[9]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      attr(div0, "class", "mdc-notched-outline__leading");
      attr(div1, "class", "mdc-notched-outline__trailing");
      set_attributes(div2, div2_data);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t1);
      append(div2, div1);
      ctx[15](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div2, ctx[0])),
          action_destroyer(ctx[8].call(null, div2)),
          listen(div2, "SMUIFloatingLabel:mount", ctx[16]),
          listen(div2, "SMUIFloatingLabel:unmount", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & 78 && div2_class_value !== (div2_class_value = classMap(__spreadValues({
          [ctx2[1]]: true,
          "mdc-notched-outline": true,
          "mdc-notched-outline--notched": ctx2[2],
          "mdc-notched-outline--no-label": ctx2[3]
        }, ctx2[6])))) && { class: div2_class_value },
        dirty & 512 && ctx2[9]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const func$2 = ([name, value]) => `${name}: ${value};`;
function instance_1$3($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { notched = false } = $$props;
  let { noLabel = false } = $$props;
  let element2;
  let instance2;
  let floatingLabel;
  let internalClasses = {};
  let notchStyles = {};
  onMount(() => {
    instance2 = new MDCNotchedOutlineFoundation({
      addClass,
      removeClass,
      setNotchWidthProperty: (width) => addNotchStyle("width", width + "px"),
      removeNotchWidthProperty: () => removeNotchStyle("width")
    });
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function addNotchStyle(name, value) {
    if (notchStyles[name] != value) {
      if (value === "" || value == null) {
        delete notchStyles[name];
        $$invalidate(7, notchStyles);
      } else {
        $$invalidate(7, notchStyles[name] = value, notchStyles);
      }
    }
  }
  function removeNotchStyle(name) {
    if (name in notchStyles) {
      delete notchStyles[name];
      $$invalidate(7, notchStyles);
    }
  }
  function notch(notchWidth) {
    instance2.notch(notchWidth);
  }
  function closeNotch() {
    instance2.closeNotch();
  }
  function getElement() {
    return element2;
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const SMUIFloatingLabel_mount_handler = (event) => $$invalidate(4, floatingLabel = event.detail);
  const SMUIFloatingLabel_unmount_handler = () => $$invalidate(4, floatingLabel = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("notched" in $$new_props)
      $$invalidate(2, notched = $$new_props.notched);
    if ("noLabel" in $$new_props)
      $$invalidate(3, noLabel = $$new_props.noLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      if (floatingLabel) {
        floatingLabel.addStyle("transition-duration", "0s");
        addClass("mdc-notched-outline--upgraded");
        requestAnimationFrame(() => {
          if (floatingLabel) {
            floatingLabel.removeStyle("transition-duration");
          }
        });
      } else {
        removeClass("mdc-notched-outline--upgraded");
      }
    }
  };
  return [
    use,
    className,
    notched,
    noLabel,
    floatingLabel,
    element2,
    internalClasses,
    notchStyles,
    forwardEvents,
    $$restProps,
    notch,
    closeNotch,
    getElement,
    $$scope,
    slots,
    div2_binding,
    SMUIFloatingLabel_mount_handler,
    SMUIFloatingLabel_unmount_handler
  ];
}
class NotchedOutline extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$3, create_fragment$h, safe_not_equal, {
      use: 0,
      class: 1,
      notched: 2,
      noLabel: 3,
      notch: 10,
      closeNotch: 11,
      getElement: 12
    });
  }
  get notch() {
    return this.$$.ctx[10];
  }
  get closeNotch() {
    return this.$$.ctx[11];
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
var HelperLine = classAdderBuilder({
  class: "mdc-text-field-helper-line",
  component: Div
});
var Prefix = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--prefix",
  component: Span
});
var Suffix = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--suffix",
  component: Span
});
function create_fragment$g(ctx) {
  let input;
  let input_class_value;
  let useActions_action;
  let mounted;
  let dispose;
  let input_levels = [
    {
      class: input_class_value = classMap({
        [ctx[1]]: true,
        "mdc-text-field__input": true
      })
    },
    { type: ctx[2] },
    { placeholder: ctx[3] },
    ctx[4],
    ctx[6],
    ctx[10]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[26](input);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, input, ctx[0])),
          action_destroyer(ctx[7].call(null, input)),
          listen(input, "input", ctx[27]),
          listen(input, "change", ctx[9]),
          listen(input, "blur", ctx[24]),
          listen(input, "focus", ctx[25])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & 2 && input_class_value !== (input_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-text-field__input": true
        })) && { class: input_class_value },
        dirty & 4 && { type: ctx2[2] },
        dirty & 8 && { placeholder: ctx2[3] },
        dirty & 16 && ctx2[4],
        dirty & 64 && ctx2[6],
        dirty & 1024 && ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function toNumber(value) {
  if (value === "") {
    const nan = new Number(Number.NaN);
    nan.length = 0;
    return nan;
  }
  return +value;
}
function instance$c($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "type",
    "placeholder",
    "value",
    "files",
    "dirty",
    "invalid",
    "updateInvalid",
    "emptyValueNull",
    "emptyValueUndefined",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { type: type2 = "text" } = $$props;
  let { placeholder = " " } = $$props;
  let { value = uninitializedValue } = $$props;
  const valueUninitialized = isUninitializedValue(value);
  if (valueUninitialized) {
    value = "";
  }
  let { files = null } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let { emptyValueNull = value === null } = $$props;
  if (valueUninitialized && emptyValueNull) {
    value = null;
  }
  let { emptyValueUndefined = value === void 0 } = $$props;
  if (valueUninitialized && emptyValueUndefined) {
    value = void 0;
  }
  let element2;
  let internalAttrs = {};
  let valueProp = {};
  onMount(() => {
    if (updateInvalid) {
      $$invalidate(14, invalid = element2.matches(":invalid"));
    }
  });
  function valueUpdater(e) {
    if (type2 === "file") {
      $$invalidate(12, files = e.currentTarget.files);
      return;
    }
    if (e.currentTarget.value === "" && emptyValueNull) {
      $$invalidate(11, value = null);
      return;
    }
    if (e.currentTarget.value === "" && emptyValueUndefined) {
      $$invalidate(11, value = void 0);
      return;
    }
    switch (type2) {
      case "number":
      case "range":
        $$invalidate(11, value = toNumber(e.currentTarget.value));
        break;
      default:
        $$invalidate(11, value = e.currentTarget.value);
        break;
    }
  }
  function changeHandler(e) {
    if (type2 === "file" || type2 === "range") {
      valueUpdater(e);
    }
    $$invalidate(13, dirty = true);
    if (updateInvalid) {
      $$invalidate(14, invalid = element2.matches(":invalid"));
    }
  }
  function getAttr(name) {
    var _a2;
    return name in internalAttrs ? (_a2 = internalAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function focus() {
    getElement().focus();
  }
  function blur() {
    getElement().blur();
  }
  function getElement() {
    return element2;
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const input_handler = (e) => type2 !== "file" && valueUpdater(e);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(2, type2 = $$new_props.type);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(11, value = $$new_props.value);
    if ("files" in $$new_props)
      $$invalidate(12, files = $$new_props.files);
    if ("dirty" in $$new_props)
      $$invalidate(13, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(14, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    if ("emptyValueNull" in $$new_props)
      $$invalidate(16, emptyValueNull = $$new_props.emptyValueNull);
    if ("emptyValueUndefined" in $$new_props)
      $$invalidate(17, emptyValueUndefined = $$new_props.emptyValueUndefined);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2068) {
      if (type2 === "file") {
        delete valueProp.value;
        $$invalidate(4, valueProp), $$invalidate(2, type2), $$invalidate(11, value);
      } else {
        $$invalidate(4, valueProp.value = value == null ? "" : value, valueProp);
      }
    }
  };
  return [
    use,
    className,
    type2,
    placeholder,
    valueProp,
    element2,
    internalAttrs,
    forwardEvents,
    valueUpdater,
    changeHandler,
    $$restProps,
    value,
    files,
    dirty,
    invalid,
    updateInvalid,
    emptyValueNull,
    emptyValueUndefined,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement,
    blur_handler,
    focus_handler,
    input_binding,
    input_handler
  ];
}
class Input extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$g, safe_not_equal, {
      use: 0,
      class: 1,
      type: 2,
      placeholder: 3,
      value: 11,
      files: 12,
      dirty: 13,
      invalid: 14,
      updateInvalid: 15,
      emptyValueNull: 16,
      emptyValueUndefined: 17,
      getAttr: 18,
      addAttr: 19,
      removeAttr: 20,
      focus: 21,
      blur: 22,
      getElement: 23
    });
  }
  get getAttr() {
    return this.$$.ctx[18];
  }
  get addAttr() {
    return this.$$.ctx[19];
  }
  get removeAttr() {
    return this.$$.ctx[20];
  }
  get focus() {
    return this.$$.ctx[21];
  }
  get blur() {
    return this.$$.ctx[22];
  }
  get getElement() {
    return this.$$.ctx[23];
  }
}
function create_fragment$f(ctx) {
  let textarea;
  let textarea_class_value;
  let textarea_style_value;
  let useActions_action;
  let mounted;
  let dispose;
  let textarea_levels = [
    {
      class: textarea_class_value = classMap({
        [ctx[2]]: true,
        "mdc-text-field__input": true
      })
    },
    {
      style: textarea_style_value = `${ctx[4] ? "" : "resize: none; "}${ctx[3]}`
    },
    ctx[6],
    ctx[9]
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  return {
    c() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      ctx[21](textarea);
      set_input_value(textarea, ctx[0]);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, textarea, ctx[1])),
          action_destroyer(ctx[7].call(null, textarea)),
          listen(textarea, "change", ctx[8]),
          listen(textarea, "blur", ctx[19]),
          listen(textarea, "focus", ctx[20]),
          listen(textarea, "input", ctx[22])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & 4 && textarea_class_value !== (textarea_class_value = classMap({
          [ctx2[2]]: true,
          "mdc-text-field__input": true
        })) && { class: textarea_class_value },
        dirty & 24 && textarea_style_value !== (textarea_style_value = `${ctx2[4] ? "" : "resize: none; "}${ctx2[3]}`) && { style: textarea_style_value },
        dirty & 64 && ctx2[6],
        dirty & 512 && ctx2[9]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 2)
        useActions_action.update.call(null, ctx2[1]);
      if (dirty & 1) {
        set_input_value(textarea, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(textarea);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "value",
    "dirty",
    "invalid",
    "updateInvalid",
    "resizable",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { value = "" } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let { resizable = true } = $$props;
  let element2;
  let internalAttrs = {};
  onMount(() => {
    if (updateInvalid) {
      $$invalidate(11, invalid = element2.matches(":invalid"));
    }
  });
  function changeHandler() {
    $$invalidate(10, dirty = true);
    if (updateInvalid) {
      $$invalidate(11, invalid = element2.matches(":invalid"));
    }
  }
  function getAttr(name) {
    var _a2;
    return name in internalAttrs ? (_a2 = internalAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function focus() {
    getElement().focus();
  }
  function blur() {
    getElement().blur();
  }
  function getElement() {
    return element2;
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(3, style = $$new_props.style);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("dirty" in $$new_props)
      $$invalidate(10, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
    if ("resizable" in $$new_props)
      $$invalidate(4, resizable = $$new_props.resizable);
  };
  return [
    value,
    use,
    className,
    style,
    resizable,
    element2,
    internalAttrs,
    forwardEvents,
    changeHandler,
    $$restProps,
    dirty,
    invalid,
    updateInvalid,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement,
    blur_handler,
    focus_handler,
    textarea_binding,
    textarea_input_handler
  ];
}
class Textarea extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$f, safe_not_equal, {
      use: 1,
      class: 2,
      style: 3,
      value: 0,
      dirty: 10,
      invalid: 11,
      updateInvalid: 12,
      resizable: 4,
      getAttr: 13,
      addAttr: 14,
      removeAttr: 15,
      focus: 16,
      blur: 17,
      getElement: 18
    });
  }
  get getAttr() {
    return this.$$.ctx[13];
  }
  get addAttr() {
    return this.$$.ctx[14];
  }
  get removeAttr() {
    return this.$$.ctx[15];
  }
  get focus() {
    return this.$$.ctx[16];
  }
  get blur() {
    return this.$$.ctx[17];
  }
  get getElement() {
    return this.$$.ctx[18];
  }
}
const get_helper_slot_changes = (dirty) => ({});
const get_helper_slot_context = (ctx) => ({});
const get_ripple_slot_changes = (dirty) => ({});
const get_ripple_slot_context = (ctx) => ({});
const get_trailingIcon_slot_changes_1 = (dirty) => ({});
const get_trailingIcon_slot_context_1 = (ctx) => ({});
const get_leadingIcon_slot_changes_1 = (dirty) => ({});
const get_leadingIcon_slot_context_1 = (ctx) => ({});
const get_label_slot_changes_2 = (dirty) => ({});
const get_label_slot_context_2 = (ctx) => ({});
const get_trailingIcon_slot_changes = (dirty) => ({});
const get_trailingIcon_slot_context = (ctx) => ({});
const get_suffix_slot_changes = (dirty) => ({});
const get_suffix_slot_context = (ctx) => ({});
const get_prefix_slot_changes = (dirty) => ({});
const get_prefix_slot_context = (ctx) => ({});
const get_internalCounter_slot_changes = (dirty) => ({});
const get_internalCounter_slot_context = (ctx) => ({});
const get_leadingIcon_slot_changes = (dirty) => ({});
const get_leadingIcon_slot_context = (ctx) => ({});
const get_label_slot_changes_1 = (dirty) => ({});
const get_label_slot_context_1 = (ctx) => ({});
const get_label_slot_changes = (dirty) => ({});
const get_label_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let div;
  let t0;
  let contextfragment0;
  let t1;
  let t2;
  let contextfragment1;
  let t3;
  let div_class_value;
  let div_style_value;
  let Ripple_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context_2);
  contextfragment0 = new ContextFragment({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: true,
      $$slots: { default: [create_default_slot_9$3] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = ctx[51].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[90], null);
  contextfragment1 = new ContextFragment({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: false,
      $$slots: { default: [create_default_slot_8$3] },
      $$scope: { ctx }
    }
  });
  const ripple_slot_template = ctx[51].ripple;
  const ripple_slot = create_slot(ripple_slot_template, ctx, ctx[90], get_ripple_slot_context);
  let div_levels = [
    {
      class: div_class_value = classMap(__spreadValues({
        [ctx[9]]: true,
        "mdc-text-field": true,
        "mdc-text-field--disabled": ctx[12],
        "mdc-text-field--textarea": ctx[14],
        "mdc-text-field--filled": ctx[15] === "filled",
        "mdc-text-field--outlined": ctx[15] === "outlined",
        "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
        "mdc-text-field--no-label": ctx[16] || !ctx[42].label,
        "mdc-text-field--with-leading-icon": ctx[42].leadingIcon,
        "mdc-text-field--with-trailing-icon": ctx[42].trailingIcon,
        "mdc-text-field--invalid": ctx[1]
      }, ctx[25]))
    },
    {
      style: div_style_value = Object.entries(ctx[26]).map(func_1).concat([ctx[10]]).join(" ")
    },
    exclude(ctx[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      create_component(contextfragment0.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(contextfragment1.$$.fragment);
      t3 = space();
      if (ripple_slot)
        ripple_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (label_slot) {
        label_slot.m(div, null);
      }
      append(div, t0);
      mount_component(contextfragment0, div, null);
      append(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t2);
      mount_component(contextfragment1, div, null);
      append(div, t3);
      if (ripple_slot) {
        ripple_slot.m(div, null);
      }
      ctx[80](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(Ripple_action = Ripple.call(null, div, {
            ripple: ctx[11],
            unbounded: false,
            addClass: ctx[38],
            removeClass: ctx[39],
            addStyle: ctx[40]
          })),
          action_destroyer(useActions_action = useActions.call(null, div, ctx[8])),
          action_destroyer(ctx[34].call(null, div)),
          listen(div, "SMUITextfieldLeadingIcon:mount", ctx[81]),
          listen(div, "SMUITextfieldLeadingIcon:unmount", ctx[82]),
          listen(div, "SMUITextfieldTrailingIcon:mount", ctx[83]),
          listen(div, "SMUITextfieldTrailingIcon:unmount", ctx[84])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(label_slot, label_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes_2), get_label_slot_context_2);
        }
      }
      const contextfragment0_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment0.$set(contextfragment0_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(default_slot_template, ctx2[90], dirty, null), null);
        }
      }
      const contextfragment1_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment1.$set(contextfragment1_changes);
      if (ripple_slot) {
        if (ripple_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(ripple_slot, ripple_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(ripple_slot_template, ctx2[90], dirty, get_ripple_slot_changes), get_ripple_slot_context);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & 33673730 | dirty[1] & 2048 && div_class_value !== (div_class_value = classMap(__spreadValues({
          [ctx2[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx2[12],
          "mdc-text-field--textarea": ctx2[14],
          "mdc-text-field--filled": ctx2[15] === "filled",
          "mdc-text-field--outlined": ctx2[15] === "outlined",
          "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
          "mdc-text-field--no-label": ctx2[16] || !ctx2[42].label,
          "mdc-text-field--with-leading-icon": ctx2[42].leadingIcon,
          "mdc-text-field--with-trailing-icon": ctx2[42].trailingIcon,
          "mdc-text-field--invalid": ctx2[1]
        }, ctx2[25])))) && { class: div_class_value },
        (!current || dirty[0] & 67109888 && div_style_value !== (div_style_value = Object.entries(ctx2[26]).map(func_1).concat([ctx2[10]]).join(" "))) && { style: div_style_value },
        dirty[1] & 1024 && exclude(ctx2[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 2048)
        Ripple_action.update.call(null, {
          ripple: ctx2[11],
          unbounded: false,
          addClass: ctx2[38],
          removeClass: ctx2[39],
          addStyle: ctx2[40]
        });
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
        useActions_action.update.call(null, ctx2[8]);
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(contextfragment0.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(contextfragment1.$$.fragment, local);
      transition_in(ripple_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(contextfragment0.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(contextfragment1.$$.fragment, local);
      transition_out(ripple_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (label_slot)
        label_slot.d(detaching);
      destroy_component(contextfragment0);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(contextfragment1);
      if (ripple_slot)
        ripple_slot.d(detaching);
      ctx[80](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$2(ctx) {
  let label_1;
  let t0;
  let t1;
  let contextfragment0;
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let contextfragment1;
  let t5;
  let label_1_class_value;
  let label_1_style_value;
  let Ripple_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[14] && ctx[15] !== "outlined" && create_if_block_8(ctx);
  let if_block1 = (ctx[14] || ctx[15] === "outlined") && create_if_block_6(ctx);
  contextfragment0 = new ContextFragment({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: true,
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = ctx[51].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[90], null);
  const if_block_creators = [create_if_block_3, create_else_block$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[14] && typeof ctx2[0] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  contextfragment1 = new ContextFragment({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: false,
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  let if_block3 = !ctx[14] && ctx[15] !== "outlined" && ctx[11] && create_if_block_2(ctx);
  let label_1_levels = [
    {
      class: label_1_class_value = classMap(__spreadValues({
        [ctx[9]]: true,
        "mdc-text-field": true,
        "mdc-text-field--disabled": ctx[12],
        "mdc-text-field--textarea": ctx[14],
        "mdc-text-field--filled": ctx[15] === "filled",
        "mdc-text-field--outlined": ctx[15] === "outlined",
        "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
        "mdc-text-field--no-label": ctx[16] || ctx[17] == null && !ctx[42].label,
        "mdc-text-field--label-floating": ctx[28] || ctx[0] != null && ctx[0] !== "",
        "mdc-text-field--with-leading-icon": ctx[35](ctx[22]) ? ctx[42].leadingIcon : ctx[22],
        "mdc-text-field--with-trailing-icon": ctx[35](ctx[23]) ? ctx[42].trailingIcon : ctx[23],
        "mdc-text-field--with-internal-counter": ctx[14] && ctx[42].internalCounter,
        "mdc-text-field--invalid": ctx[1]
      }, ctx[25]))
    },
    {
      style: label_1_style_value = Object.entries(ctx[26]).map(func$1).concat([ctx[10]]).join(" ")
    },
    {
      for: void 0
    },
    exclude(ctx[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
  ];
  let label_1_data = {};
  for (let i = 0; i < label_1_levels.length; i += 1) {
    label_1_data = assign(label_1_data, label_1_levels[i]);
  }
  return {
    c() {
      label_1 = element("label");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(contextfragment0.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      create_component(contextfragment1.$$.fragment);
      t5 = space();
      if (if_block3)
        if_block3.c();
      set_attributes(label_1, label_1_data);
    },
    m(target, anchor) {
      insert(target, label_1, anchor);
      if (if_block0)
        if_block0.m(label_1, null);
      append(label_1, t0);
      if (if_block1)
        if_block1.m(label_1, null);
      append(label_1, t1);
      mount_component(contextfragment0, label_1, null);
      append(label_1, t2);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      append(label_1, t3);
      if_blocks[current_block_type_index].m(label_1, null);
      append(label_1, t4);
      mount_component(contextfragment1, label_1, null);
      append(label_1, t5);
      if (if_block3)
        if_block3.m(label_1, null);
      ctx[73](label_1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(Ripple_action = Ripple.call(null, label_1, {
            ripple: !ctx[14] && ctx[15] === "filled",
            unbounded: false,
            addClass: ctx[38],
            removeClass: ctx[39],
            addStyle: ctx[40],
            eventTarget: ctx[33],
            activeTarget: ctx[33],
            initPromise: ctx[37]
          })),
          action_destroyer(useActions_action = useActions.call(null, label_1, ctx[8])),
          action_destroyer(ctx[34].call(null, label_1)),
          listen(label_1, "SMUITextfieldLeadingIcon:mount", ctx[74]),
          listen(label_1, "SMUITextfieldLeadingIcon:unmount", ctx[75]),
          listen(label_1, "SMUITextfieldTrailingIcon:mount", ctx[76]),
          listen(label_1, "SMUITextfieldTrailingIcon:unmount", ctx[77]),
          listen(label_1, "SMUITextfieldCharacterCounter:mount", ctx[78]),
          listen(label_1, "SMUITextfieldCharacterCounter:unmount", ctx[79])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!ctx2[14] && ctx2[15] !== "outlined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 49152) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(label_1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[14] || ctx2[15] === "outlined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 49152) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label_1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const contextfragment0_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment0.$set(contextfragment0_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(default_slot_template, ctx2[90], dirty, null), null);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(label_1, t4);
      }
      const contextfragment1_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment1.$set(contextfragment1_changes);
      if (!ctx2[14] && ctx2[15] !== "outlined" && ctx2[11]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 51200) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(label_1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
        (!current || dirty[0] & 314823171 | dirty[1] & 2048 && label_1_class_value !== (label_1_class_value = classMap(__spreadValues({
          [ctx2[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx2[12],
          "mdc-text-field--textarea": ctx2[14],
          "mdc-text-field--filled": ctx2[15] === "filled",
          "mdc-text-field--outlined": ctx2[15] === "outlined",
          "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
          "mdc-text-field--no-label": ctx2[16] || ctx2[17] == null && !ctx2[42].label,
          "mdc-text-field--label-floating": ctx2[28] || ctx2[0] != null && ctx2[0] !== "",
          "mdc-text-field--with-leading-icon": ctx2[35](ctx2[22]) ? ctx2[42].leadingIcon : ctx2[22],
          "mdc-text-field--with-trailing-icon": ctx2[35](ctx2[23]) ? ctx2[42].trailingIcon : ctx2[23],
          "mdc-text-field--with-internal-counter": ctx2[14] && ctx2[42].internalCounter,
          "mdc-text-field--invalid": ctx2[1]
        }, ctx2[25])))) && { class: label_1_class_value },
        (!current || dirty[0] & 67109888 && label_1_style_value !== (label_1_style_value = Object.entries(ctx2[26]).map(func$1).concat([ctx2[10]]).join(" "))) && { style: label_1_style_value },
        {
          for: void 0
        },
        dirty[1] & 1024 && exclude(ctx2[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 49152 | dirty[1] & 4)
        Ripple_action.update.call(null, {
          ripple: !ctx2[14] && ctx2[15] === "filled",
          unbounded: false,
          addClass: ctx2[38],
          removeClass: ctx2[39],
          addStyle: ctx2[40],
          eventTarget: ctx2[33],
          activeTarget: ctx2[33],
          initPromise: ctx2[37]
        });
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
        useActions_action.update.call(null, ctx2[8]);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(contextfragment0.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(contextfragment1.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(contextfragment0.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(contextfragment1.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(label_1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(contextfragment0);
      if (default_slot)
        default_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      destroy_component(contextfragment1);
      if (if_block3)
        if_block3.d();
      ctx[73](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_9$3(ctx) {
  let current;
  const leadingIcon_slot_template = ctx[51].leadingIcon;
  const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[90], get_leadingIcon_slot_context_1);
  return {
    c() {
      if (leadingIcon_slot)
        leadingIcon_slot.c();
    },
    m(target, anchor) {
      if (leadingIcon_slot) {
        leadingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(leadingIcon_slot_template, ctx2[90], dirty, get_leadingIcon_slot_changes_1), get_leadingIcon_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leadingIcon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leadingIcon_slot, local);
      current = false;
    },
    d(detaching) {
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
    }
  };
}
function create_default_slot_8$3(ctx) {
  let current;
  const trailingIcon_slot_template = ctx[51].trailingIcon;
  const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[90], get_trailingIcon_slot_context_1);
  return {
    c() {
      if (trailingIcon_slot)
        trailingIcon_slot.c();
    },
    m(target, anchor) {
      if (trailingIcon_slot) {
        trailingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailingIcon_slot) {
        if (trailingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(trailingIcon_slot, trailingIcon_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(trailingIcon_slot_template, ctx2[90], dirty, get_trailingIcon_slot_changes_1), get_trailingIcon_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailingIcon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailingIcon_slot, local);
      current = false;
    },
    d(detaching) {
      if (trailingIcon_slot)
        trailingIcon_slot.d(detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[15] === "filled" && create_if_block_10();
  let if_block1 = !ctx[16] && (ctx[17] != null || ctx[42].label) && create_if_block_9(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[15] === "filled") {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_10();
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[16] && (ctx2[17] != null || ctx2[42].label)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 196608 | dirty[1] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block_10(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "mdc-text-field__ripple");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_9(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    {
      floatAbove: ctx[28] || ctx[0] != null && ctx[0] !== ""
    },
    { required: ctx[13] },
    { wrapped: true },
    prefixFilter(ctx[41], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_7$3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new FloatingLabel({ props: floatinglabel_props });
  ctx[52](floatinglabel);
  return {
    c() {
      create_component(floatinglabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 268443649 | dirty[1] & 1024 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 268435457 && {
          floatAbove: ctx2[28] || ctx2[0] != null && ctx2[0] !== ""
        },
        dirty[0] & 8192 && { required: ctx2[13] },
        floatinglabel_spread_levels[2],
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "label$"))
      ]) : {};
      if (dirty[0] & 131072 | dirty[2] & 268435456) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[52](null);
      destroy_component(floatinglabel, detaching);
    }
  };
}
function create_default_slot_7$3(ctx) {
  let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
  let t;
  let current;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context);
  return {
    c() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      insert(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
        set_data(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(label_slot, label_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes), get_label_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let notchedoutline;
  let current;
  const notchedoutline_spread_levels = [
    {
      noLabel: ctx[16] || ctx[17] == null && !ctx[42].label
    },
    prefixFilter(ctx[41], "outline$")
  ];
  let notchedoutline_props = {
    $$slots: { default: [create_default_slot_5$3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
  }
  notchedoutline = new NotchedOutline({ props: notchedoutline_props });
  ctx[54](notchedoutline);
  return {
    c() {
      create_component(notchedoutline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notchedoutline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notchedoutline_changes = dirty[0] & 196608 | dirty[1] & 3072 ? get_spread_update(notchedoutline_spread_levels, [
        dirty[0] & 196608 | dirty[1] & 2048 && {
          noLabel: ctx2[16] || ctx2[17] == null && !ctx2[42].label
        },
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "outline$"))
      ]) : {};
      if (dirty[0] & 268640289 | dirty[1] & 3072 | dirty[2] & 268435456) {
        notchedoutline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notchedoutline.$set(notchedoutline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notchedoutline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notchedoutline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[54](null);
      destroy_component(notchedoutline, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    {
      floatAbove: ctx[28] || ctx[0] != null && ctx[0] !== ""
    },
    { required: ctx[13] },
    { wrapped: true },
    prefixFilter(ctx[41], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_6$3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new FloatingLabel({ props: floatinglabel_props });
  ctx[53](floatinglabel);
  return {
    c() {
      create_component(floatinglabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 268443649 | dirty[1] & 1024 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 268435457 && {
          floatAbove: ctx2[28] || ctx2[0] != null && ctx2[0] !== ""
        },
        dirty[0] & 8192 && { required: ctx2[13] },
        floatinglabel_spread_levels[2],
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "label$"))
      ]) : {};
      if (dirty[0] & 131072 | dirty[2] & 268435456) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[53](null);
      destroy_component(floatinglabel, detaching);
    }
  };
}
function create_default_slot_6$3(ctx) {
  let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
  let t;
  let current;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context_1);
  return {
    c() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      insert(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
        set_data(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(label_slot, label_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes_1), get_label_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !ctx[16] && (ctx[17] != null || ctx[42].label) && create_if_block_7(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[16] && (ctx2[17] != null || ctx2[42].label)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 196608 | dirty[1] & 2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_4$4(ctx) {
  let current;
  const leadingIcon_slot_template = ctx[51].leadingIcon;
  const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[90], get_leadingIcon_slot_context);
  return {
    c() {
      if (leadingIcon_slot)
        leadingIcon_slot.c();
    },
    m(target, anchor) {
      if (leadingIcon_slot) {
        leadingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(leadingIcon_slot_template, ctx2[90], dirty, get_leadingIcon_slot_changes), get_leadingIcon_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leadingIcon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leadingIcon_slot, local);
      current = false;
    },
    d(detaching) {
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
    }
  };
}
function create_else_block$1(ctx) {
  let t0;
  let t1;
  let input_1;
  let updating_value;
  let updating_files;
  let updating_dirty;
  let updating_invalid;
  let t2;
  let t3;
  let current;
  const prefix_slot_template = ctx[51].prefix;
  const prefix_slot = create_slot(prefix_slot_template, ctx, ctx[90], get_prefix_slot_context);
  let if_block0 = ctx[20] != null && create_if_block_5(ctx);
  const input_1_spread_levels = [
    { type: ctx[18] },
    { disabled: ctx[12] },
    { required: ctx[13] },
    { updateInvalid: ctx[19] },
    { "aria-controls": ctx[27] },
    { "aria-describedby": ctx[27] },
    ctx[16] && ctx[17] != null ? { placeholder: ctx[17] } : {},
    prefixFilter(ctx[41], "input$")
  ];
  function input_1_value_binding(value) {
    ctx[64](value);
  }
  function input_1_files_binding(value) {
    ctx[65](value);
  }
  function input_1_dirty_binding(value) {
    ctx[66](value);
  }
  function input_1_invalid_binding(value) {
    ctx[67](value);
  }
  let input_1_props = {};
  for (let i = 0; i < input_1_spread_levels.length; i += 1) {
    input_1_props = assign(input_1_props, input_1_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    input_1_props.value = ctx[0];
  }
  if (ctx[3] !== void 0) {
    input_1_props.files = ctx[3];
  }
  if (ctx[4] !== void 0) {
    input_1_props.dirty = ctx[4];
  }
  if (ctx[1] !== void 0) {
    input_1_props.invalid = ctx[1];
  }
  input_1 = new Input({ props: input_1_props });
  ctx[63](input_1);
  binding_callbacks.push(() => bind(input_1, "value", input_1_value_binding));
  binding_callbacks.push(() => bind(input_1, "files", input_1_files_binding));
  binding_callbacks.push(() => bind(input_1, "dirty", input_1_dirty_binding));
  binding_callbacks.push(() => bind(input_1, "invalid", input_1_invalid_binding));
  input_1.$on("blur", ctx[68]);
  input_1.$on("focus", ctx[69]);
  input_1.$on("blur", ctx[70]);
  input_1.$on("focus", ctx[71]);
  let if_block1 = ctx[21] != null && create_if_block_4(ctx);
  const suffix_slot_template = ctx[51].suffix;
  const suffix_slot = create_slot(suffix_slot_template, ctx, ctx[90], get_suffix_slot_context);
  return {
    c() {
      if (prefix_slot)
        prefix_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(input_1.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (suffix_slot)
        suffix_slot.c();
    },
    m(target, anchor) {
      if (prefix_slot) {
        prefix_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(input_1, target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (suffix_slot) {
        suffix_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (prefix_slot) {
        if (prefix_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(prefix_slot, prefix_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(prefix_slot_template, ctx2[90], dirty, get_prefix_slot_changes), get_prefix_slot_context);
        }
      }
      if (ctx2[20] != null) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 1048576) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const input_1_changes = dirty[0] & 135213056 | dirty[1] & 1024 ? get_spread_update(input_1_spread_levels, [
        dirty[0] & 262144 && { type: ctx2[18] },
        dirty[0] & 4096 && { disabled: ctx2[12] },
        dirty[0] & 8192 && { required: ctx2[13] },
        dirty[0] & 524288 && { updateInvalid: ctx2[19] },
        dirty[0] & 134217728 && { "aria-controls": ctx2[27] },
        dirty[0] & 134217728 && { "aria-describedby": ctx2[27] },
        dirty[0] & 196608 && get_spread_object(ctx2[16] && ctx2[17] != null ? { placeholder: ctx2[17] } : {}),
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "input$"))
      ]) : {};
      if (!updating_value && dirty[0] & 1) {
        updating_value = true;
        input_1_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_files && dirty[0] & 8) {
        updating_files = true;
        input_1_changes.files = ctx2[3];
        add_flush_callback(() => updating_files = false);
      }
      if (!updating_dirty && dirty[0] & 16) {
        updating_dirty = true;
        input_1_changes.dirty = ctx2[4];
        add_flush_callback(() => updating_dirty = false);
      }
      if (!updating_invalid && dirty[0] & 2) {
        updating_invalid = true;
        input_1_changes.invalid = ctx2[1];
        add_flush_callback(() => updating_invalid = false);
      }
      input_1.$set(input_1_changes);
      if (ctx2[21] != null) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 2097152) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (suffix_slot) {
        if (suffix_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(suffix_slot, suffix_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(suffix_slot_template, ctx2[90], dirty, get_suffix_slot_changes), get_suffix_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(prefix_slot, local);
      transition_in(if_block0);
      transition_in(input_1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(suffix_slot, local);
      current = true;
    },
    o(local) {
      transition_out(prefix_slot, local);
      transition_out(if_block0);
      transition_out(input_1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(suffix_slot, local);
      current = false;
    },
    d(detaching) {
      if (prefix_slot)
        prefix_slot.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      ctx[63](null);
      destroy_component(input_1, detaching);
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t3);
      if (suffix_slot)
        suffix_slot.d(detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let span;
  let textarea_1;
  let updating_value;
  let updating_dirty;
  let updating_invalid;
  let t;
  let span_class_value;
  let current;
  const textarea_1_spread_levels = [
    { disabled: ctx[12] },
    { required: ctx[13] },
    { updateInvalid: ctx[19] },
    { "aria-controls": ctx[27] },
    { "aria-describedby": ctx[27] },
    prefixFilter(ctx[41], "input$")
  ];
  function textarea_1_value_binding(value) {
    ctx[56](value);
  }
  function textarea_1_dirty_binding(value) {
    ctx[57](value);
  }
  function textarea_1_invalid_binding(value) {
    ctx[58](value);
  }
  let textarea_1_props = {};
  for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
    textarea_1_props = assign(textarea_1_props, textarea_1_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    textarea_1_props.value = ctx[0];
  }
  if (ctx[4] !== void 0) {
    textarea_1_props.dirty = ctx[4];
  }
  if (ctx[1] !== void 0) {
    textarea_1_props.invalid = ctx[1];
  }
  textarea_1 = new Textarea({ props: textarea_1_props });
  ctx[55](textarea_1);
  binding_callbacks.push(() => bind(textarea_1, "value", textarea_1_value_binding));
  binding_callbacks.push(() => bind(textarea_1, "dirty", textarea_1_dirty_binding));
  binding_callbacks.push(() => bind(textarea_1, "invalid", textarea_1_invalid_binding));
  textarea_1.$on("blur", ctx[59]);
  textarea_1.$on("focus", ctx[60]);
  textarea_1.$on("blur", ctx[61]);
  textarea_1.$on("focus", ctx[62]);
  const internalCounter_slot_template = ctx[51].internalCounter;
  const internalCounter_slot = create_slot(internalCounter_slot_template, ctx, ctx[90], get_internalCounter_slot_context);
  return {
    c() {
      span = element("span");
      create_component(textarea_1.$$.fragment);
      t = space();
      if (internalCounter_slot)
        internalCounter_slot.c();
      attr(span, "class", span_class_value = classMap({
        "mdc-text-field__resizer": !("input$resizable" in ctx[41]) || ctx[41].input$resizable
      }));
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(textarea_1, span, null);
      append(span, t);
      if (internalCounter_slot) {
        internalCounter_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const textarea_1_changes = dirty[0] & 134754304 | dirty[1] & 1024 ? get_spread_update(textarea_1_spread_levels, [
        dirty[0] & 4096 && { disabled: ctx2[12] },
        dirty[0] & 8192 && { required: ctx2[13] },
        dirty[0] & 524288 && { updateInvalid: ctx2[19] },
        dirty[0] & 134217728 && { "aria-controls": ctx2[27] },
        dirty[0] & 134217728 && { "aria-describedby": ctx2[27] },
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "input$"))
      ]) : {};
      if (!updating_value && dirty[0] & 1) {
        updating_value = true;
        textarea_1_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_dirty && dirty[0] & 16) {
        updating_dirty = true;
        textarea_1_changes.dirty = ctx2[4];
        add_flush_callback(() => updating_dirty = false);
      }
      if (!updating_invalid && dirty[0] & 2) {
        updating_invalid = true;
        textarea_1_changes.invalid = ctx2[1];
        add_flush_callback(() => updating_invalid = false);
      }
      textarea_1.$set(textarea_1_changes);
      if (internalCounter_slot) {
        if (internalCounter_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(internalCounter_slot, internalCounter_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(internalCounter_slot_template, ctx2[90], dirty, get_internalCounter_slot_changes), get_internalCounter_slot_context);
        }
      }
      if (!current || dirty[1] & 1024 && span_class_value !== (span_class_value = classMap({
        "mdc-text-field__resizer": !("input$resizable" in ctx2[41]) || ctx2[41].input$resizable
      }))) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea_1.$$.fragment, local);
      transition_in(internalCounter_slot, local);
      current = true;
    },
    o(local) {
      transition_out(textarea_1.$$.fragment, local);
      transition_out(internalCounter_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      ctx[55](null);
      destroy_component(textarea_1);
      if (internalCounter_slot)
        internalCounter_slot.d(detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let prefix_1;
  let current;
  prefix_1 = new Prefix({
    props: {
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(prefix_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(prefix_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const prefix_1_changes = {};
      if (dirty[0] & 1048576 | dirty[2] & 268435456) {
        prefix_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      prefix_1.$set(prefix_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(prefix_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prefix_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(prefix_1, detaching);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[20]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1048576)
        set_data(t, ctx2[20]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4(ctx) {
  let suffix_1;
  let current;
  suffix_1 = new Suffix({
    props: {
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(suffix_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suffix_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const suffix_1_changes = {};
      if (dirty[0] & 2097152 | dirty[2] & 268435456) {
        suffix_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suffix_1.$set(suffix_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suffix_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suffix_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suffix_1, detaching);
    }
  };
}
function create_default_slot_2$4(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[21]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2097152)
        set_data(t, ctx2[21]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let current;
  const trailingIcon_slot_template = ctx[51].trailingIcon;
  const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[90], get_trailingIcon_slot_context);
  return {
    c() {
      if (trailingIcon_slot)
        trailingIcon_slot.c();
    },
    m(target, anchor) {
      if (trailingIcon_slot) {
        trailingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailingIcon_slot) {
        if (trailingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(trailingIcon_slot, trailingIcon_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(trailingIcon_slot_template, ctx2[90], dirty, get_trailingIcon_slot_changes), get_trailingIcon_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailingIcon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailingIcon_slot, local);
      current = false;
    },
    d(detaching) {
      if (trailingIcon_slot)
        trailingIcon_slot.d(detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let lineripple;
  let current;
  const lineripple_spread_levels = [prefixFilter(ctx[41], "ripple$")];
  let lineripple_props = {};
  for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
  }
  lineripple = new LineRipple({ props: lineripple_props });
  ctx[72](lineripple);
  return {
    c() {
      create_component(lineripple.$$.fragment);
    },
    m(target, anchor) {
      mount_component(lineripple, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const lineripple_changes = dirty[1] & 1024 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(ctx2[41], "ripple$"))]) : {};
      lineripple.$set(lineripple_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(lineripple.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(lineripple.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[72](null);
      destroy_component(lineripple, detaching);
    }
  };
}
function create_if_block$7(ctx) {
  let helperline;
  let current;
  const helperline_spread_levels = [prefixFilter(ctx[41], "helperLine$")];
  let helperline_props = {
    $$slots: { default: [create_default_slot$6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < helperline_spread_levels.length; i += 1) {
    helperline_props = assign(helperline_props, helperline_spread_levels[i]);
  }
  helperline = new HelperLine({ props: helperline_props });
  helperline.$on("SMUITextfieldHelperText:id", ctx[85]);
  helperline.$on("SMUITextfieldHelperText:mount", ctx[86]);
  helperline.$on("SMUITextfieldHelperText:unmount", ctx[87]);
  helperline.$on("SMUITextfieldCharacterCounter:mount", ctx[88]);
  helperline.$on("SMUITextfieldCharacterCounter:unmount", ctx[89]);
  return {
    c() {
      create_component(helperline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helperline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helperline_changes = dirty[1] & 1024 ? get_spread_update(helperline_spread_levels, [get_spread_object(prefixFilter(ctx2[41], "helperLine$"))]) : {};
      if (dirty[2] & 268435456) {
        helperline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helperline.$set(helperline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helperline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helperline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helperline, detaching);
    }
  };
}
function create_default_slot$6(ctx) {
  let current;
  const helper_slot_template = ctx[51].helper;
  const helper_slot = create_slot(helper_slot_template, ctx, ctx[90], get_helper_slot_context);
  return {
    c() {
      if (helper_slot)
        helper_slot.c();
    },
    m(target, anchor) {
      if (helper_slot) {
        helper_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (helper_slot) {
        if (helper_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(helper_slot, helper_slot_template, ctx2, ctx2[90], !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(helper_slot_template, ctx2[90], dirty, get_helper_slot_changes), get_helper_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(helper_slot, local);
      current = true;
    },
    o(local) {
      transition_out(helper_slot, local);
      current = false;
    },
    d(detaching) {
      if (helper_slot)
        helper_slot.d(detaching);
    }
  };
}
function create_fragment$e(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1$2, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[36])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[42].helper && create_if_block$7(ctx);
  return {
    c() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block0.p(ctx2, dirty);
      if (ctx2[42].helper) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
const func$1 = ([name, value]) => `${name}: ${value};`;
const func_1 = ([name, value]) => `${name}: ${value};`;
function instance_1$2($$self, $$props, $$invalidate) {
  let inputElement;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "disabled",
    "required",
    "textarea",
    "variant",
    "noLabel",
    "label",
    "type",
    "value",
    "files",
    "invalid",
    "updateInvalid",
    "dirty",
    "prefix",
    "suffix",
    "validateOnValueChange",
    "useNativeValidation",
    "withLeadingIcon",
    "withTrailingIcon",
    "input",
    "floatingLabel",
    "lineRipple",
    "notchedOutline",
    "focus",
    "blur",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const { applyPassive: applyPassive2 } = events;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { textarea = false } = $$props;
  let { variant = textarea ? "outlined" : "standard" } = $$props;
  let { noLabel = false } = $$props;
  let { label = void 0 } = $$props;
  let { type: type2 = "text" } = $$props;
  let { value = $$restProps.input$emptyValueUndefined ? void 0 : uninitializedValue } = $$props;
  let { files = uninitializedValue } = $$props;
  const valued = !isUninitializedValue(value) || !isUninitializedValue(files);
  if (isUninitializedValue(value)) {
    value = void 0;
  }
  if (isUninitializedValue(files)) {
    files = null;
  }
  let { invalid = uninitializedValue } = $$props;
  let { updateInvalid = isUninitializedValue(invalid) } = $$props;
  if (isUninitializedValue(invalid)) {
    invalid = false;
  }
  let { dirty = false } = $$props;
  let { prefix = void 0 } = $$props;
  let { suffix = void 0 } = $$props;
  let { validateOnValueChange = updateInvalid } = $$props;
  let { useNativeValidation = updateInvalid } = $$props;
  let { withLeadingIcon = uninitializedValue } = $$props;
  let { withTrailingIcon = uninitializedValue } = $$props;
  let { input = void 0 } = $$props;
  let { floatingLabel = void 0 } = $$props;
  let { lineRipple = void 0 } = $$props;
  let { notchedOutline = void 0 } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let helperId = void 0;
  let focused = false;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let initPromiseResolve;
  let initPromise = new Promise((resolve) => initPromiseResolve = resolve);
  let leadingIcon = void 0;
  let trailingIcon = void 0;
  let helperText = void 0;
  let characterCounter = void 0;
  let previousValue = value;
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(49, instance2 = new MDCTextFieldFoundation({
      addClass,
      removeClass,
      hasClass,
      registerTextFieldInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterTextFieldInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler),
      registerValidationAttributeChangeHandler: (handler) => {
        const getAttributesList = (mutationsList) => {
          return mutationsList.map((mutation) => mutation.attributeName).filter((attributeName) => attributeName);
        };
        const observer = new MutationObserver((mutationsList) => {
          if (useNativeValidation) {
            handler(getAttributesList(mutationsList));
          }
        });
        const config = { attributes: true };
        if (input) {
          observer.observe(input.getElement(), config);
        }
        return observer;
      },
      deregisterValidationAttributeChangeHandler: (observer) => {
        observer.disconnect();
      },
      getNativeInput: () => {
        var _a2;
        return (_a2 = input === null || input === void 0 ? void 0 : input.getElement()) !== null && _a2 !== void 0 ? _a2 : null;
      },
      setInputAttr: (name, value2) => {
        input === null || input === void 0 ? void 0 : input.addAttr(name, value2);
      },
      removeInputAttr: (name) => {
        input === null || input === void 0 ? void 0 : input.removeAttr(name);
      },
      isFocused: () => document.activeElement === (input === null || input === void 0 ? void 0 : input.getElement()),
      registerInputInteractionHandler: (evtType, handler) => {
        input === null || input === void 0 ? void 0 : input.getElement().addEventListener(evtType, handler, applyPassive2());
      },
      deregisterInputInteractionHandler: (evtType, handler) => {
        input === null || input === void 0 ? void 0 : input.getElement().removeEventListener(evtType, handler, applyPassive2());
      },
      floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
      getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
      hasLabel: () => !!floatingLabel,
      shakeLabel: (shouldShake) => floatingLabel && floatingLabel.shake(shouldShake),
      setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired),
      activateLineRipple: () => lineRipple && lineRipple.activate(),
      deactivateLineRipple: () => lineRipple && lineRipple.deactivate(),
      setLineRippleTransformOrigin: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
      closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
      hasOutline: () => !!notchedOutline,
      notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth)
    }, {
      get helperText() {
        return helperText;
      },
      get characterCounter() {
        return characterCounter;
      },
      get leadingIcon() {
        return leadingIcon;
      },
      get trailingIcon() {
        return trailingIcon;
      }
    }));
    if (valued) {
      if (input == null) {
        throw new Error("SMUI Textfield initialized without Input component.");
      }
      instance2.init();
    } else {
      tick().then(() => {
        if (input == null) {
          throw new Error("SMUI Textfield initialized without Input component.");
        }
        instance2.init();
      });
    }
    initPromiseResolve();
    return () => {
      instance2.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    var _a2;
    return className2 in internalClasses ? (_a2 = internalClasses[className2]) !== null && _a2 !== void 0 ? _a2 : null : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(25, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(25, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value2) {
    if (internalStyles[name] != value2) {
      if (value2 === "" || value2 == null) {
        delete internalStyles[name];
        $$invalidate(26, internalStyles);
      } else {
        $$invalidate(26, internalStyles[name] = value2, internalStyles);
      }
    }
  }
  function focus() {
    input === null || input === void 0 ? void 0 : input.focus();
  }
  function blur() {
    input === null || input === void 0 ? void 0 : input.blur();
  }
  function layout() {
    if (instance2) {
      const openNotch = instance2.shouldFloat;
      instance2.notchOutline(openNotch);
    }
  }
  function getElement() {
    return element2;
  }
  function floatinglabel_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(5, floatingLabel);
    });
  }
  function floatinglabel_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(5, floatingLabel);
    });
  }
  function notchedoutline_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      notchedOutline = $$value;
      $$invalidate(7, notchedOutline);
    });
  }
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function textarea_1_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function textarea_1_dirty_binding(value2) {
    dirty = value2;
    $$invalidate(4, dirty);
  }
  function textarea_1_invalid_binding(value2) {
    invalid = value2;
    $$invalidate(1, invalid), $$invalidate(49, instance2), $$invalidate(19, updateInvalid);
  }
  const blur_handler = () => $$invalidate(28, focused = false);
  const focus_handler = () => $$invalidate(28, focused = true);
  const blur_handler_1 = (event) => dispatch(element2, "blur", event);
  const focus_handler_1 = (event) => dispatch(element2, "focus", event);
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function input_1_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function input_1_files_binding(value2) {
    files = value2;
    $$invalidate(3, files);
  }
  function input_1_dirty_binding(value2) {
    dirty = value2;
    $$invalidate(4, dirty);
  }
  function input_1_invalid_binding(value2) {
    invalid = value2;
    $$invalidate(1, invalid), $$invalidate(49, instance2), $$invalidate(19, updateInvalid);
  }
  const blur_handler_2 = () => $$invalidate(28, focused = false);
  const focus_handler_2 = () => $$invalidate(28, focused = true);
  const blur_handler_3 = (event) => dispatch(element2, "blur", event);
  const focus_handler_3 = (event) => dispatch(element2, "focus", event);
  function lineripple_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      lineRipple = $$value;
      $$invalidate(6, lineRipple);
    });
  }
  function label_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(24, element2);
    });
  }
  const SMUITextfieldLeadingIcon_mount_handler = (event) => $$invalidate(29, leadingIcon = event.detail);
  const SMUITextfieldLeadingIcon_unmount_handler = () => $$invalidate(29, leadingIcon = void 0);
  const SMUITextfieldTrailingIcon_mount_handler = (event) => $$invalidate(30, trailingIcon = event.detail);
  const SMUITextfieldTrailingIcon_unmount_handler = () => $$invalidate(30, trailingIcon = void 0);
  const SMUITextfieldCharacterCounter_mount_handler = (event) => $$invalidate(32, characterCounter = event.detail);
  const SMUITextfieldCharacterCounter_unmount_handler = () => $$invalidate(32, characterCounter = void 0);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(24, element2);
    });
  }
  const SMUITextfieldLeadingIcon_mount_handler_1 = (event) => $$invalidate(29, leadingIcon = event.detail);
  const SMUITextfieldLeadingIcon_unmount_handler_1 = () => $$invalidate(29, leadingIcon = void 0);
  const SMUITextfieldTrailingIcon_mount_handler_1 = (event) => $$invalidate(30, trailingIcon = event.detail);
  const SMUITextfieldTrailingIcon_unmount_handler_1 = () => $$invalidate(30, trailingIcon = void 0);
  const SMUITextfieldHelperText_id_handler = (event) => $$invalidate(27, helperId = event.detail);
  const SMUITextfieldHelperText_mount_handler = (event) => $$invalidate(31, helperText = event.detail);
  const SMUITextfieldHelperText_unmount_handler = () => {
    $$invalidate(27, helperId = void 0);
    $$invalidate(31, helperText = void 0);
  };
  const SMUITextfieldCharacterCounter_mount_handler_1 = (event) => $$invalidate(32, characterCounter = event.detail);
  const SMUITextfieldCharacterCounter_unmount_handler_1 = () => $$invalidate(32, characterCounter = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(41, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(8, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(10, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(11, ripple = $$new_props.ripple);
    if ("disabled" in $$new_props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(13, required = $$new_props.required);
    if ("textarea" in $$new_props)
      $$invalidate(14, textarea = $$new_props.textarea);
    if ("variant" in $$new_props)
      $$invalidate(15, variant = $$new_props.variant);
    if ("noLabel" in $$new_props)
      $$invalidate(16, noLabel = $$new_props.noLabel);
    if ("label" in $$new_props)
      $$invalidate(17, label = $$new_props.label);
    if ("type" in $$new_props)
      $$invalidate(18, type2 = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("files" in $$new_props)
      $$invalidate(3, files = $$new_props.files);
    if ("invalid" in $$new_props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(19, updateInvalid = $$new_props.updateInvalid);
    if ("dirty" in $$new_props)
      $$invalidate(4, dirty = $$new_props.dirty);
    if ("prefix" in $$new_props)
      $$invalidate(20, prefix = $$new_props.prefix);
    if ("suffix" in $$new_props)
      $$invalidate(21, suffix = $$new_props.suffix);
    if ("validateOnValueChange" in $$new_props)
      $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
    if ("useNativeValidation" in $$new_props)
      $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
    if ("withLeadingIcon" in $$new_props)
      $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("withTrailingIcon" in $$new_props)
      $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
    if ("input" in $$new_props)
      $$invalidate(2, input = $$new_props.input);
    if ("floatingLabel" in $$new_props)
      $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
    if ("lineRipple" in $$new_props)
      $$invalidate(6, lineRipple = $$new_props.lineRipple);
    if ("notchedOutline" in $$new_props)
      $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
    if ("$$scope" in $$new_props)
      $$invalidate(90, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4) {
      $$invalidate(33, inputElement = input && input.getElement());
    }
    if ($$self.$$.dirty[0] & 524290 | $$self.$$.dirty[1] & 262144) {
      if (instance2 && instance2.isValid() !== !invalid) {
        if (updateInvalid) {
          $$invalidate(1, invalid = !instance2.isValid());
        } else {
          instance2.setValid(!invalid);
        }
      }
    }
    if ($$self.$$.dirty[1] & 266240) {
      if (instance2 && instance2.getValidateOnValueChange() !== validateOnValueChange) {
        instance2.setValidateOnValueChange(isUninitializedValue(validateOnValueChange) ? false : validateOnValueChange);
      }
    }
    if ($$self.$$.dirty[1] & 270336) {
      if (instance2) {
        instance2.setUseNativeValidation(isUninitializedValue(useNativeValidation) ? true : useNativeValidation);
      }
    }
    if ($$self.$$.dirty[0] & 4096 | $$self.$$.dirty[1] & 262144) {
      if (instance2) {
        instance2.setDisabled(disabled);
      }
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 786432) {
      if (instance2 && valued && previousValue !== value) {
        $$invalidate(50, previousValue = value);
        const stringValue = `${value}`;
        if (instance2.getValue() !== stringValue) {
          instance2.setValue(stringValue);
        }
      }
    }
  };
  return [
    value,
    invalid,
    input,
    files,
    dirty,
    floatingLabel,
    lineRipple,
    notchedOutline,
    use,
    className,
    style,
    ripple,
    disabled,
    required,
    textarea,
    variant,
    noLabel,
    label,
    type2,
    updateInvalid,
    prefix,
    suffix,
    withLeadingIcon,
    withTrailingIcon,
    element2,
    internalClasses,
    internalStyles,
    helperId,
    focused,
    leadingIcon,
    trailingIcon,
    helperText,
    characterCounter,
    inputElement,
    forwardEvents,
    isUninitializedValue,
    valued,
    initPromise,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    $$slots,
    validateOnValueChange,
    useNativeValidation,
    focus,
    blur,
    layout,
    getElement,
    instance2,
    previousValue,
    slots,
    floatinglabel_binding,
    floatinglabel_binding_1,
    notchedoutline_binding,
    textarea_1_binding,
    textarea_1_value_binding,
    textarea_1_dirty_binding,
    textarea_1_invalid_binding,
    blur_handler,
    focus_handler,
    blur_handler_1,
    focus_handler_1,
    input_1_binding,
    input_1_value_binding,
    input_1_files_binding,
    input_1_dirty_binding,
    input_1_invalid_binding,
    blur_handler_2,
    focus_handler_2,
    blur_handler_3,
    focus_handler_3,
    lineripple_binding,
    label_1_binding,
    SMUITextfieldLeadingIcon_mount_handler,
    SMUITextfieldLeadingIcon_unmount_handler,
    SMUITextfieldTrailingIcon_mount_handler,
    SMUITextfieldTrailingIcon_unmount_handler,
    SMUITextfieldCharacterCounter_mount_handler,
    SMUITextfieldCharacterCounter_unmount_handler,
    div_binding,
    SMUITextfieldLeadingIcon_mount_handler_1,
    SMUITextfieldLeadingIcon_unmount_handler_1,
    SMUITextfieldTrailingIcon_mount_handler_1,
    SMUITextfieldTrailingIcon_unmount_handler_1,
    SMUITextfieldHelperText_id_handler,
    SMUITextfieldHelperText_mount_handler,
    SMUITextfieldHelperText_unmount_handler,
    SMUITextfieldCharacterCounter_mount_handler_1,
    SMUITextfieldCharacterCounter_unmount_handler_1,
    $$scope
  ];
}
class Textfield extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$2, create_fragment$e, safe_not_equal, {
      use: 8,
      class: 9,
      style: 10,
      ripple: 11,
      disabled: 12,
      required: 13,
      textarea: 14,
      variant: 15,
      noLabel: 16,
      label: 17,
      type: 18,
      value: 0,
      files: 3,
      invalid: 1,
      updateInvalid: 19,
      dirty: 4,
      prefix: 20,
      suffix: 21,
      validateOnValueChange: 43,
      useNativeValidation: 44,
      withLeadingIcon: 22,
      withTrailingIcon: 23,
      input: 2,
      floatingLabel: 5,
      lineRipple: 6,
      notchedOutline: 7,
      focus: 45,
      blur: 46,
      layout: 47,
      getElement: 48
    }, null, [-1, -1, -1, -1]);
  }
  get focus() {
    return this.$$.ctx[45];
  }
  get blur() {
    return this.$$.ctx[46];
  }
  get layout() {
    return this.$$.ctx[47];
  }
  get getElement() {
    return this.$$.ctx[48];
  }
}
var Window_svelte_svelte_type_style_lang = "";
const get_footer_slot_changes = (dirty) => ({});
const get_footer_slot_context = (ctx) => ({});
const get_content_slot_changes = (dirty) => ({});
const get_content_slot_context = (ctx) => ({});
function create_default_slot_4$3(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let title_1;
  let current;
  title_1 = new Title$1({
    props: {
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(title_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(title_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const title_1_changes = {};
      if (dirty & 17) {
        title_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      title_1.$set(title_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(title_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(title_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(title_1, detaching);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="material-icons svelte-1boaff0">close</span>`;
      attr(div, "class", "button close-button svelte-1boaff0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(div, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$3(ctx) {
  let section0;
  let t;
  let section1;
  let current;
  section0 = new Section({
    props: {
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  section1 = new Section({
    props: {
      align: "end",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(section0.$$.fragment);
      t = space();
      create_component(section1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(section0, target, anchor);
      insert(target, t, anchor);
      mount_component(section1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const section0_changes = {};
      if (dirty & 17) {
        section0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section0.$set(section0_changes);
      const section1_changes = {};
      if (dirty & 16) {
        section1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section1.$set(section1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(section0.$$.fragment, local);
      transition_in(section1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(section0.$$.fragment, local);
      transition_out(section1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(section0, detaching);
      if (detaching)
        detach(t);
      destroy_component(section1, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & 17) {
        row_changes.$$scope = { dirty, ctx: ctx2 };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let div3;
  let div0;
  let topappbar;
  let t0;
  let div1;
  let t1;
  let div2;
  let current;
  topappbar = new TopAppBar({
    props: {
      variant: "static",
      dense: true,
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  const content_slot_template = ctx[2].content;
  const content_slot = create_slot(content_slot_template, ctx, ctx[4], get_content_slot_context);
  const footer_slot_template = ctx[2].footer;
  const footer_slot = create_slot(footer_slot_template, ctx, ctx[4], get_footer_slot_context);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(topappbar.$$.fragment);
      t0 = space();
      div1 = element("div");
      if (content_slot)
        content_slot.c();
      t1 = space();
      div2 = element("div");
      if (footer_slot)
        footer_slot.c();
      attr(div0, "class", "svelte-1boaff0");
      attr(div1, "class", "window-content svelte-1boaff0");
      attr(div2, "class", "window-footer svelte-1boaff0");
      attr(div3, "class", "window svelte-1boaff0");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(topappbar, div0, null);
      append(div3, t0);
      append(div3, div1);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append(div3, t1);
      append(div3, div2);
      if (footer_slot) {
        footer_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const topappbar_changes = {};
      if (dirty & 17) {
        topappbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topappbar.$set(topappbar_changes);
      if (content_slot) {
        if (content_slot.p && (!current || dirty & 16)) {
          update_slot_base(content_slot, content_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(content_slot_template, ctx2[4], dirty, get_content_slot_changes), get_content_slot_context);
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & 16)) {
          update_slot_base(footer_slot, footer_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(footer_slot_template, ctx2[4], dirty, get_footer_slot_changes), get_footer_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(topappbar.$$.fragment, local);
      transition_in(content_slot, local);
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(topappbar.$$.fragment, local);
      transition_out(content_slot, local);
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(topappbar);
      if (content_slot)
        content_slot.d(detaching);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title = "" } = $$props;
  const dispatch2 = createEventDispatcher();
  const click_handler = () => dispatch2("close");
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [title, dispatch2, slots, click_handler, $$scope];
}
class Window extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$d, safe_not_equal, { title: 0 });
  }
}
var MapButton_svelte_svelte_type_style_lang = "";
function create_fragment$c(ctx) {
  let div;
  let span;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "material-icons svelte-7g99id");
      attr(div, "class", "button svelte-7g99id");
      attr(div, "title", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t);
      ctx[4](div);
      if (!mounted) {
        dispose = listen(div, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
      if (dirty & 4) {
        attr(div, "title", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  let { tooltip } = $$props;
  let { node = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(0, node);
    });
  }
  const click_handler = () => dispatch2("click");
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("tooltip" in $$props2)
      $$invalidate(2, tooltip = $$props2.tooltip);
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
  };
  return [node, icon, tooltip, dispatch2, div_binding, click_handler];
}
class MapButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$c, safe_not_equal, { icon: 1, tooltip: 2, node: 0 });
  }
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function isScrollable(el) {
  return el ? el.scrollHeight > el.offsetHeight : false;
}
function isScrollAtTop(el) {
  return el ? el.scrollTop === 0 : false;
}
function isScrollAtBottom(el) {
  return el ? Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight : false;
}
function areTopsMisaligned(els) {
  var tops = /* @__PURE__ */ new Set();
  [].forEach.call(els, function(el) {
    return tops.add(el.offsetTop);
  });
  return tops.size > 1;
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AnimationFrame = function() {
  function AnimationFrame2() {
    this.rafIDs = /* @__PURE__ */ new Map();
  }
  AnimationFrame2.prototype.request = function(key, callback) {
    var _this = this;
    this.cancel(key);
    var frameID = requestAnimationFrame(function(frame) {
      _this.rafIDs.delete(key);
      callback(frame);
    });
    this.rafIDs.set(key, frameID);
  };
  AnimationFrame2.prototype.cancel = function(key) {
    var rafID = this.rafIDs.get(key);
    if (rafID) {
      cancelAnimationFrame(rafID);
      this.rafIDs.delete(key);
    }
  };
  AnimationFrame2.prototype.cancelAll = function() {
    var _this = this;
    this.rafIDs.forEach(function(_, key) {
      _this.cancel(key);
    });
  };
  AnimationFrame2.prototype.getQueue = function() {
    var queue = [];
    this.rafIDs.forEach(function(_, key) {
      queue.push(key);
    });
    return queue;
  };
  return AnimationFrame2;
}();
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses = {
  CLOSING: "mdc-dialog--closing",
  OPEN: "mdc-dialog--open",
  OPENING: "mdc-dialog--opening",
  SCROLLABLE: "mdc-dialog--scrollable",
  SCROLL_LOCK: "mdc-dialog-scroll-lock",
  STACKED: "mdc-dialog--stacked",
  FULLSCREEN: "mdc-dialog--fullscreen",
  SCROLL_DIVIDER_HEADER: "mdc-dialog-scroll-divider-header",
  SCROLL_DIVIDER_FOOTER: "mdc-dialog-scroll-divider-footer",
  SURFACE_SCRIM_SHOWN: "mdc-dialog__surface-scrim--shown",
  SURFACE_SCRIM_SHOWING: "mdc-dialog__surface-scrim--showing",
  SURFACE_SCRIM_HIDING: "mdc-dialog__surface-scrim--hiding",
  SCRIM_HIDDEN: "mdc-dialog__scrim--hidden"
};
var strings = {
  ACTION_ATTRIBUTE: "data-mdc-dialog-action",
  BUTTON_DEFAULT_ATTRIBUTE: "data-mdc-dialog-button-default",
  BUTTON_SELECTOR: ".mdc-dialog__button",
  CLOSED_EVENT: "MDCDialog:closed",
  CLOSE_ACTION: "close",
  CLOSING_EVENT: "MDCDialog:closing",
  CONTAINER_SELECTOR: ".mdc-dialog__container",
  CONTENT_SELECTOR: ".mdc-dialog__content",
  DESTROY_ACTION: "destroy",
  INITIAL_FOCUS_ATTRIBUTE: "data-mdc-dialog-initial-focus",
  OPENED_EVENT: "MDCDialog:opened",
  OPENING_EVENT: "MDCDialog:opening",
  SCRIM_SELECTOR: ".mdc-dialog__scrim",
  SUPPRESS_DEFAULT_PRESS_SELECTOR: [
    "textarea",
    ".mdc-menu .mdc-list-item",
    ".mdc-menu .mdc-deprecated-list-item"
  ].join(", "),
  SURFACE_SELECTOR: ".mdc-dialog__surface"
};
var numbers = {
  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
  DIALOG_ANIMATION_OPEN_TIME_MS: 150
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["POLL_SCROLL_POS"] = "poll_scroll_position";
  AnimationKeys2["POLL_LAYOUT_CHANGE"] = "poll_layout_change";
})(AnimationKeys || (AnimationKeys = {}));
var MDCDialogFoundation = function(_super) {
  __extends(MDCDialogFoundation2, _super);
  function MDCDialogFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCDialogFoundation2.defaultAdapter), adapter)) || this;
    _this.dialogOpen = false;
    _this.isFullscreen = false;
    _this.animationFrame = 0;
    _this.animationTimer = 0;
    _this.escapeKeyAction = strings.CLOSE_ACTION;
    _this.scrimClickAction = strings.CLOSE_ACTION;
    _this.autoStackButtons = true;
    _this.areButtonsStacked = false;
    _this.suppressDefaultPressSelector = strings.SUPPRESS_DEFAULT_PRESS_SELECTOR;
    _this.animFrame = new AnimationFrame();
    _this.contentScrollHandler = function() {
      _this.handleScrollEvent();
    };
    _this.windowResizeHandler = function() {
      _this.layout();
    };
    _this.windowOrientationChangeHandler = function() {
      _this.layout();
    };
    return _this;
  }
  Object.defineProperty(MDCDialogFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addBodyClass: function() {
          return void 0;
        },
        addClass: function() {
          return void 0;
        },
        areButtonsStacked: function() {
          return false;
        },
        clickDefaultButton: function() {
          return void 0;
        },
        eventTargetMatches: function() {
          return false;
        },
        getActionFromEvent: function() {
          return "";
        },
        getInitialFocusEl: function() {
          return null;
        },
        hasClass: function() {
          return false;
        },
        isContentScrollable: function() {
          return false;
        },
        notifyClosed: function() {
          return void 0;
        },
        notifyClosing: function() {
          return void 0;
        },
        notifyOpened: function() {
          return void 0;
        },
        notifyOpening: function() {
          return void 0;
        },
        releaseFocus: function() {
          return void 0;
        },
        removeBodyClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        reverseButtons: function() {
          return void 0;
        },
        trapFocus: function() {
          return void 0;
        },
        registerContentEventHandler: function() {
          return void 0;
        },
        deregisterContentEventHandler: function() {
          return void 0;
        },
        isScrollableContentAtTop: function() {
          return false;
        },
        isScrollableContentAtBottom: function() {
          return false;
        },
        registerWindowEventHandler: function() {
          return void 0;
        },
        deregisterWindowEventHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCDialogFoundation2.prototype.init = function() {
    if (this.adapter.hasClass(cssClasses.STACKED)) {
      this.setAutoStackButtons(false);
    }
    this.isFullscreen = this.adapter.hasClass(cssClasses.FULLSCREEN);
  };
  MDCDialogFoundation2.prototype.destroy = function() {
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
      this.handleAnimationTimerEnd();
    }
    if (this.isFullscreen) {
      this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
    }
    this.animFrame.cancelAll();
    this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
  };
  MDCDialogFoundation2.prototype.open = function(dialogOptions) {
    var _this = this;
    this.dialogOpen = true;
    this.adapter.notifyOpening();
    this.adapter.addClass(cssClasses.OPENING);
    if (this.isFullscreen) {
      this.adapter.registerContentEventHandler("scroll", this.contentScrollHandler);
    }
    if (dialogOptions && dialogOptions.isAboveFullscreenDialog) {
      this.adapter.addClass(cssClasses.SCRIM_HIDDEN);
    }
    this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.registerWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
    this.runNextAnimationFrame(function() {
      _this.adapter.addClass(cssClasses.OPEN);
      _this.adapter.addBodyClass(cssClasses.SCROLL_LOCK);
      _this.layout();
      _this.animationTimer = setTimeout(function() {
        _this.handleAnimationTimerEnd();
        _this.adapter.trapFocus(_this.adapter.getInitialFocusEl());
        _this.adapter.notifyOpened();
      }, numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
    });
  };
  MDCDialogFoundation2.prototype.close = function(action) {
    var _this = this;
    if (action === void 0) {
      action = "";
    }
    if (!this.dialogOpen) {
      return;
    }
    this.dialogOpen = false;
    this.adapter.notifyClosing(action);
    this.adapter.addClass(cssClasses.CLOSING);
    this.adapter.removeClass(cssClasses.OPEN);
    this.adapter.removeBodyClass(cssClasses.SCROLL_LOCK);
    if (this.isFullscreen) {
      this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
    }
    this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    clearTimeout(this.animationTimer);
    this.animationTimer = setTimeout(function() {
      _this.adapter.releaseFocus();
      _this.handleAnimationTimerEnd();
      _this.adapter.notifyClosed(action);
    }, numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
  };
  MDCDialogFoundation2.prototype.showSurfaceScrim = function() {
    var _this = this;
    this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWING);
    this.runNextAnimationFrame(function() {
      _this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWN);
    });
  };
  MDCDialogFoundation2.prototype.hideSurfaceScrim = function() {
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWN);
    this.adapter.addClass(cssClasses.SURFACE_SCRIM_HIDING);
  };
  MDCDialogFoundation2.prototype.handleSurfaceScrimTransitionEnd = function() {
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_HIDING);
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWING);
  };
  MDCDialogFoundation2.prototype.isOpen = function() {
    return this.dialogOpen;
  };
  MDCDialogFoundation2.prototype.getEscapeKeyAction = function() {
    return this.escapeKeyAction;
  };
  MDCDialogFoundation2.prototype.setEscapeKeyAction = function(action) {
    this.escapeKeyAction = action;
  };
  MDCDialogFoundation2.prototype.getScrimClickAction = function() {
    return this.scrimClickAction;
  };
  MDCDialogFoundation2.prototype.setScrimClickAction = function(action) {
    this.scrimClickAction = action;
  };
  MDCDialogFoundation2.prototype.getAutoStackButtons = function() {
    return this.autoStackButtons;
  };
  MDCDialogFoundation2.prototype.setAutoStackButtons = function(autoStack) {
    this.autoStackButtons = autoStack;
  };
  MDCDialogFoundation2.prototype.getSuppressDefaultPressSelector = function() {
    return this.suppressDefaultPressSelector;
  };
  MDCDialogFoundation2.prototype.setSuppressDefaultPressSelector = function(selector) {
    this.suppressDefaultPressSelector = selector;
  };
  MDCDialogFoundation2.prototype.layout = function() {
    var _this = this;
    this.animFrame.request(AnimationKeys.POLL_LAYOUT_CHANGE, function() {
      _this.layoutInternal();
    });
  };
  MDCDialogFoundation2.prototype.handleClick = function(evt) {
    var isScrim = this.adapter.eventTargetMatches(evt.target, strings.SCRIM_SELECTOR);
    if (isScrim && this.scrimClickAction !== "") {
      this.close(this.scrimClickAction);
    } else {
      var action = this.adapter.getActionFromEvent(evt);
      if (action) {
        this.close(action);
      }
    }
  };
  MDCDialogFoundation2.prototype.handleKeydown = function(evt) {
    var isEnter = evt.key === "Enter" || evt.keyCode === 13;
    if (!isEnter) {
      return;
    }
    var action = this.adapter.getActionFromEvent(evt);
    if (action) {
      return;
    }
    var target = evt.composedPath ? evt.composedPath()[0] : evt.target;
    var isDefault = this.suppressDefaultPressSelector ? !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector) : true;
    if (isEnter && isDefault) {
      this.adapter.clickDefaultButton();
    }
  };
  MDCDialogFoundation2.prototype.handleDocumentKeydown = function(evt) {
    var isEscape = evt.key === "Escape" || evt.keyCode === 27;
    if (isEscape && this.escapeKeyAction !== "") {
      this.close(this.escapeKeyAction);
    }
  };
  MDCDialogFoundation2.prototype.handleScrollEvent = function() {
    var _this = this;
    this.animFrame.request(AnimationKeys.POLL_SCROLL_POS, function() {
      _this.toggleScrollDividerHeader();
      _this.toggleScrollDividerFooter();
    });
  };
  MDCDialogFoundation2.prototype.layoutInternal = function() {
    if (this.autoStackButtons) {
      this.detectStackedButtons();
    }
    this.toggleScrollableClasses();
  };
  MDCDialogFoundation2.prototype.handleAnimationTimerEnd = function() {
    this.animationTimer = 0;
    this.adapter.removeClass(cssClasses.OPENING);
    this.adapter.removeClass(cssClasses.CLOSING);
  };
  MDCDialogFoundation2.prototype.runNextAnimationFrame = function(callback) {
    var _this = this;
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = requestAnimationFrame(function() {
      _this.animationFrame = 0;
      clearTimeout(_this.animationTimer);
      _this.animationTimer = setTimeout(callback, 0);
    });
  };
  MDCDialogFoundation2.prototype.detectStackedButtons = function() {
    this.adapter.removeClass(cssClasses.STACKED);
    var areButtonsStacked = this.adapter.areButtonsStacked();
    if (areButtonsStacked) {
      this.adapter.addClass(cssClasses.STACKED);
    }
    if (areButtonsStacked !== this.areButtonsStacked) {
      this.adapter.reverseButtons();
      this.areButtonsStacked = areButtonsStacked;
    }
  };
  MDCDialogFoundation2.prototype.toggleScrollableClasses = function() {
    this.adapter.removeClass(cssClasses.SCROLLABLE);
    if (this.adapter.isContentScrollable()) {
      this.adapter.addClass(cssClasses.SCROLLABLE);
      if (this.isFullscreen) {
        this.toggleScrollDividerHeader();
        this.toggleScrollDividerFooter();
      }
    }
  };
  MDCDialogFoundation2.prototype.toggleScrollDividerHeader = function() {
    if (!this.adapter.isScrollableContentAtTop()) {
      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_HEADER);
    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_HEADER)) {
      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_HEADER);
    }
  };
  MDCDialogFoundation2.prototype.toggleScrollDividerFooter = function() {
    if (!this.adapter.isScrollableContentAtBottom()) {
      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_FOOTER);
    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_FOOTER)) {
      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_FOOTER);
    }
  };
  return MDCDialogFoundation2;
}(MDCFoundation);
const { document: document_1, window: window_1 } = globals;
const get_over_slot_changes = (dirty) => ({});
const get_over_slot_context = (ctx) => ({});
function create_if_block$6(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "mdc-dialog__surface-scrim");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(div, "transitionend", ctx[31]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$b(ctx) {
  let t0;
  let div3;
  let div1;
  let div0;
  let t1;
  let div0_class_value;
  let div1_class_value;
  let t2;
  let div2;
  let div3_class_value;
  let useActions_action;
  let t3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[27].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[26], null);
  let if_block = ctx[5] && create_if_block$6(ctx);
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [ctx[7]]: true,
        "mdc-dialog__surface": true
      })
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    prefixFilter(ctx[17], "surface$")
  ];
  let div0_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div0_data = assign(div0_data, div0_levels[i]);
  }
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [ctx[6]]: true,
        "mdc-dialog__container": true
      })
    },
    prefixFilter(ctx[17], "container$")
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  let div3_levels = [
    {
      class: div3_class_value = classMap(__spreadValues({
        [ctx[2]]: true,
        "mdc-dialog": true,
        "mdc-dialog--stacked": !ctx[4],
        "mdc-dialog--fullscreen": ctx[5],
        "smui-dialog--selection": ctx[3]
      }, ctx[10]))
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    exclude(ctx[17], ["container$", "surface$"])
  ];
  let div3_data = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div3_data = assign(div3_data, div3_levels[i]);
  }
  const over_slot_template = ctx[27].over;
  const over_slot = create_slot(over_slot_template, ctx, ctx[26], get_over_slot_context);
  return {
    c() {
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div2 = element("div");
      t3 = space();
      if (over_slot)
        over_slot.c();
      set_attributes(div0, div0_data);
      set_attributes(div1, div1_data);
      attr(div2, "class", "mdc-dialog__scrim");
      set_attributes(div3, div3_data);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      append(div3, t2);
      append(div3, div2);
      ctx[32](div3);
      insert(target, t3, anchor);
      if (over_slot) {
        over_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(window_1, "resize", ctx[28]),
          listen(window_1, "orientationchange", ctx[29]),
          listen(document_1.body, "keydown", ctx[30]),
          action_destroyer(useActions_action = useActions.call(null, div3, ctx[1])),
          action_destroyer(ctx[11].call(null, div3)),
          listen(div3, "SMUIDialog:opening", ctx[14]),
          listen(div3, "SMUIDialog:opened", ctx[15]),
          listen(div3, "SMUIDialog:closed", ctx[16]),
          listen(div3, "click", ctx[33]),
          listen(div3, "keydown", ctx[34])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[26], !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(default_slot_template, ctx2[26], dirty, null), null);
        }
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div0, div0_data = get_spread_update(div0_levels, [
        (!current || dirty[0] & 128 && div0_class_value !== (div0_class_value = classMap({
          [ctx2[7]]: true,
          "mdc-dialog__surface": true
        }))) && { class: div0_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & 131072 && prefixFilter(ctx2[17], "surface$")
      ]));
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty[0] & 64 && div1_class_value !== (div1_class_value = classMap({
          [ctx2[6]]: true,
          "mdc-dialog__container": true
        }))) && { class: div1_class_value },
        dirty[0] & 131072 && prefixFilter(ctx2[17], "container$")
      ]));
      set_attributes(div3, div3_data = get_spread_update(div3_levels, [
        (!current || dirty[0] & 1084 && div3_class_value !== (div3_class_value = classMap(__spreadValues({
          [ctx2[2]]: true,
          "mdc-dialog": true,
          "mdc-dialog--stacked": !ctx2[4],
          "mdc-dialog--fullscreen": ctx2[5],
          "smui-dialog--selection": ctx2[3]
        }, ctx2[10])))) && { class: div3_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & 131072 && exclude(ctx2[17], ["container$", "surface$"])
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 2)
        useActions_action.update.call(null, ctx2[1]);
      if (over_slot) {
        if (over_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(over_slot, over_slot_template, ctx2, ctx2[26], !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(over_slot_template, ctx2[26], dirty, get_over_slot_changes), get_over_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(over_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(over_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div3);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[32](null);
      if (detaching)
        detach(t3);
      if (over_slot)
        over_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance_1$1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "open",
    "selection",
    "escapeKeyAction",
    "scrimClickAction",
    "autoStackButtons",
    "fullscreen",
    "container$class",
    "surface$class",
    "isOpen",
    "setOpen",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $aboveFullscreenShown;
  let $actionButtonsReversed;
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a2;
  const { FocusTrap: FocusTrap2 } = domFocusTrap;
  const { closest: closest2, matches: matches2 } = ponyfill;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { open = false } = $$props;
  let { selection = false } = $$props;
  let { escapeKeyAction = "close" } = $$props;
  let { scrimClickAction = "close" } = $$props;
  let { autoStackButtons = true } = $$props;
  let { fullscreen = false } = $$props;
  let { container$class = "" } = $$props;
  let { surface$class = "" } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let focusTrap;
  let actionButtonsReversed = writable(false);
  component_subscribe($$self, actionButtonsReversed, (value) => $$invalidate(38, $actionButtonsReversed = value));
  let aboveFullscreen = getContext("SMUI:dialog:aboveFullscreen");
  let aboveFullscreenShown = (_a2 = getContext("SMUI:dialog:aboveFullscreenShown")) !== null && _a2 !== void 0 ? _a2 : writable(false);
  component_subscribe($$self, aboveFullscreenShown, (value) => $$invalidate(25, $aboveFullscreenShown = value));
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let layoutListeners = [];
  let addLayoutListenerFn = (listener) => {
    layoutListeners.push(listener);
    return () => {
      const idx = layoutListeners.indexOf(listener);
      if (idx >= 0) {
        layoutListeners.splice(idx, 1);
      }
    };
  };
  setContext("SMUI:dialog:actions:reversed", actionButtonsReversed);
  setContext("SMUI:addLayoutListener", addLayoutListenerFn);
  setContext("SMUI:dialog:selection", selection);
  setContext("SMUI:dialog:aboveFullscreen", aboveFullscreen || fullscreen);
  setContext("SMUI:dialog:aboveFullscreenShown", aboveFullscreenShown);
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  let previousAboveFullscreenShown = $aboveFullscreenShown;
  onMount(() => {
    var _a3;
    focusTrap = new FocusTrap2(element2, {
      initialFocusEl: (_a3 = getInitialFocusEl()) !== null && _a3 !== void 0 ? _a3 : void 0
    });
    $$invalidate(8, instance2 = new MDCDialogFoundation({
      addBodyClass: (className2) => document.body.classList.add(className2),
      addClass,
      areButtonsStacked: () => areTopsMisaligned(getButtonEls()),
      clickDefaultButton: () => {
        const defaultButton = getDefaultButtonEl();
        if (defaultButton) {
          defaultButton.click();
        }
      },
      eventTargetMatches: (target, selector) => target ? matches2(target, selector) : false,
      getActionFromEvent: (evt) => {
        if (!evt.target) {
          return "";
        }
        const element3 = closest2(evt.target, "[data-mdc-dialog-action]");
        return element3 && element3.getAttribute("data-mdc-dialog-action");
      },
      getInitialFocusEl,
      hasClass,
      isContentScrollable: () => isScrollable(getContentEl()),
      notifyClosed: (action) => {
        $$invalidate(0, open = false);
        dispatch(getElement(), "SMUIDialog:closed", action ? { action } : {}, void 0, true);
      },
      notifyClosing: (action) => dispatch(getElement(), "SMUIDialog:closing", action ? { action } : {}, void 0, true),
      notifyOpened: () => dispatch(getElement(), "SMUIDialog:opened", {}, void 0, true),
      notifyOpening: () => dispatch(getElement(), "SMUIDialog:opening", {}, void 0, true),
      releaseFocus: () => focusTrap.releaseFocus(),
      removeBodyClass: (className2) => document.body.classList.remove(className2),
      removeClass,
      reverseButtons: () => {
        set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
      },
      trapFocus: () => focusTrap.trapFocus(),
      registerContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.addEventListener(evt, handler);
        }
      },
      deregisterContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.removeEventListener(evt, handler);
        }
      },
      isScrollableContentAtTop: () => {
        return isScrollAtTop(getContentEl());
      },
      isScrollableContentAtBottom: () => {
        return isScrollAtBottom(getContentEl());
      },
      registerWindowEventHandler: (evt, handler) => {
        window.addEventListener(evt, handler);
      },
      deregisterWindowEventHandler: (evt, handler) => {
        window.removeEventListener(evt, handler);
      }
    }));
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = false, internalClasses);
    }
  }
  function getButtonEls() {
    return [].slice.call(element2.querySelectorAll(".mdc-dialog__button"));
  }
  function getDefaultButtonEl() {
    return element2.querySelector("[data-mdc-dialog-button-default");
  }
  function getContentEl() {
    return element2.querySelector(".mdc-dialog__content");
  }
  function getInitialFocusEl() {
    return element2.querySelector("[data-mdc-dialog-initial-focus]");
  }
  function handleDialogOpening() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = true, $aboveFullscreenShown);
    }
    requestAnimationFrame(() => {
      layoutListeners.forEach((listener) => listener());
    });
  }
  function handleDialogOpened() {
    layoutListeners.forEach((listener) => listener());
  }
  function handleDialogClosed() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = false, $aboveFullscreenShown);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(0, open = value);
  }
  function layout() {
    return instance2.layout();
  }
  function getElement() {
    return element2;
  }
  const resize_handler = () => open && instance2 && instance2.layout();
  const orientationchange_handler = () => open && instance2 && instance2.layout();
  const keydown_handler = (event) => open && instance2 && instance2.handleDocumentKeydown(event);
  const transitionend_handler = () => instance2 && instance2.handleSurfaceScrimTransitionEnd();
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  const click_handler = (event) => instance2 && instance2.handleClick(event);
  const keydown_handler_1 = (event) => instance2 && instance2.handleKeydown(event);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("selection" in $$new_props)
      $$invalidate(3, selection = $$new_props.selection);
    if ("escapeKeyAction" in $$new_props)
      $$invalidate(18, escapeKeyAction = $$new_props.escapeKeyAction);
    if ("scrimClickAction" in $$new_props)
      $$invalidate(19, scrimClickAction = $$new_props.scrimClickAction);
    if ("autoStackButtons" in $$new_props)
      $$invalidate(4, autoStackButtons = $$new_props.autoStackButtons);
    if ("fullscreen" in $$new_props)
      $$invalidate(5, fullscreen = $$new_props.fullscreen);
    if ("container$class" in $$new_props)
      $$invalidate(6, container$class = $$new_props.container$class);
    if ("surface$class" in $$new_props)
      $$invalidate(7, surface$class = $$new_props.surface$class);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 262400) {
      if (instance2 && instance2.getEscapeKeyAction() !== escapeKeyAction) {
        instance2.setEscapeKeyAction(escapeKeyAction);
      }
    }
    if ($$self.$$.dirty[0] & 524544) {
      if (instance2 && instance2.getScrimClickAction() !== scrimClickAction) {
        instance2.setScrimClickAction(scrimClickAction);
      }
    }
    if ($$self.$$.dirty[0] & 272) {
      if (instance2 && instance2.getAutoStackButtons() !== autoStackButtons) {
        instance2.setAutoStackButtons(autoStackButtons);
      }
    }
    if ($$self.$$.dirty[0] & 16) {
      if (!autoStackButtons) {
        set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
      }
    }
    if ($$self.$$.dirty[0] & 257) {
      if (instance2 && instance2.isOpen() !== open) {
        if (open) {
          instance2.open({
            isAboveFullscreenDialog: !!aboveFullscreen
          });
        } else {
          instance2.close();
        }
      }
    }
    if ($$self.$$.dirty[0] & 50331936) {
      if (fullscreen && instance2 && previousAboveFullscreenShown !== $aboveFullscreenShown) {
        $$invalidate(24, previousAboveFullscreenShown = $aboveFullscreenShown);
        if ($aboveFullscreenShown) {
          instance2.showSurfaceScrim();
        } else {
          instance2.hideSurfaceScrim();
        }
      }
    }
  };
  return [
    open,
    use,
    className,
    selection,
    autoStackButtons,
    fullscreen,
    container$class,
    surface$class,
    instance2,
    element2,
    internalClasses,
    forwardEvents,
    actionButtonsReversed,
    aboveFullscreenShown,
    handleDialogOpening,
    handleDialogOpened,
    handleDialogClosed,
    $$restProps,
    escapeKeyAction,
    scrimClickAction,
    isOpen,
    setOpen,
    layout,
    getElement,
    previousAboveFullscreenShown,
    $aboveFullscreenShown,
    $$scope,
    slots,
    resize_handler,
    orientationchange_handler,
    keydown_handler,
    transitionend_handler,
    div3_binding,
    click_handler,
    keydown_handler_1
  ];
}
class Dialog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$1, create_fragment$b, safe_not_equal, {
      use: 1,
      class: 2,
      open: 0,
      selection: 3,
      escapeKeyAction: 18,
      scrimClickAction: 19,
      autoStackButtons: 4,
      fullscreen: 5,
      container$class: 6,
      surface$class: 7,
      isOpen: 20,
      setOpen: 21,
      layout: 22,
      getElement: 23
    }, null, [-1, -1]);
  }
  get isOpen() {
    return this.$$.ctx[20];
  }
  get setOpen() {
    return this.$$.ctx[21];
  }
  get layout() {
    return this.$$.ctx[22];
  }
  get getElement() {
    return this.$$.ctx[23];
  }
}
classAdderBuilder({
  class: "mdc-dialog__header",
  component: Div,
  contexts: {
    "SMUI:icon-button:context": "dialog:header"
  }
});
var Title = classAdderBuilder({
  class: "mdc-dialog__title",
  component: H2
});
var Content = classAdderBuilder({
  class: "mdc-dialog__content",
  component: Div
});
var Actions = classAdderBuilder({
  class: "mdc-dialog__actions",
  component: Div,
  classMap: {
    "smui-dialog__actions--reversed": "SMUI:dialog:actions:reversed"
  },
  contexts: {
    "SMUI:button:context": "dialog:action"
  }
});
function create_fragment$a(ctx) {
  let div;
  let div_class_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = classMap({
        [ctx[1]]: true,
        "mdc-layout-grid__inner": true
      }));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(ctx[3].call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
      if (!current || dirty & 2 && div_class_value !== (div_class_value = classMap({
        [ctx2[1]]: true,
        "mdc-layout-grid__inner": true
      }))) {
        attr(div, "class", div_class_value);
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(0, use = $$props2.use);
    if ("class" in $$props2)
      $$invalidate(1, className = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    use,
    className,
    element2,
    forwardEvents,
    getElement,
    $$scope,
    slots,
    div_binding
  ];
}
class InnerGrid extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$a, safe_not_equal, { use: 0, class: 1, getElement: 4 });
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
function create_default_slot$4(ctx) {
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$9(ctx) {
  let div;
  let innergrid;
  let div_class_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const innergrid_spread_levels = [prefixFilter(ctx[6], "innerGrid$")];
  let innergrid_props = {
    $$slots: { default: [create_default_slot$4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < innergrid_spread_levels.length; i += 1) {
    innergrid_props = assign(innergrid_props, innergrid_spread_levels[i]);
  }
  innergrid = new InnerGrid({ props: innergrid_props });
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[1]]: true,
        "mdc-layout-grid": true,
        "mdc-layout-grid--fixed-column-width": ctx[2],
        ["mdc-layout-grid--align-" + ctx[3]]: ctx[3] != null
      })
    },
    exclude(ctx[6], ["innerGrid$"])
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      create_component(innergrid.$$.fragment);
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(innergrid, div, null);
      ctx[9](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(ctx[5].call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const innergrid_changes = dirty & 64 ? get_spread_update(innergrid_spread_levels, [get_spread_object(prefixFilter(ctx2[6], "innerGrid$"))]) : {};
      if (dirty & 1024) {
        innergrid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      innergrid.$set(innergrid_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 14 && div_class_value !== (div_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-layout-grid": true,
          "mdc-layout-grid--fixed-column-width": ctx2[2],
          ["mdc-layout-grid--align-" + ctx2[3]]: ctx2[3] != null
        }))) && { class: div_class_value },
        dirty & 64 && exclude(ctx2[6], ["innerGrid$"])
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(innergrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(innergrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(innergrid);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "fixedColumnWidth", "align", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { fixedColumnWidth = false } = $$props;
  let { align = void 0 } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("fixedColumnWidth" in $$new_props)
      $$invalidate(2, fixedColumnWidth = $$new_props.fixedColumnWidth);
    if ("align" in $$new_props)
      $$invalidate(3, align = $$new_props.align);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    className,
    fixedColumnWidth,
    align,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    slots,
    div_binding,
    $$scope
  ];
}
class LayoutGrid extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$9, safe_not_equal, {
      use: 0,
      class: 1,
      fixedColumnWidth: 2,
      align: 3,
      getElement: 7
    });
  }
  get getElement() {
    return this.$$.ctx[7];
  }
}
function create_fragment$8(ctx) {
  let div;
  let div_class_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  let div_levels = [
    {
      class: div_class_value = classMap(__spreadValues({
        [ctx[1]]: true,
        "mdc-layout-grid__cell": true,
        ["mdc-layout-grid__cell--align-" + ctx[2]]: ctx[2] != null,
        ["mdc-layout-grid__cell--order-" + ctx[3]]: ctx[3] != null,
        ["mdc-layout-grid__cell--span-" + ctx[4]]: ctx[4] != null
      }, Object.fromEntries(Object.entries(ctx[5]).map(func))))
    },
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[12](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(ctx[7].call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 62 && div_class_value !== (div_class_value = classMap(__spreadValues({
          [ctx2[1]]: true,
          "mdc-layout-grid__cell": true,
          ["mdc-layout-grid__cell--align-" + ctx2[2]]: ctx2[2] != null,
          ["mdc-layout-grid__cell--order-" + ctx2[3]]: ctx2[3] != null,
          ["mdc-layout-grid__cell--span-" + ctx2[4]]: ctx2[4] != null
        }, Object.fromEntries(Object.entries(ctx2[5]).map(func)))))) && { class: div_class_value },
        dirty & 256 && ctx2[8]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const func = ([device, span]) => [`mdc-layout-grid__cell--span-${span}-${device}`, true];
function instance$6($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "align", "order", "span", "spanDevices", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { align = void 0 } = $$props;
  let { order = void 0 } = $$props;
  let { span = void 0 } = $$props;
  let { spanDevices = {} } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("align" in $$new_props)
      $$invalidate(2, align = $$new_props.align);
    if ("order" in $$new_props)
      $$invalidate(3, order = $$new_props.order);
    if ("span" in $$new_props)
      $$invalidate(4, span = $$new_props.span);
    if ("spanDevices" in $$new_props)
      $$invalidate(5, spanDevices = $$new_props.spanDevices);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    className,
    align,
    order,
    span,
    spanDevices,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    div_binding
  ];
}
class Cell$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$8, safe_not_equal, {
      use: 0,
      class: 1,
      align: 2,
      order: 3,
      span: 4,
      spanDevices: 5,
      getElement: 9
    });
  }
  get getElement() {
    return this.$$.ctx[9];
  }
}
const Cell = Cell$1;
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[8]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 256)
        set_data(t, ctx2[8]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$5(ctx) {
  let current;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_aria_hidden_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$5, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[8] == null)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    {
      class: div_class_value = classMap(__spreadValues({
        [ctx[1]]: true,
        "mdc-text-field-helper-text": true,
        "mdc-text-field-helper-text--persistent": ctx[3],
        "mdc-text-field-helper-text--validation-msg": ctx[4]
      }, ctx[6]))
    },
    {
      "aria-hidden": div_aria_hidden_value = ctx[3] ? void 0 : "true"
    },
    { id: ctx[2] },
    ctx[7],
    ctx[10]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[14](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(ctx[9].call(null, div))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 90 && div_class_value !== (div_class_value = classMap(__spreadValues({
          [ctx2[1]]: true,
          "mdc-text-field-helper-text": true,
          "mdc-text-field-helper-text--persistent": ctx2[3],
          "mdc-text-field-helper-text--validation-msg": ctx2[4]
        }, ctx2[6])))) && { class: div_class_value },
        (!current || dirty & 8 && div_aria_hidden_value !== (div_aria_hidden_value = ctx2[3] ? void 0 : "true")) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & 4) && { id: ctx2[2] },
        dirty & 128 && ctx2[7],
        dirty & 1024 && ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
let counter = 0;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "id", "persistent", "validationMsg", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { id = "SMUI-textfield-helper-text-" + counter++ } = $$props;
  let { persistent = false } = $$props;
  let { validationMsg = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalAttrs = {};
  let content = void 0;
  onMount(() => {
    instance2 = new MDCTextFieldHelperTextFoundation({
      addClass,
      removeClass,
      hasClass,
      getAttr,
      setAttr: addAttr,
      removeAttr,
      setContent: (value) => {
        $$invalidate(8, content = value);
      }
    });
    if (id.startsWith("SMUI-textfield-helper-text-")) {
      dispatch(getElement(), "SMUITextfieldHelperText:id", id);
    }
    dispatch(getElement(), "SMUITextfieldHelperText:mount", instance2);
    instance2.init();
    return () => {
      dispatch(getElement(), "SMUITextfieldHelperText:unmount", instance2);
      instance2.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function getAttr(name) {
    var _a2;
    return name in internalAttrs ? (_a2 = internalAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(7, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(7, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("persistent" in $$new_props)
      $$invalidate(3, persistent = $$new_props.persistent);
    if ("validationMsg" in $$new_props)
      $$invalidate(4, validationMsg = $$new_props.validationMsg);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  return [
    use,
    className,
    id,
    persistent,
    validationMsg,
    element2,
    internalClasses,
    internalAttrs,
    content,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    div_binding
  ];
}
class HelperText extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1, create_fragment$7, safe_not_equal, {
      use: 0,
      class: 1,
      id: 2,
      persistent: 3,
      validationMsg: 4,
      getElement: 11
    });
  }
  get getElement() {
    return this.$$.ctx[11];
  }
}
function create_default_slot_10$2(ctx) {
  let t;
  return {
    c() {
      t = text("Set Origin");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("Invalid value");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_9$2(ctx) {
  let if_block_anchor;
  let if_block = ctx[2] && create_if_block_1$1();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$1();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_helper_slot_1(ctx) {
  let helpertext;
  let current;
  helpertext = new HelperText({
    props: {
      slot: "helper",
      $$slots: { default: [create_default_slot_9$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpertext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpertext, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helpertext_changes = {};
      if (dirty & 65540) {
        helpertext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpertext.$set(helpertext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helpertext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpertext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpertext, detaching);
    }
  };
}
function create_default_slot_8$2(ctx) {
  let textfield;
  let updating_value;
  let current;
  function textfield_value_binding(value) {
    ctx[9](value);
  }
  let textfield_props = {
    label: "Latitude",
    invalid: ctx[2],
    $$slots: { helper: [create_helper_slot_1] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    textfield_props.value = ctx[0];
  }
  textfield = new Textfield({ props: textfield_props });
  binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
  textfield.$on("change", ctx[10]);
  return {
    c() {
      create_component(textfield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textfield_changes = {};
      if (dirty & 4)
        textfield_changes.invalid = ctx2[2];
      if (dirty & 65540) {
        textfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        textfield_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      textfield.$set(textfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textfield, detaching);
    }
  };
}
function create_if_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Invalid value");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7$2(ctx) {
  let if_block_anchor;
  let if_block = ctx[3] && create_if_block$4();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[3]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$4();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_helper_slot(ctx) {
  let helpertext;
  let current;
  helpertext = new HelperText({
    props: {
      slot: "helper",
      $$slots: { default: [create_default_slot_7$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(helpertext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(helpertext, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const helpertext_changes = {};
      if (dirty & 65544) {
        helpertext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpertext.$set(helpertext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(helpertext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(helpertext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(helpertext, detaching);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let textfield;
  let updating_value;
  let current;
  function textfield_value_binding_1(value) {
    ctx[11](value);
  }
  let textfield_props = {
    label: "Longitude",
    invalid: ctx[3],
    $$slots: { helper: [create_helper_slot] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    textfield_props.value = ctx[1];
  }
  textfield = new Textfield({ props: textfield_props });
  binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_1));
  textfield.$on("change", ctx[12]);
  return {
    c() {
      create_component(textfield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textfield_changes = {};
      if (dirty & 8)
        textfield_changes.invalid = ctx2[3];
      if (dirty & 65544) {
        textfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & 2) {
        updating_value = true;
        textfield_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      textfield.$set(textfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textfield, detaching);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let cell0;
  let t;
  let cell1;
  let current;
  cell0 = new Cell({
    props: {
      span: 6,
      $$slots: { default: [create_default_slot_8$2] },
      $$scope: { ctx }
    }
  });
  cell1 = new Cell({
    props: {
      span: 6,
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(cell0.$$.fragment);
      t = space();
      create_component(cell1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cell0, target, anchor);
      insert(target, t, anchor);
      mount_component(cell1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cell0_changes = {};
      if (dirty & 65541) {
        cell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cell0.$set(cell0_changes);
      const cell1_changes = {};
      if (dirty & 65546) {
        cell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cell1.$set(cell1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cell0.$$.fragment, local);
      transition_in(cell1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cell0.$$.fragment, local);
      transition_out(cell1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cell0, detaching);
      if (detaching)
        detach(t);
      destroy_component(cell1, detaching);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let layoutgrid;
  let current;
  layoutgrid = new LayoutGrid({
    props: {
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layoutgrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layoutgrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const layoutgrid_changes = {};
      if (dirty & 65551) {
        layoutgrid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layoutgrid.$set(layoutgrid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layoutgrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layoutgrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layoutgrid, detaching);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let t;
  return {
    c() {
      t = text("Set");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let label;
  let current;
  label = new Label({
    props: {
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(label.$$.fragment);
    },
    m(target, anchor) {
      mount_component(label, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const label_changes = {};
      if (dirty & 65536) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(label, detaching);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let button;
  let current;
  button = new Button_1({
    props: {
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[13]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 65536) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot$3(ctx) {
  let title;
  let t0;
  let content;
  let t1;
  let actions;
  let current;
  title = new Title({
    props: {
      $$slots: { default: [create_default_slot_10$2] },
      $$scope: { ctx }
    }
  });
  content = new Content({
    props: {
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  actions = new Actions({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(title.$$.fragment);
      t0 = space();
      create_component(content.$$.fragment);
      t1 = space();
      create_component(actions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(title, target, anchor);
      insert(target, t0, anchor);
      mount_component(content, target, anchor);
      insert(target, t1, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const title_changes = {};
      if (dirty & 65536) {
        title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      title.$set(title_changes);
      const content_changes = {};
      if (dirty & 65551) {
        content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      content.$set(content_changes);
      const actions_changes = {};
      if (dirty & 65536) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(title.$$.fragment, local);
      transition_in(content.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(title.$$.fragment, local);
      transition_out(content.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(title, detaching);
      if (detaching)
        detach(t0);
      destroy_component(content, detaching);
      if (detaching)
        detach(t1);
      destroy_component(actions, detaching);
    }
  };
}
function create_fragment$6(ctx) {
  let dialog;
  let updating_open;
  let current;
  function dialog_open_binding(value) {
    ctx[14](value);
  }
  let dialog_props = {
    $$slots: { default: [create_default_slot$3] },
    $$scope: { ctx }
  };
  if (ctx[4] !== void 0) {
    dialog_props.open = ctx[4];
  }
  dialog = new Dialog({ props: dialog_props });
  binding_callbacks.push(() => bind(dialog, "open", dialog_open_binding));
  return {
    c() {
      create_component(dialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dialog, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const dialog_changes = {};
      if (dirty & 65551) {
        dialog_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & 16) {
        updating_open = true;
        dialog_changes.open = ctx2[4];
        add_flush_callback(() => updating_open = false);
      }
      dialog.$set(dialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialog, detaching);
    }
  };
}
function toFloat$1(s) {
  return Number(s);
}
function toLatitude(s) {
  const latitude = toFloat$1(s);
  if (isNaN(latitude) || latitude < -90 || latitude > 90) {
    return NaN;
  }
  return latitude;
}
function toLongitude(s) {
  const longitude = toFloat$1(s);
  if (isNaN(longitude) || longitude < -180 || longitude > 180) {
    return NaN;
  }
  return longitude;
}
function instance$5($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let latitudeString = "";
  let longitudeString = "";
  let invalidLatitude = false;
  let invalidLongitude = false;
  let open = false;
  function show(latLng) {
    if (latLng) {
      $$invalidate(0, latitudeString = latLng.lat.toString());
      $$invalidate(1, longitudeString = latLng.lng.toString());
    } else {
      $$invalidate(0, latitudeString = "");
      $$invalidate(1, longitudeString = "");
    }
    $$invalidate(4, open = true);
  }
  function onLatitudeChanged() {
    const latitude = toLatitude(latitudeString);
    $$invalidate(2, invalidLatitude = isNaN(latitude));
  }
  function onLongitudeChanged() {
    const longitude = toLongitude(longitudeString);
    $$invalidate(3, invalidLongitude = isNaN(longitude));
  }
  function onSet() {
    const latitude = toLatitude(latitudeString);
    const longitude = toLongitude(longitudeString);
    if (isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    dispatch2("set", { latLng: L$1.latLng(latitude, longitude) });
  }
  function textfield_value_binding(value) {
    latitudeString = value;
    $$invalidate(0, latitudeString);
  }
  const change_handler = () => onLatitudeChanged();
  function textfield_value_binding_1(value) {
    longitudeString = value;
    $$invalidate(1, longitudeString);
  }
  const change_handler_1 = () => onLongitudeChanged();
  const click_handler = () => onSet();
  function dialog_open_binding(value) {
    open = value;
    $$invalidate(4, open);
  }
  return [
    latitudeString,
    longitudeString,
    invalidLatitude,
    invalidLongitude,
    open,
    onLatitudeChanged,
    onLongitudeChanged,
    onSet,
    show,
    textfield_value_binding,
    change_handler,
    textfield_value_binding_1,
    change_handler_1,
    click_handler,
    dialog_open_binding
  ];
}
class SetOriginDialog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$6, safe_not_equal, { show: 8 });
  }
  get show() {
    return this.$$.ctx[8];
  }
}
const dmsRe = /^(-?\d+(?:\.\d+)?)[°:d]?\s?(?:(\d+(?:\.\d+)?)['′ʹ:]?\s?(?:(\d+(?:\.\d+)?)["″ʺ]?)?)?\s?([NSEW])?/i;
function truncate(n) {
  return n > 0 ? Math.floor(n) : Math.ceil(n);
}
class Dms {
  get dd() {
    return this._dd;
  }
  get hemisphere() {
    return this._hemisphere;
  }
  constructor(dd, longOrLat) {
    this._dd = dd;
    this._hemisphere = /^[WE]|(?:lon)/i.test(longOrLat) ? dd < 0 ? "W" : "E" : dd < 0 ? "S" : "N";
  }
  getDmsArray() {
    return this.dmsArray;
  }
  get dmsArray() {
    const absDD = Math.abs(this._dd);
    const degrees = truncate(absDD);
    const minutes = truncate((absDD - degrees) * 60);
    const seconds = (absDD - degrees - minutes / 60) * Math.pow(60, 2);
    return [degrees, minutes, seconds, this._hemisphere];
  }
  toString() {
    const dmsArray = this.getDmsArray();
    return `${dmsArray[0]}\xB0${dmsArray[1]}\u2032${dmsArray[2]}\u2033 ${dmsArray[3]}`;
  }
}
class DmsCoordinates {
  constructor(lat, lon) {
    this.lat = lat;
    this.lon = lon;
    if (typeof lat !== "number" || typeof lon !== "number") {
      throw TypeError("The longitude and latitude parameters must be numbers.");
    }
    if (isNaN(lon) || lon < -180 || lon > 180) {
      throw RangeError("longitude must be between -180 and 180");
    }
    if (isNaN(lat) || lat < -90 || lat > 90) {
      throw RangeError("latitude must be between -90 and 90");
    }
    this._longitude = new Dms(lon, "long");
    this._latitude = new Dms(lat, "lat");
  }
  get longitude() {
    return this._longitude;
  }
  get latitude() {
    return this._latitude;
  }
  getDmsArrays() {
    return this.dmsArrays;
  }
  get dmsArrays() {
    return {
      longitude: this.longitude.getDmsArray(),
      latitude: this.latitude.getDmsArray()
    };
  }
  toString() {
    return [this.latitude, this.longitude].join(", ");
  }
}
DmsCoordinates.dmsRe = dmsRe;
class DmsHelper {
  static toString(dms) {
    const dmsArray = dms.getDmsArray();
    return `${dmsArray[0]}\xB0${dmsArray[1]}\u2032${dmsArray[2].toFixed(1)}\u2033 ${dmsArray[3]}`;
  }
  static toDmsString(latLng) {
    const dmsCoords = new DmsCoordinates(latLng.lat, latLng.lng);
    return `${DmsHelper.toString(dmsCoords.latitude)} ${DmsHelper.toString(dmsCoords.longitude)}`;
  }
}
var Coords_svelte_svelte_type_style_lang = "";
function create_if_block$3(ctx) {
  let t0;
  let t1;
  return {
    c() {
      t0 = text("G ");
      t1 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t1, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$5(ctx) {
  let div0;
  let t0;
  let div2;
  let div1;
  let t1;
  let t2;
  let if_block = ctx[2] !== "" && create_if_block$3(ctx);
  return {
    c() {
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      t1 = text("G ");
      t2 = text(ctx[3]);
      attr(div0, "class", "coords svelte-m29apg");
      attr(div1, "class", "svelte-m29apg");
      set_style(div2, "display", "none");
      attr(div2, "class", "svelte-m29apg");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (if_block)
        if_block.m(div0, null);
      ctx[6](div0);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, t1);
      append(div1, t2);
      ctx[7](div1);
    },
    p(ctx2, [dirty]) {
      if (ctx2[2] !== "") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 8)
        set_data(t2, ctx2[3]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (if_block)
        if_block.d();
      ctx[6](null);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
      ctx[7](null);
    }
  };
}
function formatLatLng(lat, lng) {
  return { lat: lat.toFixed(6), lng: lng.toFixed(6) };
}
function instance$4($$self, $$props, $$invalidate) {
  let { node = void 0 } = $$props;
  let popupElement;
  let currentMap;
  let popup;
  let coords = "";
  let clickedCoords = "";
  function onControlAdded(map) {
    currentMap = map;
    map.on("mousemove", onMouseMove);
    map.on("contextmenu", onContextMenu);
    popup = L$1.popup().setContent(popupElement);
  }
  function onControlRemoved(map) {
    map.off("mousemove", onMouseMove);
    map.off("contextmenu", onContextMenu);
    popup.removeFrom(map);
  }
  function onMouseMove(e) {
    const formattedLatLng = formatLatLng(e.latlng.lat, e.latlng.lng);
    new DmsCoordinates(e.latlng.lat, e.latlng.lng);
    $$invalidate(2, coords = `${formattedLatLng.lat}, ${formattedLatLng.lng} / ${DmsHelper.toDmsString(e.latlng)}`);
  }
  function onContextMenu(e) {
    if (!e.originalEvent.shiftKey && !e.originalEvent.ctrlKey && !e.originalEvent.altKey) {
      $$invalidate(3, clickedCoords = coords);
      if (!currentMap) {
        return;
      }
      popup.setLatLng(e.latlng).openOn(currentMap);
    }
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(0, node);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popupElement = $$value;
      $$invalidate(1, popupElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
  };
  return [
    node,
    popupElement,
    coords,
    clickedCoords,
    onControlAdded,
    onControlRemoved,
    div0_binding,
    div1_binding
  ];
}
class Coords extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$5, safe_not_equal, {
      node: 0,
      onControlAdded: 4,
      onControlRemoved: 5
    });
  }
  get onControlAdded() {
    return this.$$.ctx[4];
  }
  get onControlRemoved() {
    return this.$$.ctx[5];
  }
}
class GpsLocalFrame {
  constructor(latitude, longitude) {
    this.latitude = latitude;
    this.longitude = longitude;
    this.rLatitude = latitude * Math.PI / 180;
    this.latitudeMultiplier = 111132.92 - 559.82 * Math.cos(2 * this.rLatitude) + 1.175 * Math.cos(4 * this.rLatitude) - 23e-4 * Math.cos(6 * this.rLatitude);
    this.longitudeMultiplier = 111412.84 * Math.cos(this.rLatitude) - 93.5 * Math.cos(3 * this.rLatitude) + 0.118 * Math.cos(5 * this.rLatitude);
  }
  toLocal(latitude, longitude) {
    return [
      (longitude - this.longitude) * this.longitudeMultiplier,
      (latitude - this.latitude) * this.latitudeMultiplier
    ];
  }
  toGps(x, y) {
    return [
      y / this.latitudeMultiplier + this.latitude,
      x / this.longitudeMultiplier + this.longitude
    ];
  }
}
var LocalCoords_svelte_svelte_type_style_lang = "";
function create_if_block$2(ctx) {
  let t0;
  let t1;
  return {
    c() {
      t0 = text("L ");
      t1 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t1, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$4(ctx) {
  let div0;
  let t0;
  let div2;
  let div1;
  let t1;
  let t2;
  let if_block = ctx[2] !== "" && create_if_block$2(ctx);
  return {
    c() {
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      t1 = text("L ");
      t2 = text(ctx[3]);
      attr(div0, "class", "coords svelte-m29apg");
      attr(div1, "class", "svelte-m29apg");
      set_style(div2, "display", "none");
      attr(div2, "class", "svelte-m29apg");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (if_block)
        if_block.m(div0, null);
      ctx[7](div0);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, t1);
      append(div1, t2);
      ctx[8](div1);
    },
    p(ctx2, [dirty]) {
      if (ctx2[2] !== "") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 8)
        set_data(t2, ctx2[3]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (if_block)
        if_block.d();
      ctx[7](null);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
      ctx[8](null);
    }
  };
}
function formatPoint(x, y) {
  return { x: x.toFixed(3), y: y.toFixed(3) };
}
function instance$3($$self, $$props, $$invalidate) {
  let { node = void 0 } = $$props;
  let { origin = null } = $$props;
  let popupElement;
  let currentMap;
  let popup;
  let coords = "";
  let clickedCoords = "";
  let gpsLocalFrame = null;
  function onControlAdded(map) {
    currentMap = map;
    map.on("mousemove", onMouseMove);
    map.on("contextmenu", onContextMenu);
    popup = L$1.popup().setContent(popupElement);
  }
  function onControlRemoved(map) {
    map.off("mousemove", onMouseMove);
    map.off("contextmenu", onContextMenu);
    popup.removeFrom(map);
  }
  function onMouseMove(e) {
    if (!gpsLocalFrame) {
      return;
    }
    const point = gpsLocalFrame.toLocal(e.latlng.lat, e.latlng.lng);
    const formattedPoint = formatPoint(point[0], point[1]);
    $$invalidate(2, coords = formattedPoint.x + ", " + formattedPoint.y);
  }
  function onContextMenu(e) {
    if (!e.originalEvent.shiftKey && !e.originalEvent.ctrlKey && e.originalEvent.altKey) {
      $$invalidate(3, clickedCoords = coords);
      if (!currentMap) {
        return;
      }
      popup.setLatLng(e.latlng).openOn(currentMap);
    }
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(0, node);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popupElement = $$value;
      $$invalidate(1, popupElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("origin" in $$props2)
      $$invalidate(4, origin = $$props2.origin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      {
        if (origin) {
          gpsLocalFrame = new GpsLocalFrame(origin.lat, origin.lng);
          $$invalidate(2, coords = "");
          $$invalidate(3, clickedCoords = "");
        } else {
          gpsLocalFrame = null;
          $$invalidate(2, coords = "");
          $$invalidate(3, clickedCoords = "");
        }
      }
    }
  };
  return [
    node,
    popupElement,
    coords,
    clickedCoords,
    origin,
    onControlAdded,
    onControlRemoved,
    div0_binding,
    div1_binding
  ];
}
class LocalCoords extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$4, safe_not_equal, {
      node: 0,
      origin: 4,
      onControlAdded: 5,
      onControlRemoved: 6
    });
  }
  get onControlAdded() {
    return this.$$.ctx[5];
  }
  get onControlRemoved() {
    return this.$$.ctx[6];
  }
}
var LeafletHelper;
((LeafletHelper2) => {
  function newControl(element2, controlOptions, addCallback, removeCallback) {
    const Control = L$1.Control.extend({
      onAdd: (map) => {
        L$1.DomEvent.disableClickPropagation(element2);
        if (addCallback) {
          addCallback(map);
        }
        return element2;
      },
      onRemove: (map) => {
        if (removeCallback) {
          removeCallback(map);
        }
      }
    });
    return new Control(controlOptions);
  }
  LeafletHelper2.newControl = newControl;
  class Converter {
    constructor(gpsLocalFrame) {
      this.gpsLocalFrame = gpsLocalFrame;
    }
    toLocal(latLng) {
      const localPoint = this.gpsLocalFrame.toLocal(latLng.lat, latLng.lng);
      localPoint[0] = Number(localPoint[0].toFixed(1));
      localPoint[1] = Number(localPoint[1].toFixed(1));
      return localPoint;
    }
    toLocalArray(latLngs) {
      return latLngs.map((latLng) => this.toLocal(latLng));
    }
    toLocalArrayList(latLngs) {
      try {
        if (!Array.isArray(latLngs[0])) {
          const v = latLngs;
          return [this.toLocalArray(v)];
        } else if (!Array.isArray(latLngs[0][0])) {
          const v = latLngs;
          return v.map((latLngs2) => this.toLocalArray(latLngs2));
        } else if (!Array.isArray(latLngs[0][0][0])) {
          console.log("cannot handle value", latLngs);
          return null;
        }
      } catch (e) {
        console.log(e);
        return null;
      }
    }
  }
  LeafletHelper2.Converter = Converter;
})(LeafletHelper || (LeafletHelper = {}));
class MapLayerManager {
  constructor(map) {
    this.originMarker = null;
    this.missionPolyline = null;
    this.geofencePolygon = null;
    this.map = map;
    map.createPane("geofence").style.zIndex = "300";
    map.createPane("mission").style.zIndex = "301";
    this.geofenceLayer = L$1.featureGroup([], {
      pane: "geofence"
    });
    this.geofenceLayer.addTo(map);
    this.missionLayer = L$1.featureGroup([], {
      pane: "mission"
    });
    this.missionLayer.addTo(map);
  }
  getBounds() {
    const bounds = L$1.latLngBounds([]);
    const featureGroups = [
      this.geofenceLayer,
      this.missionLayer
    ];
    featureGroups.filter((featureGroup) => this.map.hasLayer(featureGroup) && featureGroup.getBounds().isValid()).forEach((featureGroup) => bounds.extend(featureGroup.getBounds()));
    return bounds;
  }
  setOrigin(latLng) {
    if (!latLng) {
      if (this.originMarker) {
        this.originMarker.remove();
        this.originMarker = null;
      }
      return;
    }
    if (this.originMarker !== null) {
      this.originMarker.setLatLng(latLng);
    } else {
      this.originMarker = L$1.marker(latLng, {
        title: "origin"
      });
      this.originMarker.addTo(this.map);
    }
  }
  setGeofence(latLngs) {
    if (!latLngs) {
      if (this.geofencePolygon) {
        this.geofencePolygon.remove();
        this.geofencePolygon = null;
      }
      return;
    }
    if (this.geofencePolygon !== null) {
      this.geofencePolygon.setLatLngs(latLngs);
    } else {
      this.geofencePolygon = L$1.polygon(latLngs, {
        interactive: false
      });
      this.geofencePolygon.bindPopup("geofence");
      this.geofencePolygon.addTo(this.geofenceLayer);
    }
  }
  setMission(latLngs) {
    if (!latLngs) {
      if (this.missionPolyline) {
        this.missionPolyline.remove();
        this.missionPolyline = null;
      }
      return;
    }
    if (this.missionPolyline !== null) {
      this.missionPolyline.setLatLngs(latLngs);
    } else {
      this.missionPolyline = L$1.polyline(latLngs, {
        interactive: false
      });
      this.missionPolyline.bindPopup("mission");
      this.missionPolyline.addTo(this.missionLayer);
    }
  }
}
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
class TypedStorage {
  constructor(options = { storage: "localStorage" }) {
    this.storage = typeof window !== "undefined" ? window[options.storage] : commonjsGlobal[options.storage];
    if (!this.storage) {
      throw Error("Web Storage API not found.");
    }
  }
  length() {
    var _a2;
    return (_a2 = this.storage) === null || _a2 === void 0 ? void 0 : _a2.length;
  }
  key(index) {
    var _a2;
    return (_a2 = this.storage) === null || _a2 === void 0 ? void 0 : _a2.key(index);
  }
  getItem(key, retrievalMode = "fail") {
    var _a2;
    const item = (_a2 = this.storage) === null || _a2 === void 0 ? void 0 : _a2.getItem(key.toString());
    if (item == null) {
      return item;
    }
    try {
      return JSON.parse(item);
    } catch (error) {
      switch (retrievalMode) {
        case "safe":
          return null;
        case "raw":
          return item;
        default:
          throw error;
      }
    }
  }
  setItem(key, value) {
    var _a2;
    (_a2 = this.storage) === null || _a2 === void 0 ? void 0 : _a2.setItem(key.toString(), JSON.stringify(value));
  }
  removeItem(key) {
    var _a2;
    (_a2 = this.storage) === null || _a2 === void 0 ? void 0 : _a2.removeItem(key.toString());
  }
  clear() {
    var _a2;
    (_a2 = this.storage) === null || _a2 === void 0 ? void 0 : _a2.clear();
  }
}
var _default = dist.default = TypedStorage;
const typedStore = new _default();
const originWritable = writable(null, (start2) => {
  const storedValue = typedStore.getItem("origin", "safe");
  if (storedValue) {
    start2(L$1.latLng(storedValue.latitude, storedValue.longitude));
  } else {
    start2(null);
  }
});
originWritable.subscribe((value) => {
  if (value) {
    typedStore.setItem("origin", {
      latitude: value.lat,
      longitude: value.lng
    });
  } else {
    typedStore.setItem("origin", null);
  }
});
const geoJsonWritable = writable(null, (start2) => {
  const storedValue = typedStore.getItem("geoJson", "safe");
  if (storedValue) {
    start2(JSON.parse(storedValue));
  } else {
    start2(null);
  }
});
geoJsonWritable.subscribe((value) => {
  if (value) {
    typedStore.setItem("geoJson", JSON.stringify(value));
  } else {
    typedStore.setItem("geoJson", null);
  }
});
function create_default_slot_10$1(ctx) {
  let t;
  return {
    c() {
      t = text("Add local marker");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_9$1(ctx) {
  let textfield;
  let updating_value;
  let current;
  function textfield_value_binding(value) {
    ctx[10](value);
  }
  let textfield_props = { label: "X" };
  if (ctx[0] !== void 0) {
    textfield_props.value = ctx[0];
  }
  textfield = new Textfield({ props: textfield_props });
  binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
  textfield.$on("change", ctx[11]);
  return {
    c() {
      create_component(textfield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textfield_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        textfield_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      textfield.$set(textfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textfield, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let textfield;
  let updating_value;
  let current;
  function textfield_value_binding_1(value) {
    ctx[12](value);
  }
  let textfield_props = { label: "Y" };
  if (ctx[1] !== void 0) {
    textfield_props.value = ctx[1];
  }
  textfield = new Textfield({ props: textfield_props });
  binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_1));
  textfield.$on("change", ctx[13]);
  return {
    c() {
      create_component(textfield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textfield_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        textfield_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      textfield.$set(textfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textfield, detaching);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[3]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[4]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let cell0;
  let t0;
  let cell1;
  let t1;
  let cell2;
  let t2;
  let cell3;
  let current;
  cell0 = new Cell({
    props: {
      span: 6,
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx }
    }
  });
  cell1 = new Cell({
    props: {
      span: 6,
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  cell2 = new Cell({
    props: {
      span: 12,
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx }
    }
  });
  cell3 = new Cell({
    props: {
      span: 12,
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(cell0.$$.fragment);
      t0 = space();
      create_component(cell1.$$.fragment);
      t1 = space();
      create_component(cell2.$$.fragment);
      t2 = space();
      create_component(cell3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(cell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(cell2, target, anchor);
      insert(target, t2, anchor);
      mount_component(cell3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cell0_changes = {};
      if (dirty & 4194305) {
        cell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cell0.$set(cell0_changes);
      const cell1_changes = {};
      if (dirty & 4194306) {
        cell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cell1.$set(cell1_changes);
      const cell2_changes = {};
      if (dirty & 4194312) {
        cell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cell2.$set(cell2_changes);
      const cell3_changes = {};
      if (dirty & 4194320) {
        cell3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cell3.$set(cell3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cell0.$$.fragment, local);
      transition_in(cell1.$$.fragment, local);
      transition_in(cell2.$$.fragment, local);
      transition_in(cell3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cell0.$$.fragment, local);
      transition_out(cell1.$$.fragment, local);
      transition_out(cell2.$$.fragment, local);
      transition_out(cell3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cell0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(cell1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(cell2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(cell3, detaching);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let layoutgrid;
  let current;
  layoutgrid = new LayoutGrid({
    props: {
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layoutgrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layoutgrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const layoutgrid_changes = {};
      if (dirty & 4194331) {
        layoutgrid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layoutgrid.$set(layoutgrid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layoutgrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layoutgrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layoutgrid, detaching);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let t;
  return {
    c() {
      t = text("Set");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let label;
  let current;
  label = new Label({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(label.$$.fragment);
    },
    m(target, anchor) {
      mount_component(label, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const label_changes = {};
      if (dirty & 4194304) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(label, detaching);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let button;
  let current;
  button = new Button_1({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[14]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4194304) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let title;
  let t0;
  let content;
  let t1;
  let actions;
  let current;
  title = new Title({
    props: {
      $$slots: { default: [create_default_slot_10$1] },
      $$scope: { ctx }
    }
  });
  content = new Content({
    props: {
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  actions = new Actions({
    props: {
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(title.$$.fragment);
      t0 = space();
      create_component(content.$$.fragment);
      t1 = space();
      create_component(actions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(title, target, anchor);
      insert(target, t0, anchor);
      mount_component(content, target, anchor);
      insert(target, t1, anchor);
      mount_component(actions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const title_changes = {};
      if (dirty & 4194304) {
        title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      title.$set(title_changes);
      const content_changes = {};
      if (dirty & 4194331) {
        content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      content.$set(content_changes);
      const actions_changes = {};
      if (dirty & 4194304) {
        actions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actions.$set(actions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(title.$$.fragment, local);
      transition_in(content.$$.fragment, local);
      transition_in(actions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(title.$$.fragment, local);
      transition_out(content.$$.fragment, local);
      transition_out(actions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(title, detaching);
      if (detaching)
        detach(t0);
      destroy_component(content, detaching);
      if (detaching)
        detach(t1);
      destroy_component(actions, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let dialog;
  let updating_open;
  let current;
  function dialog_open_binding(value) {
    ctx[15](value);
  }
  let dialog_props = {
    $$slots: { default: [create_default_slot$2] },
    $$scope: { ctx }
  };
  if (ctx[2] !== void 0) {
    dialog_props.open = ctx[2];
  }
  dialog = new Dialog({ props: dialog_props });
  binding_callbacks.push(() => bind(dialog, "open", dialog_open_binding));
  return {
    c() {
      create_component(dialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dialog, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const dialog_changes = {};
      if (dirty & 4194331) {
        dialog_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & 4) {
        updating_open = true;
        dialog_changes.open = ctx2[2];
        add_flush_callback(() => updating_open = false);
      }
      dialog.$set(dialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialog, detaching);
    }
  };
}
function toFloat(s) {
  if (s === void 0 || s === null) {
    return NaN;
  }
  s = s.trim();
  if (s === "") {
    return NaN;
  }
  return Number(s);
}
function instance$2($$self, $$props, $$invalidate) {
  let { origin = null } = $$props;
  const dispatch2 = createEventDispatcher();
  let xString = "";
  let yString = "";
  let x = NaN;
  let y = NaN;
  let open = false;
  let gpsLocalFrame = null;
  let latLng = null;
  let coords = "";
  let coordsDms = "";
  function show() {
    $$invalidate(0, xString = "");
    $$invalidate(1, yString = "");
    x = NaN;
    y = NaN;
    latLng = null;
    $$invalidate(3, coords = "");
    $$invalidate(4, coordsDms = "");
    $$invalidate(2, open = true);
  }
  function onXChanged() {
    update2();
  }
  function onYChanged() {
    update2();
  }
  function update2() {
    x = toFloat(xString);
    y = toFloat(yString);
    if (isNaN(x) || isNaN(y) || !gpsLocalFrame) {
      latLng = null;
      $$invalidate(3, coords = "");
      $$invalidate(4, coordsDms = "");
      return;
    }
    if (gpsLocalFrame) {
      const globalCoords = gpsLocalFrame.toGps(x, y);
      latLng = L$1.latLng(globalCoords[0], globalCoords[1]);
      $$invalidate(3, coords = `${globalCoords[0].toFixed(6)}, ${globalCoords[1].toFixed(6)}`);
      $$invalidate(4, coordsDms = `${DmsHelper.toDmsString(latLng)}`);
    }
  }
  function onSet() {
    update2();
    if (latLng) {
      dispatch2("add", { latLng });
    }
  }
  function textfield_value_binding(value) {
    xString = value;
    $$invalidate(0, xString);
  }
  const change_handler = () => onXChanged();
  function textfield_value_binding_1(value) {
    yString = value;
    $$invalidate(1, yString);
  }
  const change_handler_1 = () => onYChanged();
  const click_handler = () => onSet();
  function dialog_open_binding(value) {
    open = value;
    $$invalidate(2, open);
  }
  $$self.$$set = ($$props2) => {
    if ("origin" in $$props2)
      $$invalidate(8, origin = $$props2.origin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      {
        if (origin) {
          gpsLocalFrame = new GpsLocalFrame(origin.lat, origin.lng);
        } else {
          gpsLocalFrame = null;
          $$invalidate(3, coords = "");
          $$invalidate(4, coordsDms = "");
          latLng = null;
        }
      }
    }
  };
  return [
    xString,
    yString,
    open,
    coords,
    coordsDms,
    onXChanged,
    onYChanged,
    onSet,
    origin,
    show,
    textfield_value_binding,
    change_handler,
    textfield_value_binding_1,
    change_handler_1,
    click_handler,
    dialog_open_binding
  ];
}
class AddLocalMarkerDialog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$3, safe_not_equal, { origin: 8, show: 9 });
  }
  get show() {
    return this.$$.ctx[9];
  }
}
var Home_svelte_svelte_type_style_lang = "";
function create_if_block_1(ctx) {
  let div;
  let window2;
  let current;
  window2 = new Window({
    props: {
      title: "GeoJSON",
      $$slots: {
        footer: [create_footer_slot],
        content: [create_content_slot_1]
      },
      $$scope: { ctx }
    }
  });
  window2.$on("close", ctx[46]);
  return {
    c() {
      div = element("div");
      create_component(window2.$$.fragment);
      attr(div, "class", "overlay svelte-1a5npx0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(window2, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const window_changes = {};
      if (dirty[0] & 65536 | dirty[1] & 1073741824) {
        window_changes.$$scope = { dirty, ctx: ctx2 };
      }
      window2.$set(window_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(window2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(window2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(window2);
    }
  };
}
function create_content_slot_1(ctx) {
  let div;
  let textfield;
  let updating_value;
  let current;
  function textfield_value_binding(value) {
    ctx[45](value);
  }
  let textfield_props = {
    textarea: true,
    style: "width: 100%; height: 100%;"
  };
  if (ctx[16] !== void 0) {
    textfield_props.value = ctx[16];
  }
  textfield = new Textfield({ props: textfield_props });
  binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
  return {
    c() {
      div = element("div");
      create_component(textfield.$$.fragment);
      attr(div, "slot", "content");
      set_style(div, "height", "100%");
      attr(div, "class", "svelte-1a5npx0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textfield, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textfield_changes = {};
      if (!updating_value && dirty[0] & 65536) {
        updating_value = true;
        textfield_changes.value = ctx2[16];
        add_flush_callback(() => updating_value = false);
      }
      textfield.$set(textfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(textfield);
    }
  };
}
function create_default_slot$1(ctx) {
  let t;
  return {
    c() {
      t = text("Update");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_footer_slot(ctx) {
  let div;
  let button;
  let current;
  button = new Button_1({
    props: {
      variant: "raised",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[44]);
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      attr(div, "slot", "footer");
      set_style(div, "text-align", "right");
      set_style(div, "margin", "8px");
      attr(div, "class", "svelte-1a5npx0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[1] & 1073741824) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(button);
    }
  };
}
function create_if_block$1(ctx) {
  let div;
  let window2;
  let current;
  window2 = new Window({
    props: {
      title: "Local coords",
      $$slots: { content: [create_content_slot] },
      $$scope: { ctx }
    }
  });
  window2.$on("close", ctx[48]);
  return {
    c() {
      div = element("div");
      create_component(window2.$$.fragment);
      attr(div, "class", "overlay svelte-1a5npx0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(window2, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const window_changes = {};
      if (dirty[0] & 131072 | dirty[1] & 1073741824) {
        window_changes.$$scope = { dirty, ctx: ctx2 };
      }
      window2.$set(window_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(window2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(window2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(window2);
    }
  };
}
function create_content_slot(ctx) {
  let div;
  let textfield;
  let updating_value;
  let current;
  function textfield_value_binding_1(value) {
    ctx[47](value);
  }
  let textfield_props = {
    textarea: true,
    style: "width: 100%; height: 100%;"
  };
  if (ctx[17] !== void 0) {
    textfield_props.value = ctx[17];
  }
  textfield = new Textfield({ props: textfield_props });
  binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_1));
  return {
    c() {
      div = element("div");
      create_component(textfield.$$.fragment);
      attr(div, "slot", "content");
      set_style(div, "height", "100%");
      attr(div, "class", "svelte-1a5npx0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textfield, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textfield_changes = {};
      if (!updating_value && dirty[0] & 131072) {
        updating_value = true;
        textfield_changes.value = ctx2[17];
        add_flush_callback(() => updating_value = false);
      }
      textfield.$set(textfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(textfield);
    }
  };
}
function create_fragment$2(ctx) {
  let div1;
  let div0;
  let t0;
  let div2;
  let mapbutton0;
  let updating_node;
  let t1;
  let mapbutton1;
  let updating_node_1;
  let t2;
  let mapbutton2;
  let updating_node_2;
  let t3;
  let mapbutton3;
  let updating_node_3;
  let t4;
  let mapbutton4;
  let updating_node_4;
  let t5;
  let mapbutton5;
  let updating_node_5;
  let t6;
  let coords;
  let updating_node_6;
  let t7;
  let localcoords;
  let updating_node_7;
  let t8;
  let t9;
  let t10;
  let setorigindialog;
  let t11;
  let addlocalmarkerdialog;
  let current;
  function mapbutton0_node_binding(value) {
    ctx[28](value);
  }
  let mapbutton0_props = {
    icon: "crop_free",
    tooltip: "Zoom to fit"
  };
  if (ctx[1] !== void 0) {
    mapbutton0_props.node = ctx[1];
  }
  mapbutton0 = new MapButton({ props: mapbutton0_props });
  binding_callbacks.push(() => bind(mapbutton0, "node", mapbutton0_node_binding));
  mapbutton0.$on("click", ctx[29]);
  function mapbutton1_node_binding(value) {
    ctx[30](value);
  }
  let mapbutton1_props = { icon: "adjust", tooltip: "Set origin" };
  if (ctx[2] !== void 0) {
    mapbutton1_props.node = ctx[2];
  }
  mapbutton1 = new MapButton({ props: mapbutton1_props });
  binding_callbacks.push(() => bind(mapbutton1, "node", mapbutton1_node_binding));
  mapbutton1.$on("click", ctx[31]);
  function mapbutton2_node_binding(value) {
    ctx[32](value);
  }
  let mapbutton2_props = { icon: "code", tooltip: "GeoJSON" };
  if (ctx[3] !== void 0) {
    mapbutton2_props.node = ctx[3];
  }
  mapbutton2 = new MapButton({ props: mapbutton2_props });
  binding_callbacks.push(() => bind(mapbutton2, "node", mapbutton2_node_binding));
  mapbutton2.$on("click", ctx[33]);
  function mapbutton3_node_binding(value) {
    ctx[34](value);
  }
  let mapbutton3_props = {
    icon: "output",
    tooltip: "Export to local coords format"
  };
  if (ctx[4] !== void 0) {
    mapbutton3_props.node = ctx[4];
  }
  mapbutton3 = new MapButton({ props: mapbutton3_props });
  binding_callbacks.push(() => bind(mapbutton3, "node", mapbutton3_node_binding));
  mapbutton3.$on("click", ctx[35]);
  function mapbutton4_node_binding(value) {
    ctx[36](value);
  }
  let mapbutton4_props = {
    icon: "my_location",
    tooltip: "My location"
  };
  if (ctx[5] !== void 0) {
    mapbutton4_props.node = ctx[5];
  }
  mapbutton4 = new MapButton({ props: mapbutton4_props });
  binding_callbacks.push(() => bind(mapbutton4, "node", mapbutton4_node_binding));
  mapbutton4.$on("click", ctx[37]);
  function mapbutton5_node_binding(value) {
    ctx[38](value);
  }
  let mapbutton5_props = {
    icon: "place",
    tooltip: "Add local marker"
  };
  if (ctx[6] !== void 0) {
    mapbutton5_props.node = ctx[6];
  }
  mapbutton5 = new MapButton({ props: mapbutton5_props });
  binding_callbacks.push(() => bind(mapbutton5, "node", mapbutton5_node_binding));
  mapbutton5.$on("click", ctx[39]);
  function coords_node_binding(value) {
    ctx[41](value);
  }
  let coords_props = {};
  if (ctx[9] !== void 0) {
    coords_props.node = ctx[9];
  }
  coords = new Coords({ props: coords_props });
  ctx[40](coords);
  binding_callbacks.push(() => bind(coords, "node", coords_node_binding));
  function localcoords_node_binding(value) {
    ctx[43](value);
  }
  let localcoords_props = { origin: ctx[15] };
  if (ctx[11] !== void 0) {
    localcoords_props.node = ctx[11];
  }
  localcoords = new LocalCoords({ props: localcoords_props });
  ctx[42](localcoords);
  binding_callbacks.push(() => bind(localcoords, "node", localcoords_node_binding));
  let if_block0 = ctx[13] && create_if_block_1(ctx);
  let if_block1 = ctx[14] && create_if_block$1(ctx);
  let setorigindialog_props = {};
  setorigindialog = new SetOriginDialog({ props: setorigindialog_props });
  ctx[49](setorigindialog);
  setorigindialog.$on("set", ctx[50]);
  let addlocalmarkerdialog_props = { origin: ctx[15] };
  addlocalmarkerdialog = new AddLocalMarkerDialog({ props: addlocalmarkerdialog_props });
  ctx[51](addlocalmarkerdialog);
  addlocalmarkerdialog.$on("add", ctx[52]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      create_component(mapbutton0.$$.fragment);
      t1 = space();
      create_component(mapbutton1.$$.fragment);
      t2 = space();
      create_component(mapbutton2.$$.fragment);
      t3 = space();
      create_component(mapbutton3.$$.fragment);
      t4 = space();
      create_component(mapbutton4.$$.fragment);
      t5 = space();
      create_component(mapbutton5.$$.fragment);
      t6 = space();
      create_component(coords.$$.fragment);
      t7 = space();
      create_component(localcoords.$$.fragment);
      t8 = space();
      if (if_block0)
        if_block0.c();
      t9 = space();
      if (if_block1)
        if_block1.c();
      t10 = space();
      create_component(setorigindialog.$$.fragment);
      t11 = space();
      create_component(addlocalmarkerdialog.$$.fragment);
      attr(div0, "class", "map-container svelte-1a5npx0");
      attr(div1, "class", "map-container svelte-1a5npx0");
      set_style(div2, "display", "none");
      attr(div2, "class", "svelte-1a5npx0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[27](div0);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      mount_component(mapbutton0, div2, null);
      append(div2, t1);
      mount_component(mapbutton1, div2, null);
      append(div2, t2);
      mount_component(mapbutton2, div2, null);
      append(div2, t3);
      mount_component(mapbutton3, div2, null);
      append(div2, t4);
      mount_component(mapbutton4, div2, null);
      append(div2, t5);
      mount_component(mapbutton5, div2, null);
      append(div2, t6);
      mount_component(coords, div2, null);
      append(div2, t7);
      mount_component(localcoords, div2, null);
      insert(target, t8, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t9, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t10, anchor);
      mount_component(setorigindialog, target, anchor);
      insert(target, t11, anchor);
      mount_component(addlocalmarkerdialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const mapbutton0_changes = {};
      if (!updating_node && dirty[0] & 2) {
        updating_node = true;
        mapbutton0_changes.node = ctx2[1];
        add_flush_callback(() => updating_node = false);
      }
      mapbutton0.$set(mapbutton0_changes);
      const mapbutton1_changes = {};
      if (!updating_node_1 && dirty[0] & 4) {
        updating_node_1 = true;
        mapbutton1_changes.node = ctx2[2];
        add_flush_callback(() => updating_node_1 = false);
      }
      mapbutton1.$set(mapbutton1_changes);
      const mapbutton2_changes = {};
      if (!updating_node_2 && dirty[0] & 8) {
        updating_node_2 = true;
        mapbutton2_changes.node = ctx2[3];
        add_flush_callback(() => updating_node_2 = false);
      }
      mapbutton2.$set(mapbutton2_changes);
      const mapbutton3_changes = {};
      if (!updating_node_3 && dirty[0] & 16) {
        updating_node_3 = true;
        mapbutton3_changes.node = ctx2[4];
        add_flush_callback(() => updating_node_3 = false);
      }
      mapbutton3.$set(mapbutton3_changes);
      const mapbutton4_changes = {};
      if (!updating_node_4 && dirty[0] & 32) {
        updating_node_4 = true;
        mapbutton4_changes.node = ctx2[5];
        add_flush_callback(() => updating_node_4 = false);
      }
      mapbutton4.$set(mapbutton4_changes);
      const mapbutton5_changes = {};
      if (!updating_node_5 && dirty[0] & 64) {
        updating_node_5 = true;
        mapbutton5_changes.node = ctx2[6];
        add_flush_callback(() => updating_node_5 = false);
      }
      mapbutton5.$set(mapbutton5_changes);
      const coords_changes = {};
      if (!updating_node_6 && dirty[0] & 512) {
        updating_node_6 = true;
        coords_changes.node = ctx2[9];
        add_flush_callback(() => updating_node_6 = false);
      }
      coords.$set(coords_changes);
      const localcoords_changes = {};
      if (dirty[0] & 32768)
        localcoords_changes.origin = ctx2[15];
      if (!updating_node_7 && dirty[0] & 2048) {
        updating_node_7 = true;
        localcoords_changes.node = ctx2[11];
        add_flush_callback(() => updating_node_7 = false);
      }
      localcoords.$set(localcoords_changes);
      if (ctx2[13]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t9.parentNode, t9);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[14]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16384) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t10.parentNode, t10);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const setorigindialog_changes = {};
      setorigindialog.$set(setorigindialog_changes);
      const addlocalmarkerdialog_changes = {};
      if (dirty[0] & 32768)
        addlocalmarkerdialog_changes.origin = ctx2[15];
      addlocalmarkerdialog.$set(addlocalmarkerdialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(mapbutton0.$$.fragment, local);
      transition_in(mapbutton1.$$.fragment, local);
      transition_in(mapbutton2.$$.fragment, local);
      transition_in(mapbutton3.$$.fragment, local);
      transition_in(mapbutton4.$$.fragment, local);
      transition_in(mapbutton5.$$.fragment, local);
      transition_in(coords.$$.fragment, local);
      transition_in(localcoords.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(setorigindialog.$$.fragment, local);
      transition_in(addlocalmarkerdialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(mapbutton0.$$.fragment, local);
      transition_out(mapbutton1.$$.fragment, local);
      transition_out(mapbutton2.$$.fragment, local);
      transition_out(mapbutton3.$$.fragment, local);
      transition_out(mapbutton4.$$.fragment, local);
      transition_out(mapbutton5.$$.fragment, local);
      transition_out(coords.$$.fragment, local);
      transition_out(localcoords.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(setorigindialog.$$.fragment, local);
      transition_out(addlocalmarkerdialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[27](null);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
      destroy_component(mapbutton0);
      destroy_component(mapbutton1);
      destroy_component(mapbutton2);
      destroy_component(mapbutton3);
      destroy_component(mapbutton4);
      destroy_component(mapbutton5);
      ctx[40](null);
      destroy_component(coords);
      ctx[42](null);
      destroy_component(localcoords);
      if (detaching)
        detach(t8);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t9);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t10);
      ctx[49](null);
      destroy_component(setorigindialog, detaching);
      if (detaching)
        detach(t11);
      ctx[51](null);
      destroy_component(addlocalmarkerdialog, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let mapEl;
  let zoomToFitButton;
  let setOriginButton;
  let editGeoJSONButton;
  let exportToLocalCoordsButton;
  let myLocationButton;
  let addLocalMarkerButton;
  let setOriginDialog;
  let addLocalMarkerDialog;
  let coordsEl;
  let coordsComponent;
  let localCoordsEl;
  let localCoordsComponent;
  let displayGeoJsonOverlay = false;
  let displayLocalCoordsOverlay = false;
  let map;
  let mapControls = [];
  let mapLayerManager;
  let editableLayers;
  let origin = null;
  let geojsonText = null;
  let localCoordsText = null;
  let myLocationTrackSymbol = null;
  onMount(() => {
    initMap();
    originWritable.subscribe((value) => {
      mapLayerManager.setOrigin(value);
      $$invalidate(15, origin = value);
    });
    geoJsonWritable.subscribe((value) => {
      const geojsonLayer = L$1.geoJSON();
      geojsonLayer.addData(value);
      editableLayers.clearLayers();
      geojsonLayer.getLayers().forEach((layer) => {
        editableLayers.addLayer(layer);
      });
    });
  });
  onDestroy(() => {
    mapControls.forEach((control) => map.removeControl(control));
  });
  function initMap() {
    map = L$1.map(mapEl, { center: [1.364917, 103.822872], zoom: 11 });
    mapLayerManager = new MapLayerManager(map);
    addControl(L$1.control.scale({ maxWidth: 200 }));
    addControl(L$1.control.ruler({ position: "topleft" }));
    const openStreetMapsTileLayer = L$1.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      minZoom: 0,
      maxZoom: 20,
      maxNativeZoom: 19,
      attribution: "\xA9 OpenStreetMap contributors"
    });
    const oneMapSgTileLayer = L$1.tileLayer("https://maps-{s}.onemap.sg/v3/Original/{z}/{x}/{y}.png", {
      minZoom: 11,
      maxZoom: 18,
      bounds: [[1.56073, 104.11475], [1.16, 103.502]],
      attribution: '<img src="https://docs.onemap.sg/maps/images/oneMap64-01.png" style="height:20px;width:20px;"/> New OneMap | Map data &copy; contributors, <a href="http://SLA.gov.sg">Singapore Land Authority</a>'
    });
    const cartoDBVoyagerTileLayer = L$1.tileLayer("https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: "abcd",
      maxZoom: 19
    });
    const openSeaMapTileLayer = L$1.tileLayer("https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png", {
      opacity: 0.2,
      attribution: 'Map data: &copy; <a href="http://www.openseamap.org">OpenSeaMap</a> contributors'
    });
    const esriWorldImageryTileLayer = L$1.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
      attribution: "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community"
    });
    openStreetMapsTileLayer.addTo(map);
    const baseMaps = {
      "OpenStreetMaps": openStreetMapsTileLayer,
      "OneMapSG": oneMapSgTileLayer,
      "CartoDB.Voyager": cartoDBVoyagerTileLayer,
      "Esri.WorldImagery": esriWorldImageryTileLayer
    };
    const overlayMaps = {
      "OpenSeaMap": openSeaMapTileLayer,
      "Mission": mapLayerManager.missionLayer,
      "Geofence": mapLayerManager.geofenceLayer
    };
    addControl(L$1.control.layers(baseMaps, overlayMaps, {}));
    addControl(LeafletHelper.newControl(zoomToFitButton, { position: "topright" }));
    addControl(LeafletHelper.newControl(setOriginButton, { position: "topright" }));
    addControl(LeafletHelper.newControl(editGeoJSONButton, { position: "topright" }));
    addControl(LeafletHelper.newControl(exportToLocalCoordsButton, { position: "topright" }));
    addControl(LeafletHelper.newControl(myLocationButton, { position: "topright" }));
    addControl(LeafletHelper.newControl(addLocalMarkerButton, { position: "topright" }));
    addControl(LeafletHelper.newControl(coordsEl, { position: "bottomright" }, (map2) => {
      coordsComponent.onControlAdded(map2);
    }, (map2) => {
      coordsComponent.onControlRemoved(map2);
    }));
    addControl(LeafletHelper.newControl(localCoordsEl, { position: "bottomright" }, (map2) => {
      localCoordsComponent.onControlAdded(map2);
    }, (map2) => {
      localCoordsComponent.onControlRemoved(map2);
    }));
    editableLayers = L$1.featureGroup();
    editableLayers.addTo(map);
    addControl(new L$1.Control.Draw({
      draw: { circle: false, circlemarker: false },
      edit: {
        featureGroup: editableLayers,
        remove: true
      }
    }));
    map.on(L$1.Draw.Event.CREATED, (e) => {
      editableLayers.addLayer(e.layer);
      save(editableLayers);
    });
    map.on(L$1.Draw.Event.EDITED, (_e) => {
      save(editableLayers);
    });
    map.on(L$1.Draw.Event.DELETED, (_e) => {
      save(editableLayers);
    });
  }
  function save(featureGroup) {
    console.log(featureGroup.toGeoJSON());
    geoJsonWritable.set(featureGroup.toGeoJSON());
  }
  function addControl(control) {
    mapControls.push(control);
    control.addTo(map);
  }
  function onZoomToFit() {
    const bounds = mapLayerManager.getBounds();
    if (editableLayers.getBounds().isValid()) {
      bounds.extend(editableLayers.getBounds());
    }
    if (bounds.isValid()) {
      map.fitBounds(bounds);
    }
  }
  function showSetOriginDialog() {
    setOriginDialog.show(origin);
  }
  function onOriginSet(e) {
    $$invalidate(15, origin = e.detail.latLng);
    mapLayerManager.setOrigin(e.detail.latLng);
    originWritable.set(e.detail.latLng);
  }
  function showGeoJsonDialog() {
    $$invalidate(16, geojsonText = JSON.stringify(editableLayers.toGeoJSON(), null, 2));
    $$invalidate(13, displayGeoJsonOverlay = true);
  }
  function updateGeoJSON() {
    try {
      const o = JSON.parse(geojsonText);
      geoJsonWritable.set(o);
      $$invalidate(13, displayGeoJsonOverlay = false);
    } catch (e) {
      console.log(e);
    }
  }
  function showLocalCoordsDialog() {
    if (!origin) {
      return;
    }
    const gpsLocalFrame = new GpsLocalFrame(origin.lat, origin.lng);
    const converter = new LeafletHelper.Converter(gpsLocalFrame);
    const data = { "layers": [] };
    editableLayers.getLayers().forEach((layer) => {
      if (layer instanceof leafletSrc.exports.Polygon) {
        data.layers.push({
          "type": "Polygon",
          "items": converter.toLocalArrayList(layer.getLatLngs())
        });
      } else if (layer instanceof leafletSrc.exports.Polyline) {
        data.layers.push({
          "type": "Polyline",
          "items": converter.toLocalArrayList(layer.getLatLngs())
        });
      } else if (layer instanceof leafletSrc.exports.Marker) {
        data.layers.push({
          "type": "Marker",
          "point": converter.toLocal(layer.getLatLng())
        });
      }
    });
    $$invalidate(17, localCoordsText = JSON.stringify(data, null, 2));
    $$invalidate(14, displayLocalCoordsOverlay = true);
  }
  function showMyLocation() {
    navigator.geolocation.getCurrentPosition((position) => {
      const latLng = L$1.latLng(position.coords.latitude, position.coords.longitude);
      toasts.add({
        type: "info",
        description: `${position.coords.latitude} ${position.coords.longitude} / ${DmsHelper.toDmsString(latLng)} / ${position.coords.accuracy.toFixed(1)}m / ${position.coords.heading}`,
        placement: "bottom-center",
        duration: 0
      });
      const headingInRadians = position.coords.heading !== null ? position.coords.heading * Math.PI / 180 : null;
      if (myLocationTrackSymbol) {
        myLocationTrackSymbol.setLatLng(latLng);
        myLocationTrackSymbol.setHeading(headingInRadians);
      } else {
        myLocationTrackSymbol = L$1.trackSymbol(latLng, {
          fill: true,
          fillColor: "#0000ff",
          fillOpacity: 1,
          stroke: true,
          color: "#000000",
          opacity: 1,
          weight: 1,
          heading: headingInRadians
        });
        myLocationTrackSymbol.addTo(map);
      }
      console.log(position);
    }, (error) => {
      toasts.add({
        type: "error",
        description: "Could not get location: " + error,
        placement: "bottom-center",
        duration: 5e3
      });
      console.log(error);
    }, { enableHighAccuracy: true });
  }
  function addLocalMarker() {
    addLocalMarkerDialog.show();
  }
  function onAddLocalMarker(e) {
    editableLayers.addLayer(L$1.marker(e.detail.latLng));
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      mapEl = $$value;
      $$invalidate(0, mapEl);
    });
  }
  function mapbutton0_node_binding(value) {
    zoomToFitButton = value;
    $$invalidate(1, zoomToFitButton);
  }
  const click_handler = () => onZoomToFit();
  function mapbutton1_node_binding(value) {
    setOriginButton = value;
    $$invalidate(2, setOriginButton);
  }
  const click_handler_1 = () => showSetOriginDialog();
  function mapbutton2_node_binding(value) {
    editGeoJSONButton = value;
    $$invalidate(3, editGeoJSONButton);
  }
  const click_handler_2 = () => showGeoJsonDialog();
  function mapbutton3_node_binding(value) {
    exportToLocalCoordsButton = value;
    $$invalidate(4, exportToLocalCoordsButton);
  }
  const click_handler_3 = () => showLocalCoordsDialog();
  function mapbutton4_node_binding(value) {
    myLocationButton = value;
    $$invalidate(5, myLocationButton);
  }
  const click_handler_4 = () => showMyLocation();
  function mapbutton5_node_binding(value) {
    addLocalMarkerButton = value;
    $$invalidate(6, addLocalMarkerButton);
  }
  const click_handler_5 = () => addLocalMarker();
  function coords_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      coordsComponent = $$value;
      $$invalidate(10, coordsComponent);
    });
  }
  function coords_node_binding(value) {
    coordsEl = value;
    $$invalidate(9, coordsEl);
  }
  function localcoords_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      localCoordsComponent = $$value;
      $$invalidate(12, localCoordsComponent);
    });
  }
  function localcoords_node_binding(value) {
    localCoordsEl = value;
    $$invalidate(11, localCoordsEl);
  }
  const click_handler_6 = () => updateGeoJSON();
  function textfield_value_binding(value) {
    geojsonText = value;
    $$invalidate(16, geojsonText);
  }
  const close_handler = () => $$invalidate(13, displayGeoJsonOverlay = false);
  function textfield_value_binding_1(value) {
    localCoordsText = value;
    $$invalidate(17, localCoordsText);
  }
  const close_handler_1 = () => $$invalidate(14, displayLocalCoordsOverlay = false);
  function setorigindialog_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      setOriginDialog = $$value;
      $$invalidate(7, setOriginDialog);
    });
  }
  const set_handler = (e) => onOriginSet(e);
  function addlocalmarkerdialog_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      addLocalMarkerDialog = $$value;
      $$invalidate(8, addLocalMarkerDialog);
    });
  }
  const add_handler = (e) => onAddLocalMarker(e);
  return [
    mapEl,
    zoomToFitButton,
    setOriginButton,
    editGeoJSONButton,
    exportToLocalCoordsButton,
    myLocationButton,
    addLocalMarkerButton,
    setOriginDialog,
    addLocalMarkerDialog,
    coordsEl,
    coordsComponent,
    localCoordsEl,
    localCoordsComponent,
    displayGeoJsonOverlay,
    displayLocalCoordsOverlay,
    origin,
    geojsonText,
    localCoordsText,
    onZoomToFit,
    showSetOriginDialog,
    onOriginSet,
    showGeoJsonDialog,
    updateGeoJSON,
    showLocalCoordsDialog,
    showMyLocation,
    addLocalMarker,
    onAddLocalMarker,
    div0_binding,
    mapbutton0_node_binding,
    click_handler,
    mapbutton1_node_binding,
    click_handler_1,
    mapbutton2_node_binding,
    click_handler_2,
    mapbutton3_node_binding,
    click_handler_3,
    mapbutton4_node_binding,
    click_handler_4,
    mapbutton5_node_binding,
    click_handler_5,
    coords_binding,
    coords_node_binding,
    localcoords_binding,
    localcoords_node_binding,
    click_handler_6,
    textfield_value_binding,
    close_handler,
    textfield_value_binding_1,
    close_handler_1,
    setorigindialog_binding,
    set_handler,
    addlocalmarkerdialog_binding,
    add_handler
  ];
}
class Home extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$2, safe_not_equal, {}, null, [-1, -1]);
  }
}
var About_svelte_svelte_type_style_lang = "";
function create_fragment$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "container svelte-hk2a25");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class About extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1, safe_not_equal, {});
  }
}
var App_svelte_svelte_type_style_lang = "";
function create_default_slot_15(ctx) {
  let t;
  return {
    c() {
      t = text("menu");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "dev";
      attr(span, "class", "mdc-chip svelte-195huik");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_14(ctx) {
  let t;
  let if_block_anchor;
  let if_block = !Env.isProduction && create_if_block();
  return {
    c() {
      t = text("Map Tool\n                        ");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_13(ctx) {
  let iconbutton;
  let t;
  let title;
  let current;
  iconbutton = new IconButton({
    props: {
      class: "material-icons",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  iconbutton.$on("click", ctx[3]);
  title = new Title$1({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(iconbutton.$$.fragment);
      t = space();
      create_component(title.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      insert(target, t, anchor);
      mount_component(title, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const iconbutton_changes = {};
      if (dirty & 256) {
        iconbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbutton.$set(iconbutton_changes);
      const title_changes = {};
      if (dirty & 256) {
        title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      title.$set(title_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      transition_in(title.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      transition_out(title.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
      if (detaching)
        detach(t);
      destroy_component(title, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let section;
  let current;
  section = new Section({
    props: {
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(section.$$.fragment);
    },
    m(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const section_changes = {};
      if (dirty & 257) {
        section_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section.$set(section_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(section, detaching);
    }
  };
}
function create_default_slot_11(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & 257) {
        row_changes.$$scope = { dirty, ctx: ctx2 };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let t;
  return {
    c() {
      t = text("Home");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_9(ctx) {
  let t;
  return {
    c() {
      t = text("home");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_8(ctx) {
  let text_1;
  let t;
  let meta;
  let current;
  text_1 = new Text({
    props: {
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  meta = new Meta({
    props: {
      class: "material-icons",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(text_1.$$.fragment);
      t = space();
      create_component(meta.$$.fragment);
    },
    m(target, anchor) {
      mount_component(text_1, target, anchor);
      insert(target, t, anchor);
      mount_component(meta, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const text_1_changes = {};
      if (dirty & 256) {
        text_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      text_1.$set(text_1_changes);
      const meta_changes = {};
      if (dirty & 256) {
        meta_changes.$$scope = { dirty, ctx: ctx2 };
      }
      meta.$set(meta_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      transition_in(meta.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(text_1.$$.fragment, local);
      transition_out(meta.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(text_1, detaching);
      if (detaching)
        detach(t);
      destroy_component(meta, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("About");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("info");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5(ctx) {
  let text_1;
  let t;
  let meta;
  let current;
  text_1 = new Text({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  meta = new Meta({
    props: {
      class: "material-icons",
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(text_1.$$.fragment);
      t = space();
      create_component(meta.$$.fragment);
    },
    m(target, anchor) {
      mount_component(text_1, target, anchor);
      insert(target, t, anchor);
      mount_component(meta, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const text_1_changes = {};
      if (dirty & 256) {
        text_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      text_1.$set(text_1_changes);
      const meta_changes = {};
      if (dirty & 256) {
        meta_changes.$$scope = { dirty, ctx: ctx2 };
      }
      meta.$set(meta_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      transition_in(meta.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(text_1.$$.fragment, local);
      transition_out(meta.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(text_1, detaching);
      if (detaching)
        detach(t);
      destroy_component(meta, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let item0;
  let t0;
  let separator;
  let t1;
  let item1;
  let current;
  item0 = new Item({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  item0.$on("click", ctx[4]);
  separator = new Separator({});
  item1 = new Item({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  item1.$on("click", ctx[5]);
  return {
    c() {
      create_component(item0.$$.fragment);
      t0 = space();
      create_component(separator.$$.fragment);
      t1 = space();
      create_component(item1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(item0, target, anchor);
      insert(target, t0, anchor);
      mount_component(separator, target, anchor);
      insert(target, t1, anchor);
      mount_component(item1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const item0_changes = {};
      if (dirty & 256) {
        item0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      item0.$set(item0_changes);
      const item1_changes = {};
      if (dirty & 256) {
        item1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      item1.$set(item1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item0.$$.fragment, local);
      transition_in(separator.$$.fragment, local);
      transition_in(item1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item0.$$.fragment, local);
      transition_out(separator.$$.fragment, local);
      transition_out(item1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(item0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(separator, detaching);
      if (detaching)
        detach(t1);
      destroy_component(item1, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let list;
  let current;
  list = new List({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & 256) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let content;
  let current;
  content = new Content$1({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const content_changes = {};
      if (dirty & 256) {
        content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(content, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let flattoast;
  let current;
  flattoast = new FlatToast({ props: { data: ctx[7] } });
  return {
    c() {
      create_component(flattoast.$$.fragment);
    },
    m(target, anchor) {
      mount_component(flattoast, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const flattoast_changes = {};
      if (dirty & 128)
        flattoast_changes.data = ctx2[7];
      flattoast.$set(flattoast_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(flattoast.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flattoast.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(flattoast, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let div;
  let router;
  let t;
  let toastcontainer;
  let current;
  router = new Router({ props: { routes: ctx[1] } });
  toastcontainer = new ToastContainer({
    props: {
      placement: "bottom-center",
      theme: "dark",
      showProgress: true,
      $$slots: {
        default: [
          create_default_slot_1,
          ({ data }) => ({ 7: data }),
          ({ data }) => data ? 128 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(router.$$.fragment);
      t = space();
      create_component(toastcontainer.$$.fragment);
      attr(div, "class", "main-container svelte-195huik");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(router, div, null);
      insert(target, t, anchor);
      mount_component(toastcontainer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toastcontainer_changes = {};
      if (dirty & 384) {
        toastcontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toastcontainer.$set(toastcontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(router.$$.fragment, local);
      transition_in(toastcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(router.$$.fragment, local);
      transition_out(toastcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(router);
      if (detaching)
        detach(t);
      destroy_component(toastcontainer, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div2;
  let div0;
  let topappbar;
  let t0;
  let div1;
  let drawer;
  let updating_open;
  let t1;
  let scrim;
  let t2;
  let appcontent;
  let current;
  topappbar = new TopAppBar({
    props: {
      variant: "static",
      dense: true,
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  function drawer_open_binding(value) {
    ctx[6](value);
  }
  let drawer_props = {
    variant: "modal",
    style: "z-index: 2001;",
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    drawer_props.open = ctx[0];
  }
  drawer = new Drawer({ props: drawer_props });
  binding_callbacks.push(() => bind(drawer, "open", drawer_open_binding));
  scrim = new Scrim({ props: { style: "z-index: 2000;" } });
  appcontent = new AppContent({
    props: {
      style: "height: 100%;",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(topappbar.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(drawer.$$.fragment);
      t1 = space();
      create_component(scrim.$$.fragment);
      t2 = space();
      create_component(appcontent.$$.fragment);
      attr(div0, "class", "svelte-195huik");
      set_style(div1, "flex-grow", "1");
      attr(div1, "class", "svelte-195huik");
      attr(div2, "class", "main-wrapper svelte-195huik");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(topappbar, div0, null);
      append(div2, t0);
      append(div2, div1);
      mount_component(drawer, div1, null);
      append(div1, t1);
      mount_component(scrim, div1, null);
      append(div1, t2);
      mount_component(appcontent, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const topappbar_changes = {};
      if (dirty & 257) {
        topappbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topappbar.$set(topappbar_changes);
      const drawer_changes = {};
      if (dirty & 256) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & 1) {
        updating_open = true;
        drawer_changes.open = ctx2[0];
        add_flush_callback(() => updating_open = false);
      }
      drawer.$set(drawer_changes);
      const appcontent_changes = {};
      if (dirty & 256) {
        appcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      appcontent.$set(appcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topappbar.$$.fragment, local);
      transition_in(drawer.$$.fragment, local);
      transition_in(scrim.$$.fragment, local);
      transition_in(appcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topappbar.$$.fragment, local);
      transition_out(drawer.$$.fragment, local);
      transition_out(scrim.$$.fragment, local);
      transition_out(appcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(topappbar);
      destroy_component(drawer);
      destroy_component(scrim);
      destroy_component(appcontent);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const routes = { "/": Home, "/about": About };
  let drawerOpen = false;
  function goto(url) {
    $$invalidate(0, drawerOpen = false);
    push(url);
  }
  const click_handler = () => $$invalidate(0, drawerOpen = !drawerOpen);
  const click_handler_1 = () => goto("#/");
  const click_handler_2 = () => goto("#/about");
  function drawer_open_binding(value) {
    drawerOpen = value;
    $$invalidate(0, drawerOpen);
  }
  return [
    drawerOpen,
    routes,
    goto,
    click_handler,
    click_handler_1,
    click_handler_2,
    drawer_open_binding
  ];
}
class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}
!function(t, e, i) {
  function o(t2, e2) {
    for (; (t2 = t2.parentElement) && !t2.classList.contains(e2); )
      ;
    return t2;
  }
  L.drawVersion = "1.0.4", L.Draw = {}, L.drawLocal = { draw: { toolbar: { actions: { title: "Cancel drawing", text: "Cancel" }, finish: { title: "Finish drawing", text: "Finish" }, undo: { title: "Delete last point drawn", text: "Delete last point" }, buttons: { polyline: "Draw a polyline", polygon: "Draw a polygon", rectangle: "Draw a rectangle", circle: "Draw a circle", marker: "Draw a marker", circlemarker: "Draw a circlemarker" } }, handlers: { circle: { tooltip: { start: "Click and drag to draw circle." }, radius: "Radius" }, circlemarker: { tooltip: { start: "Click map to place circle marker." } }, marker: { tooltip: { start: "Click map to place marker." } }, polygon: { tooltip: { start: "Click to start drawing shape.", cont: "Click to continue drawing shape.", end: "Click first point to close this shape." } }, polyline: { error: "<strong>Error:</strong> shape edges cannot cross!", tooltip: { start: "Click to start drawing line.", cont: "Click to continue drawing line.", end: "Click last point to finish line." } }, rectangle: { tooltip: { start: "Click and drag to draw rectangle." } }, simpleshape: { tooltip: { end: "Release mouse to finish drawing." } } } }, edit: { toolbar: { actions: { save: { title: "Save changes", text: "Save" }, cancel: { title: "Cancel editing, discards all changes", text: "Cancel" }, clearAll: { title: "Clear all layers", text: "Clear All" } }, buttons: { edit: "Edit layers", editDisabled: "No layers to edit", remove: "Delete layers", removeDisabled: "No layers to delete" } }, handlers: { edit: { tooltip: { text: "Drag handles or markers to edit features.", subtext: "Click cancel to undo changes." } }, remove: { tooltip: { text: "Click on a feature to remove." } } } } }, L.Draw.Event = {}, L.Draw.Event.CREATED = "draw:created", L.Draw.Event.EDITED = "draw:edited", L.Draw.Event.DELETED = "draw:deleted", L.Draw.Event.DRAWSTART = "draw:drawstart", L.Draw.Event.DRAWSTOP = "draw:drawstop", L.Draw.Event.DRAWVERTEX = "draw:drawvertex", L.Draw.Event.EDITSTART = "draw:editstart", L.Draw.Event.EDITMOVE = "draw:editmove", L.Draw.Event.EDITRESIZE = "draw:editresize", L.Draw.Event.EDITVERTEX = "draw:editvertex", L.Draw.Event.EDITSTOP = "draw:editstop", L.Draw.Event.DELETESTART = "draw:deletestart", L.Draw.Event.DELETESTOP = "draw:deletestop", L.Draw.Event.TOOLBAROPENED = "draw:toolbaropened", L.Draw.Event.TOOLBARCLOSED = "draw:toolbarclosed", L.Draw.Event.MARKERCONTEXT = "draw:markercontext", L.Draw = L.Draw || {}, L.Draw.Feature = L.Handler.extend({ initialize: function(t2, e2) {
    this._map = t2, this._container = t2._container, this._overlayPane = t2._panes.overlayPane, this._popupPane = t2._panes.popupPane, e2 && e2.shapeOptions && (e2.shapeOptions = L.Util.extend({}, this.options.shapeOptions, e2.shapeOptions)), L.setOptions(this, e2);
    var i2 = L.version.split(".");
    parseInt(i2[0], 10) === 1 && parseInt(i2[1], 10) >= 2 ? L.Draw.Feature.include(L.Evented.prototype) : L.Draw.Feature.include(L.Mixin.Events);
  }, enable: function() {
    this._enabled || (L.Handler.prototype.enable.call(this), this.fire("enabled", { handler: this.type }), this._map.fire(L.Draw.Event.DRAWSTART, { layerType: this.type }));
  }, disable: function() {
    this._enabled && (L.Handler.prototype.disable.call(this), this._map.fire(L.Draw.Event.DRAWSTOP, { layerType: this.type }), this.fire("disabled", { handler: this.type }));
  }, addHooks: function() {
    var t2 = this._map;
    t2 && (L.DomUtil.disableTextSelection(), t2.getContainer().focus(), this._tooltip = new L.Draw.Tooltip(this._map), L.DomEvent.on(this._container, "keyup", this._cancelDrawing, this));
  }, removeHooks: function() {
    this._map && (L.DomUtil.enableTextSelection(), this._tooltip.dispose(), this._tooltip = null, L.DomEvent.off(this._container, "keyup", this._cancelDrawing, this));
  }, setOptions: function(t2) {
    L.setOptions(this, t2);
  }, _fireCreatedEvent: function(t2) {
    this._map.fire(L.Draw.Event.CREATED, { layer: t2, layerType: this.type });
  }, _cancelDrawing: function(t2) {
    t2.keyCode === 27 && (this._map.fire("draw:canceled", { layerType: this.type }), this.disable());
  } }), L.Draw.Polyline = L.Draw.Feature.extend({ statics: { TYPE: "polyline" }, Poly: L.Polyline, options: { allowIntersection: true, repeatMode: false, drawError: { color: "#b00b00", timeout: 2500 }, icon: new L.DivIcon({ iconSize: new L.Point(8, 8), className: "leaflet-div-icon leaflet-editing-icon" }), touchIcon: new L.DivIcon({ iconSize: new L.Point(20, 20), className: "leaflet-div-icon leaflet-editing-icon leaflet-touch-icon" }), guidelineDistance: 20, maxGuideLineLength: 4e3, shapeOptions: { stroke: true, color: "#3388ff", weight: 4, opacity: 0.5, fill: false, clickable: true }, metric: true, feet: true, nautic: false, showLength: true, zIndexOffset: 2e3, factor: 1, maxPoints: 0 }, initialize: function(t2, e2) {
    L.Browser.touch && (this.options.icon = this.options.touchIcon), this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error, e2 && e2.drawError && (e2.drawError = L.Util.extend({}, this.options.drawError, e2.drawError)), this.type = L.Draw.Polyline.TYPE, L.Draw.Feature.prototype.initialize.call(this, t2, e2);
  }, addHooks: function() {
    L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._markers = [], this._markerGroup = new L.LayerGroup(), this._map.addLayer(this._markerGroup), this._poly = new L.Polyline([], this.options.shapeOptions), this._tooltip.updateContent(this._getTooltipText()), this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), { icon: L.divIcon({ className: "leaflet-mouse-marker", iconAnchor: [20, 20], iconSize: [40, 40] }), opacity: 0, zIndexOffset: this.options.zIndexOffset })), this._mouseMarker.on("mouseout", this._onMouseOut, this).on("mousemove", this._onMouseMove, this).on("mousedown", this._onMouseDown, this).on("mouseup", this._onMouseUp, this).addTo(this._map), this._map.on("mouseup", this._onMouseUp, this).on("mousemove", this._onMouseMove, this).on("zoomlevelschange", this._onZoomEnd, this).on("touchstart", this._onTouch, this).on("zoomend", this._onZoomEnd, this));
  }, removeHooks: function() {
    L.Draw.Feature.prototype.removeHooks.call(this), this._clearHideErrorTimeout(), this._cleanUpShape(), this._map.removeLayer(this._markerGroup), delete this._markerGroup, delete this._markers, this._map.removeLayer(this._poly), delete this._poly, this._mouseMarker.off("mousedown", this._onMouseDown, this).off("mouseout", this._onMouseOut, this).off("mouseup", this._onMouseUp, this).off("mousemove", this._onMouseMove, this), this._map.removeLayer(this._mouseMarker), delete this._mouseMarker, this._clearGuides(), this._map.off("mouseup", this._onMouseUp, this).off("mousemove", this._onMouseMove, this).off("zoomlevelschange", this._onZoomEnd, this).off("zoomend", this._onZoomEnd, this).off("touchstart", this._onTouch, this).off("click", this._onTouch, this);
  }, deleteLastVertex: function() {
    if (!(this._markers.length <= 1)) {
      var t2 = this._markers.pop(), e2 = this._poly, i2 = e2.getLatLngs(), o2 = i2.splice(-1, 1)[0];
      this._poly.setLatLngs(i2), this._markerGroup.removeLayer(t2), e2.getLatLngs().length < 2 && this._map.removeLayer(e2), this._vertexChanged(o2, false);
    }
  }, addVertex: function(t2) {
    if (this._markers.length >= 2 && !this.options.allowIntersection && this._poly.newLatLngIntersects(t2))
      return void this._showErrorTooltip();
    this._errorShown && this._hideErrorTooltip(), this._markers.push(this._createMarker(t2)), this._poly.addLatLng(t2), this._poly.getLatLngs().length === 2 && this._map.addLayer(this._poly), this._vertexChanged(t2, true);
  }, completeShape: function() {
    this._markers.length <= 1 || !this._shapeIsValid() || (this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable());
  }, _finishShape: function() {
    var t2 = this._poly._defaultShape ? this._poly._defaultShape() : this._poly.getLatLngs(), e2 = this._poly.newLatLngIntersects(t2[t2.length - 1]);
    if (!this.options.allowIntersection && e2 || !this._shapeIsValid())
      return void this._showErrorTooltip();
    this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable();
  }, _shapeIsValid: function() {
    return true;
  }, _onZoomEnd: function() {
    this._markers !== null && this._updateGuide();
  }, _onMouseMove: function(t2) {
    var e2 = this._map.mouseEventToLayerPoint(t2.originalEvent), i2 = this._map.layerPointToLatLng(e2);
    this._currentLatLng = i2, this._updateTooltip(i2), this._updateGuide(e2), this._mouseMarker.setLatLng(i2), L.DomEvent.preventDefault(t2.originalEvent);
  }, _vertexChanged: function(t2, e2) {
    this._map.fire(L.Draw.Event.DRAWVERTEX, { layers: this._markerGroup }), this._updateFinishHandler(), this._updateRunningMeasure(t2, e2), this._clearGuides(), this._updateTooltip();
  }, _onMouseDown: function(t2) {
    if (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {
      this._onMouseMove(t2), this._clickHandled = true, this._disableNewMarkers();
      var e2 = t2.originalEvent, i2 = e2.clientX, o2 = e2.clientY;
      this._startPoint.call(this, i2, o2);
    }
  }, _startPoint: function(t2, e2) {
    this._mouseDownOrigin = L.point(t2, e2);
  }, _onMouseUp: function(t2) {
    var e2 = t2.originalEvent, i2 = e2.clientX, o2 = e2.clientY;
    this._endPoint.call(this, i2, o2, t2), this._clickHandled = null;
  }, _endPoint: function(e2, i2, o2) {
    if (this._mouseDownOrigin) {
      var a = L.point(e2, i2).distanceTo(this._mouseDownOrigin), n = this._calculateFinishDistance(o2.latlng);
      this.options.maxPoints > 1 && this.options.maxPoints == this._markers.length + 1 ? (this.addVertex(o2.latlng), this._finishShape()) : n < 10 && L.Browser.touch ? this._finishShape() : Math.abs(a) < 9 * (t.devicePixelRatio || 1) && this.addVertex(o2.latlng), this._enableNewMarkers();
    }
    this._mouseDownOrigin = null;
  }, _onTouch: function(t2) {
    var e2, i2, o2 = t2.originalEvent;
    !o2.touches || !o2.touches[0] || this._clickHandled || this._touchHandled || this._disableMarkers || (e2 = o2.touches[0].clientX, i2 = o2.touches[0].clientY, this._disableNewMarkers(), this._touchHandled = true, this._startPoint.call(this, e2, i2), this._endPoint.call(this, e2, i2, t2), this._touchHandled = null), this._clickHandled = null;
  }, _onMouseOut: function() {
    this._tooltip && this._tooltip._onMouseOut.call(this._tooltip);
  }, _calculateFinishDistance: function(t2) {
    var e2;
    if (this._markers.length > 0) {
      var i2;
      if (this.type === L.Draw.Polyline.TYPE)
        i2 = this._markers[this._markers.length - 1];
      else {
        if (this.type !== L.Draw.Polygon.TYPE)
          return 1 / 0;
        i2 = this._markers[0];
      }
      var o2 = this._map.latLngToContainerPoint(i2.getLatLng()), a = new L.Marker(t2, { icon: this.options.icon, zIndexOffset: 2 * this.options.zIndexOffset }), n = this._map.latLngToContainerPoint(a.getLatLng());
      e2 = o2.distanceTo(n);
    } else
      e2 = 1 / 0;
    return e2;
  }, _updateFinishHandler: function() {
    var t2 = this._markers.length;
    t2 > 1 && this._markers[t2 - 1].on("click", this._finishShape, this), t2 > 2 && this._markers[t2 - 2].off("click", this._finishShape, this);
  }, _createMarker: function(t2) {
    var e2 = new L.Marker(t2, { icon: this.options.icon, zIndexOffset: 2 * this.options.zIndexOffset });
    return this._markerGroup.addLayer(e2), e2;
  }, _updateGuide: function(t2) {
    var e2 = this._markers ? this._markers.length : 0;
    e2 > 0 && (t2 = t2 || this._map.latLngToLayerPoint(this._currentLatLng), this._clearGuides(), this._drawGuide(this._map.latLngToLayerPoint(this._markers[e2 - 1].getLatLng()), t2));
  }, _updateTooltip: function(t2) {
    var e2 = this._getTooltipText();
    t2 && this._tooltip.updatePosition(t2), this._errorShown || this._tooltip.updateContent(e2);
  }, _drawGuide: function(t2, e2) {
    var i2, o2, a, n = Math.floor(Math.sqrt(Math.pow(e2.x - t2.x, 2) + Math.pow(e2.y - t2.y, 2))), s = this.options.guidelineDistance, r = this.options.maxGuideLineLength, l = n > r ? n - r : s;
    for (this._guidesContainer || (this._guidesContainer = L.DomUtil.create("div", "leaflet-draw-guides", this._overlayPane)); l < n; l += this.options.guidelineDistance)
      i2 = l / n, o2 = { x: Math.floor(t2.x * (1 - i2) + i2 * e2.x), y: Math.floor(t2.y * (1 - i2) + i2 * e2.y) }, a = L.DomUtil.create("div", "leaflet-draw-guide-dash", this._guidesContainer), a.style.backgroundColor = this._errorShown ? this.options.drawError.color : this.options.shapeOptions.color, L.DomUtil.setPosition(a, o2);
  }, _updateGuideColor: function(t2) {
    if (this._guidesContainer)
      for (var e2 = 0, i2 = this._guidesContainer.childNodes.length; e2 < i2; e2++)
        this._guidesContainer.childNodes[e2].style.backgroundColor = t2;
  }, _clearGuides: function() {
    if (this._guidesContainer)
      for (; this._guidesContainer.firstChild; )
        this._guidesContainer.removeChild(this._guidesContainer.firstChild);
  }, _getTooltipText: function() {
    var t2, e2, i2 = this.options.showLength;
    return this._markers.length === 0 ? t2 = { text: L.drawLocal.draw.handlers.polyline.tooltip.start } : (e2 = i2 ? this._getMeasurementString() : "", t2 = this._markers.length === 1 ? { text: L.drawLocal.draw.handlers.polyline.tooltip.cont, subtext: e2 } : { text: L.drawLocal.draw.handlers.polyline.tooltip.end, subtext: e2 }), t2;
  }, _updateRunningMeasure: function(t2, e2) {
    var i2, o2, a = this._markers.length;
    this._markers.length === 1 ? this._measurementRunningTotal = 0 : (i2 = a - (e2 ? 2 : 1), o2 = L.GeometryUtil.isVersion07x() ? t2.distanceTo(this._markers[i2].getLatLng()) * (this.options.factor || 1) : this._map.distance(t2, this._markers[i2].getLatLng()) * (this.options.factor || 1), this._measurementRunningTotal += o2 * (e2 ? 1 : -1));
  }, _getMeasurementString: function() {
    var t2, e2 = this._currentLatLng, i2 = this._markers[this._markers.length - 1].getLatLng();
    return t2 = L.GeometryUtil.isVersion07x() ? i2 && e2 && e2.distanceTo ? this._measurementRunningTotal + e2.distanceTo(i2) * (this.options.factor || 1) : this._measurementRunningTotal || 0 : i2 && e2 ? this._measurementRunningTotal + this._map.distance(e2, i2) * (this.options.factor || 1) : this._measurementRunningTotal || 0, L.GeometryUtil.readableDistance(t2, this.options.metric, this.options.feet, this.options.nautic, this.options.precision);
  }, _showErrorTooltip: function() {
    this._errorShown = true, this._tooltip.showAsError().updateContent({ text: this.options.drawError.message }), this._updateGuideColor(this.options.drawError.color), this._poly.setStyle({ color: this.options.drawError.color }), this._clearHideErrorTimeout(), this._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);
  }, _hideErrorTooltip: function() {
    this._errorShown = false, this._clearHideErrorTimeout(), this._tooltip.removeError().updateContent(this._getTooltipText()), this._updateGuideColor(this.options.shapeOptions.color), this._poly.setStyle({ color: this.options.shapeOptions.color });
  }, _clearHideErrorTimeout: function() {
    this._hideErrorTimeout && (clearTimeout(this._hideErrorTimeout), this._hideErrorTimeout = null);
  }, _disableNewMarkers: function() {
    this._disableMarkers = true;
  }, _enableNewMarkers: function() {
    setTimeout(function() {
      this._disableMarkers = false;
    }.bind(this), 50);
  }, _cleanUpShape: function() {
    this._markers.length > 1 && this._markers[this._markers.length - 1].off("click", this._finishShape, this);
  }, _fireCreatedEvent: function() {
    var t2 = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);
    L.Draw.Feature.prototype._fireCreatedEvent.call(this, t2);
  } }), L.Draw.Polygon = L.Draw.Polyline.extend({ statics: { TYPE: "polygon" }, Poly: L.Polygon, options: { showArea: false, showLength: false, shapeOptions: { stroke: true, color: "#3388ff", weight: 4, opacity: 0.5, fill: true, fillColor: null, fillOpacity: 0.2, clickable: true }, metric: true, feet: true, nautic: false, precision: {} }, initialize: function(t2, e2) {
    L.Draw.Polyline.prototype.initialize.call(this, t2, e2), this.type = L.Draw.Polygon.TYPE;
  }, _updateFinishHandler: function() {
    var t2 = this._markers.length;
    t2 === 1 && this._markers[0].on("click", this._finishShape, this), t2 > 2 && (this._markers[t2 - 1].on("dblclick", this._finishShape, this), t2 > 3 && this._markers[t2 - 2].off("dblclick", this._finishShape, this));
  }, _getTooltipText: function() {
    var t2, e2;
    return this._markers.length === 0 ? t2 = L.drawLocal.draw.handlers.polygon.tooltip.start : this._markers.length < 3 ? (t2 = L.drawLocal.draw.handlers.polygon.tooltip.cont, e2 = this._getMeasurementString()) : (t2 = L.drawLocal.draw.handlers.polygon.tooltip.end, e2 = this._getMeasurementString()), { text: t2, subtext: e2 };
  }, _getMeasurementString: function() {
    var t2 = this._area, e2 = "";
    return t2 || this.options.showLength ? (this.options.showLength && (e2 = L.Draw.Polyline.prototype._getMeasurementString.call(this)), t2 && (e2 += "<br>" + L.GeometryUtil.readableArea(t2, this.options.metric, this.options.precision)), e2) : null;
  }, _shapeIsValid: function() {
    return this._markers.length >= 3;
  }, _vertexChanged: function(t2, e2) {
    var i2;
    !this.options.allowIntersection && this.options.showArea && (i2 = this._poly.getLatLngs(), this._area = L.GeometryUtil.geodesicArea(i2)), L.Draw.Polyline.prototype._vertexChanged.call(this, t2, e2);
  }, _cleanUpShape: function() {
    var t2 = this._markers.length;
    t2 > 0 && (this._markers[0].off("click", this._finishShape, this), t2 > 2 && this._markers[t2 - 1].off("dblclick", this._finishShape, this));
  } }), L.SimpleShape = {}, L.Draw.SimpleShape = L.Draw.Feature.extend({ options: { repeatMode: false }, initialize: function(t2, e2) {
    this._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end, L.Draw.Feature.prototype.initialize.call(this, t2, e2);
  }, addHooks: function() {
    L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._mapDraggable = this._map.dragging.enabled(), this._mapDraggable && this._map.dragging.disable(), this._container.style.cursor = "crosshair", this._tooltip.updateContent({ text: this._initialLabelText }), this._map.on("mousedown", this._onMouseDown, this).on("mousemove", this._onMouseMove, this).on("touchstart", this._onMouseDown, this).on("touchmove", this._onMouseMove, this), e.addEventListener("touchstart", L.DomEvent.preventDefault, { passive: false }));
  }, removeHooks: function() {
    L.Draw.Feature.prototype.removeHooks.call(this), this._map && (this._mapDraggable && this._map.dragging.enable(), this._container.style.cursor = "", this._map.off("mousedown", this._onMouseDown, this).off("mousemove", this._onMouseMove, this).off("touchstart", this._onMouseDown, this).off("touchmove", this._onMouseMove, this), L.DomEvent.off(e, "mouseup", this._onMouseUp, this), L.DomEvent.off(e, "touchend", this._onMouseUp, this), e.removeEventListener("touchstart", L.DomEvent.preventDefault), this._shape && (this._map.removeLayer(this._shape), delete this._shape)), this._isDrawing = false;
  }, _getTooltipText: function() {
    return { text: this._endLabelText };
  }, _onMouseDown: function(t2) {
    this._isDrawing = true, this._startLatLng = t2.latlng, L.DomEvent.on(e, "mouseup", this._onMouseUp, this).on(e, "touchend", this._onMouseUp, this).preventDefault(t2.originalEvent);
  }, _onMouseMove: function(t2) {
    var e2 = t2.latlng;
    this._tooltip.updatePosition(e2), this._isDrawing && (this._tooltip.updateContent(this._getTooltipText()), this._drawShape(e2));
  }, _onMouseUp: function() {
    this._shape && this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable();
  } }), L.Draw.Rectangle = L.Draw.SimpleShape.extend({ statics: { TYPE: "rectangle" }, options: { shapeOptions: { stroke: true, color: "#3388ff", weight: 4, opacity: 0.5, fill: true, fillColor: null, fillOpacity: 0.2, clickable: true }, showArea: true, metric: true }, initialize: function(t2, e2) {
    this.type = L.Draw.Rectangle.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start, L.Draw.SimpleShape.prototype.initialize.call(this, t2, e2);
  }, disable: function() {
    this._enabled && (this._isCurrentlyTwoClickDrawing = false, L.Draw.SimpleShape.prototype.disable.call(this));
  }, _onMouseUp: function(t2) {
    if (!this._shape && !this._isCurrentlyTwoClickDrawing)
      return void (this._isCurrentlyTwoClickDrawing = true);
    this._isCurrentlyTwoClickDrawing && !o(t2.target, "leaflet-pane") || L.Draw.SimpleShape.prototype._onMouseUp.call(this);
  }, _drawShape: function(t2) {
    this._shape ? this._shape.setBounds(new L.LatLngBounds(this._startLatLng, t2)) : (this._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, t2), this.options.shapeOptions), this._map.addLayer(this._shape));
  }, _fireCreatedEvent: function() {
    var t2 = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);
    L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, t2);
  }, _getTooltipText: function() {
    var t2, e2, i2, o2 = L.Draw.SimpleShape.prototype._getTooltipText.call(this), a = this._shape, n = this.options.showArea;
    return a && (t2 = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(), e2 = L.GeometryUtil.geodesicArea(t2), i2 = n ? L.GeometryUtil.readableArea(e2, this.options.metric) : ""), { text: o2.text, subtext: i2 };
  } }), L.Draw.Marker = L.Draw.Feature.extend({ statics: { TYPE: "marker" }, options: { icon: new L.Icon.Default(), repeatMode: false, zIndexOffset: 2e3 }, initialize: function(t2, e2) {
    this.type = L.Draw.Marker.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.marker.tooltip.start, L.Draw.Feature.prototype.initialize.call(this, t2, e2);
  }, addHooks: function() {
    L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._tooltip.updateContent({ text: this._initialLabelText }), this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), { icon: L.divIcon({ className: "leaflet-mouse-marker", iconAnchor: [20, 20], iconSize: [40, 40] }), opacity: 0, zIndexOffset: this.options.zIndexOffset })), this._mouseMarker.on("click", this._onClick, this).addTo(this._map), this._map.on("mousemove", this._onMouseMove, this), this._map.on("click", this._onTouch, this));
  }, removeHooks: function() {
    L.Draw.Feature.prototype.removeHooks.call(this), this._map && (this._map.off("click", this._onClick, this).off("click", this._onTouch, this), this._marker && (this._marker.off("click", this._onClick, this), this._map.removeLayer(this._marker), delete this._marker), this._mouseMarker.off("click", this._onClick, this), this._map.removeLayer(this._mouseMarker), delete this._mouseMarker, this._map.off("mousemove", this._onMouseMove, this));
  }, _onMouseMove: function(t2) {
    var e2 = t2.latlng;
    this._tooltip.updatePosition(e2), this._mouseMarker.setLatLng(e2), this._marker ? (e2 = this._mouseMarker.getLatLng(), this._marker.setLatLng(e2)) : (this._marker = this._createMarker(e2), this._marker.on("click", this._onClick, this), this._map.on("click", this._onClick, this).addLayer(this._marker));
  }, _createMarker: function(t2) {
    return new L.Marker(t2, { icon: this.options.icon, zIndexOffset: this.options.zIndexOffset });
  }, _onClick: function() {
    this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable();
  }, _onTouch: function(t2) {
    this._onMouseMove(t2), this._onClick();
  }, _fireCreatedEvent: function() {
    var t2 = new L.Marker.Touch(this._marker.getLatLng(), { icon: this.options.icon });
    L.Draw.Feature.prototype._fireCreatedEvent.call(this, t2);
  } }), L.Draw.CircleMarker = L.Draw.Marker.extend({ statics: { TYPE: "circlemarker" }, options: { stroke: true, color: "#3388ff", weight: 4, opacity: 0.5, fill: true, fillColor: null, fillOpacity: 0.2, clickable: true, zIndexOffset: 2e3 }, initialize: function(t2, e2) {
    this.type = L.Draw.CircleMarker.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.circlemarker.tooltip.start, L.Draw.Feature.prototype.initialize.call(this, t2, e2);
  }, _fireCreatedEvent: function() {
    var t2 = new L.CircleMarker(this._marker.getLatLng(), this.options);
    L.Draw.Feature.prototype._fireCreatedEvent.call(this, t2);
  }, _createMarker: function(t2) {
    return new L.CircleMarker(t2, this.options);
  } }), L.Draw.Circle = L.Draw.SimpleShape.extend({ statics: { TYPE: "circle" }, options: { shapeOptions: { stroke: true, color: "#3388ff", weight: 4, opacity: 0.5, fill: true, fillColor: null, fillOpacity: 0.2, clickable: true }, showRadius: true, metric: true, feet: true, nautic: false }, initialize: function(t2, e2) {
    this.type = L.Draw.Circle.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start, L.Draw.SimpleShape.prototype.initialize.call(this, t2, e2);
  }, _drawShape: function(t2) {
    if (L.GeometryUtil.isVersion07x())
      var e2 = this._startLatLng.distanceTo(t2);
    else
      var e2 = this._map.distance(this._startLatLng, t2);
    this._shape ? this._shape.setRadius(e2) : (this._shape = new L.Circle(this._startLatLng, e2, this.options.shapeOptions), this._map.addLayer(this._shape));
  }, _fireCreatedEvent: function() {
    var t2 = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);
    L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, t2);
  }, _onMouseMove: function(t2) {
    var e2, i2 = t2.latlng, o2 = this.options.showRadius, a = this.options.metric;
    if (this._tooltip.updatePosition(i2), this._isDrawing) {
      this._drawShape(i2), e2 = this._shape.getRadius().toFixed(1);
      var n = "";
      o2 && (n = L.drawLocal.draw.handlers.circle.radius + ": " + L.GeometryUtil.readableDistance(e2, a, this.options.feet, this.options.nautic)), this._tooltip.updateContent({ text: this._endLabelText, subtext: n });
    }
  } }), L.Edit = L.Edit || {}, L.Edit.Marker = L.Handler.extend({ initialize: function(t2, e2) {
    this._marker = t2, L.setOptions(this, e2);
  }, addHooks: function() {
    var t2 = this._marker;
    t2.dragging.enable(), t2.on("dragend", this._onDragEnd, t2), this._toggleMarkerHighlight();
  }, removeHooks: function() {
    var t2 = this._marker;
    t2.dragging.disable(), t2.off("dragend", this._onDragEnd, t2), this._toggleMarkerHighlight();
  }, _onDragEnd: function(t2) {
    var e2 = t2.target;
    e2.edited = true, this._map.fire(L.Draw.Event.EDITMOVE, { layer: e2 });
  }, _toggleMarkerHighlight: function() {
    var t2 = this._marker._icon;
    t2 && (t2.style.display = "none", L.DomUtil.hasClass(t2, "leaflet-edit-marker-selected") ? (L.DomUtil.removeClass(t2, "leaflet-edit-marker-selected"), this._offsetMarker(t2, -4)) : (L.DomUtil.addClass(t2, "leaflet-edit-marker-selected"), this._offsetMarker(t2, 4)), t2.style.display = "");
  }, _offsetMarker: function(t2, e2) {
    var i2 = parseInt(t2.style.marginTop, 10) - e2, o2 = parseInt(t2.style.marginLeft, 10) - e2;
    t2.style.marginTop = i2 + "px", t2.style.marginLeft = o2 + "px";
  } }), L.Marker.addInitHook(function() {
    L.Edit.Marker && (this.editing = new L.Edit.Marker(this), this.options.editable && this.editing.enable());
  }), L.Edit = L.Edit || {}, L.Edit.Poly = L.Handler.extend({ initialize: function(t2) {
    this.latlngs = [t2._latlngs], t2._holes && (this.latlngs = this.latlngs.concat(t2._holes)), this._poly = t2, this._poly.on("revert-edited", this._updateLatLngs, this);
  }, _defaultShape: function() {
    return L.Polyline._flat ? L.Polyline._flat(this._poly._latlngs) ? this._poly._latlngs : this._poly._latlngs[0] : this._poly._latlngs;
  }, _eachVertexHandler: function(t2) {
    for (var e2 = 0; e2 < this._verticesHandlers.length; e2++)
      t2(this._verticesHandlers[e2]);
  }, addHooks: function() {
    this._initHandlers(), this._eachVertexHandler(function(t2) {
      t2.addHooks();
    });
  }, removeHooks: function() {
    this._eachVertexHandler(function(t2) {
      t2.removeHooks();
    });
  }, updateMarkers: function() {
    this._eachVertexHandler(function(t2) {
      t2.updateMarkers();
    });
  }, _initHandlers: function() {
    this._verticesHandlers = [];
    for (var t2 = 0; t2 < this.latlngs.length; t2++)
      this._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly, this.latlngs[t2], this._poly.options.poly));
  }, _updateLatLngs: function(t2) {
    this.latlngs = [t2.layer._latlngs], t2.layer._holes && (this.latlngs = this.latlngs.concat(t2.layer._holes));
  } }), L.Edit.PolyVerticesEdit = L.Handler.extend({ options: { icon: new L.DivIcon({ iconSize: new L.Point(8, 8), className: "leaflet-div-icon leaflet-editing-icon" }), touchIcon: new L.DivIcon({ iconSize: new L.Point(20, 20), className: "leaflet-div-icon leaflet-editing-icon leaflet-touch-icon" }), drawError: { color: "#b00b00", timeout: 1e3 } }, initialize: function(t2, e2, i2) {
    L.Browser.touch && (this.options.icon = this.options.touchIcon), this._poly = t2, i2 && i2.drawError && (i2.drawError = L.Util.extend({}, this.options.drawError, i2.drawError)), this._latlngs = e2, L.setOptions(this, i2);
  }, _defaultShape: function() {
    return L.Polyline._flat ? L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0] : this._latlngs;
  }, addHooks: function() {
    var t2 = this._poly, e2 = t2._path;
    t2 instanceof L.Polygon || (t2.options.fill = false, t2.options.editing && (t2.options.editing.fill = false)), e2 && t2.options.editing && t2.options.editing.className && (t2.options.original.className && t2.options.original.className.split(" ").forEach(function(t3) {
      L.DomUtil.removeClass(e2, t3);
    }), t2.options.editing.className.split(" ").forEach(function(t3) {
      L.DomUtil.addClass(e2, t3);
    })), t2.setStyle(t2.options.editing), this._poly._map && (this._map = this._poly._map, this._markerGroup || this._initMarkers(), this._poly._map.addLayer(this._markerGroup));
  }, removeHooks: function() {
    var t2 = this._poly, e2 = t2._path;
    e2 && t2.options.editing && t2.options.editing.className && (t2.options.editing.className.split(" ").forEach(function(t3) {
      L.DomUtil.removeClass(e2, t3);
    }), t2.options.original.className && t2.options.original.className.split(" ").forEach(function(t3) {
      L.DomUtil.addClass(e2, t3);
    })), t2.setStyle(t2.options.original), t2._map && (t2._map.removeLayer(this._markerGroup), delete this._markerGroup, delete this._markers);
  }, updateMarkers: function() {
    this._markerGroup.clearLayers(), this._initMarkers();
  }, _initMarkers: function() {
    this._markerGroup || (this._markerGroup = new L.LayerGroup()), this._markers = [];
    var t2, e2, i2, o2, a = this._defaultShape();
    for (t2 = 0, i2 = a.length; t2 < i2; t2++)
      o2 = this._createMarker(a[t2], t2), o2.on("click", this._onMarkerClick, this), o2.on("contextmenu", this._onContextMenu, this), this._markers.push(o2);
    var n, s;
    for (t2 = 0, e2 = i2 - 1; t2 < i2; e2 = t2++)
      (t2 !== 0 || L.Polygon && this._poly instanceof L.Polygon) && (n = this._markers[e2], s = this._markers[t2], this._createMiddleMarker(n, s), this._updatePrevNext(n, s));
  }, _createMarker: function(t2, e2) {
    var i2 = new L.Marker.Touch(t2, { draggable: true, icon: this.options.icon });
    return i2._origLatLng = t2, i2._index = e2, i2.on("dragstart", this._onMarkerDragStart, this).on("drag", this._onMarkerDrag, this).on("dragend", this._fireEdit, this).on("touchmove", this._onTouchMove, this).on("touchend", this._fireEdit, this).on("MSPointerMove", this._onTouchMove, this).on("MSPointerUp", this._fireEdit, this), this._markerGroup.addLayer(i2), i2;
  }, _onMarkerDragStart: function() {
    this._poly.fire("editstart");
  }, _spliceLatLngs: function() {
    var t2 = this._defaultShape(), e2 = [].splice.apply(t2, arguments);
    return this._poly._convertLatLngs(t2, true), this._poly.redraw(), e2;
  }, _removeMarker: function(t2) {
    var e2 = t2._index;
    this._markerGroup.removeLayer(t2), this._markers.splice(e2, 1), this._spliceLatLngs(e2, 1), this._updateIndexes(e2, -1), t2.off("dragstart", this._onMarkerDragStart, this).off("drag", this._onMarkerDrag, this).off("dragend", this._fireEdit, this).off("touchmove", this._onMarkerDrag, this).off("touchend", this._fireEdit, this).off("click", this._onMarkerClick, this).off("MSPointerMove", this._onTouchMove, this).off("MSPointerUp", this._fireEdit, this);
  }, _fireEdit: function() {
    this._poly.edited = true, this._poly.fire("edit"), this._poly._map.fire(L.Draw.Event.EDITVERTEX, { layers: this._markerGroup, poly: this._poly });
  }, _onMarkerDrag: function(t2) {
    var e2 = t2.target, i2 = this._poly, o2 = L.LatLngUtil.cloneLatLng(e2._origLatLng);
    if (L.extend(e2._origLatLng, e2._latlng), i2.options.poly) {
      var a = i2._map._editTooltip;
      if (!i2.options.poly.allowIntersection && i2.intersects()) {
        L.extend(e2._origLatLng, o2), e2.setLatLng(o2);
        var n = i2.options.color;
        i2.setStyle({ color: this.options.drawError.color }), a && a.updateContent({ text: L.drawLocal.draw.handlers.polyline.error }), setTimeout(function() {
          i2.setStyle({ color: n }), a && a.updateContent({ text: L.drawLocal.edit.handlers.edit.tooltip.text, subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext });
        }, 1e3);
      }
    }
    e2._middleLeft && e2._middleLeft.setLatLng(this._getMiddleLatLng(e2._prev, e2)), e2._middleRight && e2._middleRight.setLatLng(this._getMiddleLatLng(e2, e2._next)), this._poly._bounds._southWest = L.latLng(1 / 0, 1 / 0), this._poly._bounds._northEast = L.latLng(-1 / 0, -1 / 0);
    var s = this._poly.getLatLngs();
    this._poly._convertLatLngs(s, true), this._poly.redraw(), this._poly.fire("editdrag");
  }, _onMarkerClick: function(t2) {
    var e2 = L.Polygon && this._poly instanceof L.Polygon ? 4 : 3, i2 = t2.target;
    this._defaultShape().length < e2 || (this._removeMarker(i2), this._updatePrevNext(i2._prev, i2._next), i2._middleLeft && this._markerGroup.removeLayer(i2._middleLeft), i2._middleRight && this._markerGroup.removeLayer(i2._middleRight), i2._prev && i2._next ? this._createMiddleMarker(i2._prev, i2._next) : i2._prev ? i2._next || (i2._prev._middleRight = null) : i2._next._middleLeft = null, this._fireEdit());
  }, _onContextMenu: function(t2) {
    var e2 = t2.target;
    this._poly;
    this._poly._map.fire(L.Draw.Event.MARKERCONTEXT, { marker: e2, layers: this._markerGroup, poly: this._poly }), L.DomEvent.stopPropagation;
  }, _onTouchMove: function(t2) {
    var e2 = this._map.mouseEventToLayerPoint(t2.originalEvent.touches[0]), i2 = this._map.layerPointToLatLng(e2), o2 = t2.target;
    L.extend(o2._origLatLng, i2), o2._middleLeft && o2._middleLeft.setLatLng(this._getMiddleLatLng(o2._prev, o2)), o2._middleRight && o2._middleRight.setLatLng(this._getMiddleLatLng(o2, o2._next)), this._poly.redraw(), this.updateMarkers();
  }, _updateIndexes: function(t2, e2) {
    this._markerGroup.eachLayer(function(i2) {
      i2._index > t2 && (i2._index += e2);
    });
  }, _createMiddleMarker: function(t2, e2) {
    var i2, o2, a, n = this._getMiddleLatLng(t2, e2), s = this._createMarker(n);
    s.setOpacity(0.6), t2._middleRight = e2._middleLeft = s, o2 = function() {
      s.off("touchmove", o2, this);
      var a2 = e2._index;
      s._index = a2, s.off("click", i2, this).on("click", this._onMarkerClick, this), n.lat = s.getLatLng().lat, n.lng = s.getLatLng().lng, this._spliceLatLngs(a2, 0, n), this._markers.splice(a2, 0, s), s.setOpacity(1), this._updateIndexes(a2, 1), e2._index++, this._updatePrevNext(t2, s), this._updatePrevNext(s, e2), this._poly.fire("editstart");
    }, a = function() {
      s.off("dragstart", o2, this), s.off("dragend", a, this), s.off("touchmove", o2, this), this._createMiddleMarker(t2, s), this._createMiddleMarker(s, e2);
    }, i2 = function() {
      o2.call(this), a.call(this), this._fireEdit();
    }, s.on("click", i2, this).on("dragstart", o2, this).on("dragend", a, this).on("touchmove", o2, this), this._markerGroup.addLayer(s);
  }, _updatePrevNext: function(t2, e2) {
    t2 && (t2._next = e2), e2 && (e2._prev = t2);
  }, _getMiddleLatLng: function(t2, e2) {
    var i2 = this._poly._map, o2 = i2.project(t2.getLatLng()), a = i2.project(e2.getLatLng());
    return i2.unproject(o2._add(a)._divideBy(2));
  } }), L.Polyline.addInitHook(function() {
    this.editing || (L.Edit.Poly && (this.editing = new L.Edit.Poly(this), this.options.editable && this.editing.enable()), this.on("add", function() {
      this.editing && this.editing.enabled() && this.editing.addHooks();
    }), this.on("remove", function() {
      this.editing && this.editing.enabled() && this.editing.removeHooks();
    }));
  }), L.Edit = L.Edit || {}, L.Edit.SimpleShape = L.Handler.extend({ options: { moveIcon: new L.DivIcon({ iconSize: new L.Point(8, 8), className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-move" }), resizeIcon: new L.DivIcon({
    iconSize: new L.Point(8, 8),
    className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"
  }), touchMoveIcon: new L.DivIcon({ iconSize: new L.Point(20, 20), className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon" }), touchResizeIcon: new L.DivIcon({ iconSize: new L.Point(20, 20), className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon" }) }, initialize: function(t2, e2) {
    L.Browser.touch && (this.options.moveIcon = this.options.touchMoveIcon, this.options.resizeIcon = this.options.touchResizeIcon), this._shape = t2, L.Util.setOptions(this, e2);
  }, addHooks: function() {
    var t2 = this._shape;
    this._shape._map && (this._map = this._shape._map, t2.setStyle(t2.options.editing), t2._map && (this._map = t2._map, this._markerGroup || this._initMarkers(), this._map.addLayer(this._markerGroup)));
  }, removeHooks: function() {
    var t2 = this._shape;
    if (t2.setStyle(t2.options.original), t2._map) {
      this._unbindMarker(this._moveMarker);
      for (var e2 = 0, i2 = this._resizeMarkers.length; e2 < i2; e2++)
        this._unbindMarker(this._resizeMarkers[e2]);
      this._resizeMarkers = null, this._map.removeLayer(this._markerGroup), delete this._markerGroup;
    }
    this._map = null;
  }, updateMarkers: function() {
    this._markerGroup.clearLayers(), this._initMarkers();
  }, _initMarkers: function() {
    this._markerGroup || (this._markerGroup = new L.LayerGroup()), this._createMoveMarker(), this._createResizeMarker();
  }, _createMoveMarker: function() {
  }, _createResizeMarker: function() {
  }, _createMarker: function(t2, e2) {
    var i2 = new L.Marker.Touch(t2, { draggable: true, icon: e2, zIndexOffset: 10 });
    return this._bindMarker(i2), this._markerGroup.addLayer(i2), i2;
  }, _bindMarker: function(t2) {
    t2.on("dragstart", this._onMarkerDragStart, this).on("drag", this._onMarkerDrag, this).on("dragend", this._onMarkerDragEnd, this).on("touchstart", this._onTouchStart, this).on("touchmove", this._onTouchMove, this).on("MSPointerMove", this._onTouchMove, this).on("touchend", this._onTouchEnd, this).on("MSPointerUp", this._onTouchEnd, this);
  }, _unbindMarker: function(t2) {
    t2.off("dragstart", this._onMarkerDragStart, this).off("drag", this._onMarkerDrag, this).off("dragend", this._onMarkerDragEnd, this).off("touchstart", this._onTouchStart, this).off("touchmove", this._onTouchMove, this).off("MSPointerMove", this._onTouchMove, this).off("touchend", this._onTouchEnd, this).off("MSPointerUp", this._onTouchEnd, this);
  }, _onMarkerDragStart: function(t2) {
    t2.target.setOpacity(0), this._shape.fire("editstart");
  }, _fireEdit: function() {
    this._shape.edited = true, this._shape.fire("edit");
  }, _onMarkerDrag: function(t2) {
    var e2 = t2.target, i2 = e2.getLatLng();
    e2 === this._moveMarker ? this._move(i2) : this._resize(i2), this._shape.redraw(), this._shape.fire("editdrag");
  }, _onMarkerDragEnd: function(t2) {
    t2.target.setOpacity(1), this._fireEdit();
  }, _onTouchStart: function(t2) {
    if (L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, t2), typeof this._getCorners == "function") {
      var e2 = this._getCorners(), i2 = t2.target, o2 = i2._cornerIndex;
      i2.setOpacity(0), this._oppositeCorner = e2[(o2 + 2) % 4], this._toggleCornerMarkers(0, o2);
    }
    this._shape.fire("editstart");
  }, _onTouchMove: function(t2) {
    var e2 = this._map.mouseEventToLayerPoint(t2.originalEvent.touches[0]), i2 = this._map.layerPointToLatLng(e2);
    return t2.target === this._moveMarker ? this._move(i2) : this._resize(i2), this._shape.redraw(), false;
  }, _onTouchEnd: function(t2) {
    t2.target.setOpacity(1), this.updateMarkers(), this._fireEdit();
  }, _move: function() {
  }, _resize: function() {
  } }), L.Edit = L.Edit || {}, L.Edit.Rectangle = L.Edit.SimpleShape.extend({ _createMoveMarker: function() {
    var t2 = this._shape.getBounds(), e2 = t2.getCenter();
    this._moveMarker = this._createMarker(e2, this.options.moveIcon);
  }, _createResizeMarker: function() {
    var t2 = this._getCorners();
    this._resizeMarkers = [];
    for (var e2 = 0, i2 = t2.length; e2 < i2; e2++)
      this._resizeMarkers.push(this._createMarker(t2[e2], this.options.resizeIcon)), this._resizeMarkers[e2]._cornerIndex = e2;
  }, _onMarkerDragStart: function(t2) {
    L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, t2);
    var e2 = this._getCorners(), i2 = t2.target, o2 = i2._cornerIndex;
    this._oppositeCorner = e2[(o2 + 2) % 4], this._toggleCornerMarkers(0, o2);
  }, _onMarkerDragEnd: function(t2) {
    var e2, i2, o2 = t2.target;
    o2 === this._moveMarker && (e2 = this._shape.getBounds(), i2 = e2.getCenter(), o2.setLatLng(i2)), this._toggleCornerMarkers(1), this._repositionCornerMarkers(), L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, t2);
  }, _move: function(t2) {
    for (var e2, i2 = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(), o2 = this._shape.getBounds(), a = o2.getCenter(), n = [], s = 0, r = i2.length; s < r; s++)
      e2 = [i2[s].lat - a.lat, i2[s].lng - a.lng], n.push([t2.lat + e2[0], t2.lng + e2[1]]);
    this._shape.setLatLngs(n), this._repositionCornerMarkers(), this._map.fire(L.Draw.Event.EDITMOVE, { layer: this._shape });
  }, _resize: function(t2) {
    var e2;
    this._shape.setBounds(L.latLngBounds(t2, this._oppositeCorner)), e2 = this._shape.getBounds(), this._moveMarker.setLatLng(e2.getCenter()), this._map.fire(L.Draw.Event.EDITRESIZE, { layer: this._shape });
  }, _getCorners: function() {
    var t2 = this._shape.getBounds();
    return [t2.getNorthWest(), t2.getNorthEast(), t2.getSouthEast(), t2.getSouthWest()];
  }, _toggleCornerMarkers: function(t2) {
    for (var e2 = 0, i2 = this._resizeMarkers.length; e2 < i2; e2++)
      this._resizeMarkers[e2].setOpacity(t2);
  }, _repositionCornerMarkers: function() {
    for (var t2 = this._getCorners(), e2 = 0, i2 = this._resizeMarkers.length; e2 < i2; e2++)
      this._resizeMarkers[e2].setLatLng(t2[e2]);
  } }), L.Rectangle.addInitHook(function() {
    L.Edit.Rectangle && (this.editing = new L.Edit.Rectangle(this), this.options.editable && this.editing.enable());
  }), L.Edit = L.Edit || {}, L.Edit.CircleMarker = L.Edit.SimpleShape.extend({ _createMoveMarker: function() {
    var t2 = this._shape.getLatLng();
    this._moveMarker = this._createMarker(t2, this.options.moveIcon);
  }, _createResizeMarker: function() {
    this._resizeMarkers = [];
  }, _move: function(t2) {
    if (this._resizeMarkers.length) {
      var e2 = this._getResizeMarkerPoint(t2);
      this._resizeMarkers[0].setLatLng(e2);
    }
    this._shape.setLatLng(t2), this._map.fire(L.Draw.Event.EDITMOVE, { layer: this._shape });
  } }), L.CircleMarker.addInitHook(function() {
    L.Edit.CircleMarker && (this.editing = new L.Edit.CircleMarker(this), this.options.editable && this.editing.enable()), this.on("add", function() {
      this.editing && this.editing.enabled() && this.editing.addHooks();
    }), this.on("remove", function() {
      this.editing && this.editing.enabled() && this.editing.removeHooks();
    });
  }), L.Edit = L.Edit || {}, L.Edit.Circle = L.Edit.CircleMarker.extend({ _createResizeMarker: function() {
    var t2 = this._shape.getLatLng(), e2 = this._getResizeMarkerPoint(t2);
    this._resizeMarkers = [], this._resizeMarkers.push(this._createMarker(e2, this.options.resizeIcon));
  }, _getResizeMarkerPoint: function(t2) {
    var e2 = this._shape._radius * Math.cos(Math.PI / 4), i2 = this._map.project(t2);
    return this._map.unproject([i2.x + e2, i2.y - e2]);
  }, _resize: function(t2) {
    var e2 = this._moveMarker.getLatLng();
    L.GeometryUtil.isVersion07x() ? radius = e2.distanceTo(t2) : radius = this._map.distance(e2, t2), this._shape.setRadius(radius), this._map.editTooltip && this._map._editTooltip.updateContent({ text: L.drawLocal.edit.handlers.edit.tooltip.subtext + "<br />" + L.drawLocal.edit.handlers.edit.tooltip.text, subtext: L.drawLocal.draw.handlers.circle.radius + ": " + L.GeometryUtil.readableDistance(radius, true, this.options.feet, this.options.nautic) }), this._shape.setRadius(radius), this._map.fire(L.Draw.Event.EDITRESIZE, { layer: this._shape });
  } }), L.Circle.addInitHook(function() {
    L.Edit.Circle && (this.editing = new L.Edit.Circle(this), this.options.editable && this.editing.enable());
  }), L.Map.mergeOptions({ touchExtend: true }), L.Map.TouchExtend = L.Handler.extend({ initialize: function(t2) {
    this._map = t2, this._container = t2._container, this._pane = t2._panes.overlayPane;
  }, addHooks: function() {
    L.DomEvent.on(this._container, "touchstart", this._onTouchStart, this), L.DomEvent.on(this._container, "touchend", this._onTouchEnd, this), L.DomEvent.on(this._container, "touchmove", this._onTouchMove, this), this._detectIE() ? (L.DomEvent.on(this._container, "MSPointerDown", this._onTouchStart, this), L.DomEvent.on(this._container, "MSPointerUp", this._onTouchEnd, this), L.DomEvent.on(this._container, "MSPointerMove", this._onTouchMove, this), L.DomEvent.on(this._container, "MSPointerCancel", this._onTouchCancel, this)) : (L.DomEvent.on(this._container, "touchcancel", this._onTouchCancel, this), L.DomEvent.on(this._container, "touchleave", this._onTouchLeave, this));
  }, removeHooks: function() {
    L.DomEvent.off(this._container, "touchstart", this._onTouchStart, this), L.DomEvent.off(this._container, "touchend", this._onTouchEnd, this), L.DomEvent.off(this._container, "touchmove", this._onTouchMove, this), this._detectIE() ? (L.DomEvent.off(this._container, "MSPointerDown", this._onTouchStart, this), L.DomEvent.off(this._container, "MSPointerUp", this._onTouchEnd, this), L.DomEvent.off(this._container, "MSPointerMove", this._onTouchMove, this), L.DomEvent.off(this._container, "MSPointerCancel", this._onTouchCancel, this)) : (L.DomEvent.off(this._container, "touchcancel", this._onTouchCancel, this), L.DomEvent.off(this._container, "touchleave", this._onTouchLeave, this));
  }, _touchEvent: function(t2, e2) {
    var i2 = {};
    if (t2.touches !== void 0) {
      if (!t2.touches.length)
        return;
      i2 = t2.touches[0];
    } else {
      if (t2.pointerType !== "touch")
        return;
      if (i2 = t2, !this._filterClick(t2))
        return;
    }
    var o2 = this._map.mouseEventToContainerPoint(i2), a = this._map.mouseEventToLayerPoint(i2), n = this._map.layerPointToLatLng(a);
    this._map.fire(e2, { latlng: n, layerPoint: a, containerPoint: o2, pageX: i2.pageX, pageY: i2.pageY, originalEvent: t2 });
  }, _filterClick: function(t2) {
    var e2 = t2.timeStamp || t2.originalEvent.timeStamp, i2 = L.DomEvent._lastClick && e2 - L.DomEvent._lastClick;
    return i2 && i2 > 100 && i2 < 500 || t2.target._simulatedClick && !t2._simulated ? (L.DomEvent.stop(t2), false) : (L.DomEvent._lastClick = e2, true);
  }, _onTouchStart: function(t2) {
    if (this._map._loaded) {
      this._touchEvent(t2, "touchstart");
    }
  }, _onTouchEnd: function(t2) {
    if (this._map._loaded) {
      this._touchEvent(t2, "touchend");
    }
  }, _onTouchCancel: function(t2) {
    if (this._map._loaded) {
      var e2 = "touchcancel";
      this._detectIE() && (e2 = "pointercancel"), this._touchEvent(t2, e2);
    }
  }, _onTouchLeave: function(t2) {
    if (this._map._loaded) {
      this._touchEvent(t2, "touchleave");
    }
  }, _onTouchMove: function(t2) {
    if (this._map._loaded) {
      this._touchEvent(t2, "touchmove");
    }
  }, _detectIE: function() {
    var e2 = t.navigator.userAgent, i2 = e2.indexOf("MSIE ");
    if (i2 > 0)
      return parseInt(e2.substring(i2 + 5, e2.indexOf(".", i2)), 10);
    if (e2.indexOf("Trident/") > 0) {
      var o2 = e2.indexOf("rv:");
      return parseInt(e2.substring(o2 + 3, e2.indexOf(".", o2)), 10);
    }
    var a = e2.indexOf("Edge/");
    return a > 0 && parseInt(e2.substring(a + 5, e2.indexOf(".", a)), 10);
  } }), L.Map.addInitHook("addHandler", "touchExtend", L.Map.TouchExtend), L.Marker.Touch = L.Marker.extend({ _initInteraction: function() {
    return this.addInteractiveTarget ? L.Marker.prototype._initInteraction.apply(this) : this._initInteractionLegacy();
  }, _initInteractionLegacy: function() {
    if (this.options.clickable) {
      var t2 = this._icon, e2 = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchmove"];
      this._detectIE ? e2.concat(["MSPointerDown", "MSPointerUp", "MSPointerMove", "MSPointerCancel"]) : e2.concat(["touchcancel"]), L.DomUtil.addClass(t2, "leaflet-clickable"), L.DomEvent.on(t2, "click", this._onMouseClick, this), L.DomEvent.on(t2, "keypress", this._onKeyPress, this);
      for (var i2 = 0; i2 < e2.length; i2++)
        L.DomEvent.on(t2, e2[i2], this._fireMouseEvent, this);
      L.Handler.MarkerDrag && (this.dragging = new L.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable());
    }
  }, _detectIE: function() {
    var e2 = t.navigator.userAgent, i2 = e2.indexOf("MSIE ");
    if (i2 > 0)
      return parseInt(e2.substring(i2 + 5, e2.indexOf(".", i2)), 10);
    if (e2.indexOf("Trident/") > 0) {
      var o2 = e2.indexOf("rv:");
      return parseInt(e2.substring(o2 + 3, e2.indexOf(".", o2)), 10);
    }
    var a = e2.indexOf("Edge/");
    return a > 0 && parseInt(e2.substring(a + 5, e2.indexOf(".", a)), 10);
  } }), L.LatLngUtil = { cloneLatLngs: function(t2) {
    for (var e2 = [], i2 = 0, o2 = t2.length; i2 < o2; i2++)
      Array.isArray(t2[i2]) ? e2.push(L.LatLngUtil.cloneLatLngs(t2[i2])) : e2.push(this.cloneLatLng(t2[i2]));
    return e2;
  }, cloneLatLng: function(t2) {
    return L.latLng(t2.lat, t2.lng);
  } }, function() {
    var t2 = { km: 2, ha: 2, m: 0, mi: 2, ac: 2, yd: 0, ft: 0, nm: 2 };
    L.GeometryUtil = L.extend(L.GeometryUtil || {}, { geodesicArea: function(t3) {
      var e2, i2, o2 = t3.length, a = 0, n = Math.PI / 180;
      if (o2 > 2) {
        for (var s = 0; s < o2; s++)
          e2 = t3[s], i2 = t3[(s + 1) % o2], a += (i2.lng - e2.lng) * n * (2 + Math.sin(e2.lat * n) + Math.sin(i2.lat * n));
        a = 6378137 * a * 6378137 / 2;
      }
      return Math.abs(a);
    }, formattedNumber: function(t3, e2) {
      var i2 = parseFloat(t3).toFixed(e2), o2 = L.drawLocal.format && L.drawLocal.format.numeric, a = o2 && o2.delimiters, n = a && a.thousands, s = a && a.decimal;
      if (n || s) {
        var r = i2.split(".");
        i2 = n ? r[0].replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + n) : r[0], s = s || ".", r.length > 1 && (i2 = i2 + s + r[1]);
      }
      return i2;
    }, readableArea: function(e2, i2, o2) {
      var a, n, o2 = L.Util.extend({}, t2, o2);
      return i2 ? (n = ["ha", "m"], type = typeof i2, type === "string" ? n = [i2] : type !== "boolean" && (n = i2), a = e2 >= 1e6 && n.indexOf("km") !== -1 ? L.GeometryUtil.formattedNumber(1e-6 * e2, o2.km) + " km\xB2" : e2 >= 1e4 && n.indexOf("ha") !== -1 ? L.GeometryUtil.formattedNumber(1e-4 * e2, o2.ha) + " ha" : L.GeometryUtil.formattedNumber(e2, o2.m) + " m\xB2") : (e2 /= 0.836127, a = e2 >= 3097600 ? L.GeometryUtil.formattedNumber(e2 / 3097600, o2.mi) + " mi\xB2" : e2 >= 4840 ? L.GeometryUtil.formattedNumber(e2 / 4840, o2.ac) + " acres" : L.GeometryUtil.formattedNumber(e2, o2.yd) + " yd\xB2"), a;
    }, readableDistance: function(e2, i2, o2, a, n) {
      var s, n = L.Util.extend({}, t2, n);
      switch (i2 ? typeof i2 == "string" ? i2 : "metric" : o2 ? "feet" : a ? "nauticalMile" : "yards") {
        case "metric":
          s = e2 > 1e3 ? L.GeometryUtil.formattedNumber(e2 / 1e3, n.km) + " km" : L.GeometryUtil.formattedNumber(e2, n.m) + " m";
          break;
        case "feet":
          e2 *= 3.28083, s = L.GeometryUtil.formattedNumber(e2, n.ft) + " ft";
          break;
        case "nauticalMile":
          e2 *= 0.53996, s = L.GeometryUtil.formattedNumber(e2 / 1e3, n.nm) + " nm";
          break;
        case "yards":
        default:
          e2 *= 1.09361, s = e2 > 1760 ? L.GeometryUtil.formattedNumber(e2 / 1760, n.mi) + " miles" : L.GeometryUtil.formattedNumber(e2, n.yd) + " yd";
      }
      return s;
    }, isVersion07x: function() {
      var t3 = L.version.split(".");
      return parseInt(t3[0], 10) === 0 && parseInt(t3[1], 10) === 7;
    } });
  }(), L.Util.extend(L.LineUtil, { segmentsIntersect: function(t2, e2, i2, o2) {
    return this._checkCounterclockwise(t2, i2, o2) !== this._checkCounterclockwise(e2, i2, o2) && this._checkCounterclockwise(t2, e2, i2) !== this._checkCounterclockwise(t2, e2, o2);
  }, _checkCounterclockwise: function(t2, e2, i2) {
    return (i2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (i2.x - t2.x);
  } }), L.Polyline.include({ intersects: function() {
    var t2, e2, i2, o2 = this._getProjectedPoints(), a = o2 ? o2.length : 0;
    if (this._tooFewPointsForIntersection())
      return false;
    for (t2 = a - 1; t2 >= 3; t2--)
      if (e2 = o2[t2 - 1], i2 = o2[t2], this._lineSegmentsIntersectsRange(e2, i2, t2 - 2))
        return true;
    return false;
  }, newLatLngIntersects: function(t2, e2) {
    return !!this._map && this.newPointIntersects(this._map.latLngToLayerPoint(t2), e2);
  }, newPointIntersects: function(t2, e2) {
    var i2 = this._getProjectedPoints(), o2 = i2 ? i2.length : 0, a = i2 ? i2[o2 - 1] : null, n = o2 - 2;
    return !this._tooFewPointsForIntersection(1) && this._lineSegmentsIntersectsRange(a, t2, n, e2 ? 1 : 0);
  }, _tooFewPointsForIntersection: function(t2) {
    var e2 = this._getProjectedPoints(), i2 = e2 ? e2.length : 0;
    return i2 += t2 || 0, !e2 || i2 <= 3;
  }, _lineSegmentsIntersectsRange: function(t2, e2, i2, o2) {
    var a, n, s = this._getProjectedPoints();
    o2 = o2 || 0;
    for (var r = i2; r > o2; r--)
      if (a = s[r - 1], n = s[r], L.LineUtil.segmentsIntersect(t2, e2, a, n))
        return true;
    return false;
  }, _getProjectedPoints: function() {
    if (!this._defaultShape)
      return this._originalPoints;
    for (var t2 = [], e2 = this._defaultShape(), i2 = 0; i2 < e2.length; i2++)
      t2.push(this._map.latLngToLayerPoint(e2[i2]));
    return t2;
  } }), L.Polygon.include({ intersects: function() {
    var t2, e2, i2, o2, a = this._getProjectedPoints();
    return !this._tooFewPointsForIntersection() && (!!L.Polyline.prototype.intersects.call(this) || (t2 = a.length, e2 = a[0], i2 = a[t2 - 1], o2 = t2 - 2, this._lineSegmentsIntersectsRange(i2, e2, o2, 1)));
  } }), L.Control.Draw = L.Control.extend({ options: { position: "topleft", draw: {}, edit: false }, initialize: function(t2) {
    if (L.version < "0.7")
      throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/");
    L.Control.prototype.initialize.call(this, t2);
    var e2;
    this._toolbars = {}, L.DrawToolbar && this.options.draw && (e2 = new L.DrawToolbar(this.options.draw), this._toolbars[L.DrawToolbar.TYPE] = e2, this._toolbars[L.DrawToolbar.TYPE].on("enable", this._toolbarEnabled, this)), L.EditToolbar && this.options.edit && (e2 = new L.EditToolbar(this.options.edit), this._toolbars[L.EditToolbar.TYPE] = e2, this._toolbars[L.EditToolbar.TYPE].on("enable", this._toolbarEnabled, this)), L.toolbar = this;
  }, onAdd: function(t2) {
    var e2, i2 = L.DomUtil.create("div", "leaflet-draw"), o2 = false;
    for (var a in this._toolbars)
      this._toolbars.hasOwnProperty(a) && (e2 = this._toolbars[a].addToolbar(t2)) && (o2 || (L.DomUtil.hasClass(e2, "leaflet-draw-toolbar-top") || L.DomUtil.addClass(e2.childNodes[0], "leaflet-draw-toolbar-top"), o2 = true), i2.appendChild(e2));
    return i2;
  }, onRemove: function() {
    for (var t2 in this._toolbars)
      this._toolbars.hasOwnProperty(t2) && this._toolbars[t2].removeToolbar();
  }, setDrawingOptions: function(t2) {
    for (var e2 in this._toolbars)
      this._toolbars[e2] instanceof L.DrawToolbar && this._toolbars[e2].setOptions(t2);
  }, _toolbarEnabled: function(t2) {
    var e2 = t2.target;
    for (var i2 in this._toolbars)
      this._toolbars[i2] !== e2 && this._toolbars[i2].disable();
  } }), L.Map.mergeOptions({ drawControlTooltips: true, drawControl: false }), L.Map.addInitHook(function() {
    this.options.drawControl && (this.drawControl = new L.Control.Draw(), this.addControl(this.drawControl));
  }), L.Toolbar = L.Class.extend({ initialize: function(t2) {
    L.setOptions(this, t2), this._modes = {}, this._actionButtons = [], this._activeMode = null;
    var e2 = L.version.split(".");
    parseInt(e2[0], 10) === 1 && parseInt(e2[1], 10) >= 2 ? L.Toolbar.include(L.Evented.prototype) : L.Toolbar.include(L.Mixin.Events);
  }, enabled: function() {
    return this._activeMode !== null;
  }, disable: function() {
    this.enabled() && this._activeMode.handler.disable();
  }, addToolbar: function(t2) {
    var e2, i2 = L.DomUtil.create("div", "leaflet-draw-section"), o2 = 0, a = this._toolbarClass || "", n = this.getModeHandlers(t2);
    for (this._toolbarContainer = L.DomUtil.create("div", "leaflet-draw-toolbar leaflet-bar"), this._map = t2, e2 = 0; e2 < n.length; e2++)
      n[e2].enabled && this._initModeHandler(n[e2].handler, this._toolbarContainer, o2++, a, n[e2].title);
    if (o2)
      return this._lastButtonIndex = --o2, this._actionsContainer = L.DomUtil.create("ul", "leaflet-draw-actions"), i2.appendChild(this._toolbarContainer), i2.appendChild(this._actionsContainer), i2;
  }, removeToolbar: function() {
    for (var t2 in this._modes)
      this._modes.hasOwnProperty(t2) && (this._disposeButton(this._modes[t2].button, this._modes[t2].handler.enable, this._modes[t2].handler), this._modes[t2].handler.disable(), this._modes[t2].handler.off("enabled", this._handlerActivated, this).off("disabled", this._handlerDeactivated, this));
    this._modes = {};
    for (var e2 = 0, i2 = this._actionButtons.length; e2 < i2; e2++)
      this._disposeButton(this._actionButtons[e2].button, this._actionButtons[e2].callback, this);
    this._actionButtons = [], this._actionsContainer = null;
  }, _initModeHandler: function(t2, e2, i2, o2, a) {
    var n = t2.type;
    this._modes[n] = {}, this._modes[n].handler = t2, this._modes[n].button = this._createButton({ type: n, title: a, className: o2 + "-" + n, container: e2, callback: this._modes[n].handler.enable, context: this._modes[n].handler }), this._modes[n].buttonIndex = i2, this._modes[n].handler.on("enabled", this._handlerActivated, this).on("disabled", this._handlerDeactivated, this);
  }, _detectIOS: function() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !t.MSStream;
  }, _createButton: function(t2) {
    var e2 = L.DomUtil.create("a", t2.className || "", t2.container), i2 = L.DomUtil.create("span", "sr-only", t2.container);
    e2.href = "#", e2.appendChild(i2), t2.title && (e2.title = t2.title, i2.innerHTML = t2.title), t2.text && (e2.innerHTML = t2.text, i2.innerHTML = t2.text);
    var o2 = this._detectIOS() ? "touchstart" : "click";
    return L.DomEvent.on(e2, "click", L.DomEvent.stopPropagation).on(e2, "mousedown", L.DomEvent.stopPropagation).on(e2, "dblclick", L.DomEvent.stopPropagation).on(e2, "touchstart", L.DomEvent.stopPropagation).on(e2, "click", L.DomEvent.preventDefault).on(e2, o2, t2.callback, t2.context), e2;
  }, _disposeButton: function(t2, e2) {
    var i2 = this._detectIOS() ? "touchstart" : "click";
    L.DomEvent.off(t2, "click", L.DomEvent.stopPropagation).off(t2, "mousedown", L.DomEvent.stopPropagation).off(t2, "dblclick", L.DomEvent.stopPropagation).off(t2, "touchstart", L.DomEvent.stopPropagation).off(t2, "click", L.DomEvent.preventDefault).off(t2, i2, e2);
  }, _handlerActivated: function(t2) {
    this.disable(), this._activeMode = this._modes[t2.handler], L.DomUtil.addClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled"), this._showActionsToolbar(), this.fire("enable");
  }, _handlerDeactivated: function() {
    this._hideActionsToolbar(), L.DomUtil.removeClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled"), this._activeMode = null, this.fire("disable");
  }, _createActions: function(t2) {
    var e2, i2, o2, a, n = this._actionsContainer, s = this.getActions(t2), r = s.length;
    for (i2 = 0, o2 = this._actionButtons.length; i2 < o2; i2++)
      this._disposeButton(this._actionButtons[i2].button, this._actionButtons[i2].callback);
    for (this._actionButtons = []; n.firstChild; )
      n.removeChild(n.firstChild);
    for (var l = 0; l < r; l++)
      "enabled" in s[l] && !s[l].enabled || (e2 = L.DomUtil.create("li", "", n), a = this._createButton({ title: s[l].title, text: s[l].text, container: e2, callback: s[l].callback, context: s[l].context }), this._actionButtons.push({ button: a, callback: s[l].callback }));
  }, _showActionsToolbar: function() {
    var t2 = this._activeMode.buttonIndex, e2 = this._lastButtonIndex, i2 = this._activeMode.button.offsetTop - 1;
    this._createActions(this._activeMode.handler), this._actionsContainer.style.top = i2 + "px", t2 === 0 && (L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-notop"), L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-top")), t2 === e2 && (L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom"), L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-bottom")), this._actionsContainer.style.display = "block", this._map.fire(L.Draw.Event.TOOLBAROPENED);
  }, _hideActionsToolbar: function() {
    this._actionsContainer.style.display = "none", L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-notop"), L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom"), L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-top"), L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-bottom"), this._map.fire(L.Draw.Event.TOOLBARCLOSED);
  } }), L.Draw = L.Draw || {}, L.Draw.Tooltip = L.Class.extend({ initialize: function(t2) {
    this._map = t2, this._popupPane = t2._panes.popupPane, this._visible = false, this._container = t2.options.drawControlTooltips ? L.DomUtil.create("div", "leaflet-draw-tooltip", this._popupPane) : null, this._singleLineLabel = false, this._map.on("mouseout", this._onMouseOut, this);
  }, dispose: function() {
    this._map.off("mouseout", this._onMouseOut, this), this._container && (this._popupPane.removeChild(this._container), this._container = null);
  }, updateContent: function(t2) {
    return this._container ? (t2.subtext = t2.subtext || "", t2.subtext.length !== 0 || this._singleLineLabel ? t2.subtext.length > 0 && this._singleLineLabel && (L.DomUtil.removeClass(this._container, "leaflet-draw-tooltip-single"), this._singleLineLabel = false) : (L.DomUtil.addClass(this._container, "leaflet-draw-tooltip-single"), this._singleLineLabel = true), this._container.innerHTML = (t2.subtext.length > 0 ? '<span class="leaflet-draw-tooltip-subtext">' + t2.subtext + "</span><br />" : "") + "<span>" + t2.text + "</span>", t2.text || t2.subtext ? (this._visible = true, this._container.style.visibility = "inherit") : (this._visible = false, this._container.style.visibility = "hidden"), this) : this;
  }, updatePosition: function(t2) {
    var e2 = this._map.latLngToLayerPoint(t2), i2 = this._container;
    return this._container && (this._visible && (i2.style.visibility = "inherit"), L.DomUtil.setPosition(i2, e2)), this;
  }, showAsError: function() {
    return this._container && L.DomUtil.addClass(this._container, "leaflet-error-draw-tooltip"), this;
  }, removeError: function() {
    return this._container && L.DomUtil.removeClass(this._container, "leaflet-error-draw-tooltip"), this;
  }, _onMouseOut: function() {
    this._container && (this._container.style.visibility = "hidden");
  } }), L.DrawToolbar = L.Toolbar.extend({ statics: { TYPE: "draw" }, options: { polyline: {}, polygon: {}, rectangle: {}, circle: {}, marker: {}, circlemarker: {} }, initialize: function(t2) {
    for (var e2 in this.options)
      this.options.hasOwnProperty(e2) && t2[e2] && (t2[e2] = L.extend({}, this.options[e2], t2[e2]));
    this._toolbarClass = "leaflet-draw-draw", L.Toolbar.prototype.initialize.call(this, t2);
  }, getModeHandlers: function(t2) {
    return [{ enabled: this.options.polyline, handler: new L.Draw.Polyline(t2, this.options.polyline), title: L.drawLocal.draw.toolbar.buttons.polyline }, { enabled: this.options.polygon, handler: new L.Draw.Polygon(t2, this.options.polygon), title: L.drawLocal.draw.toolbar.buttons.polygon }, { enabled: this.options.rectangle, handler: new L.Draw.Rectangle(t2, this.options.rectangle), title: L.drawLocal.draw.toolbar.buttons.rectangle }, { enabled: this.options.circle, handler: new L.Draw.Circle(t2, this.options.circle), title: L.drawLocal.draw.toolbar.buttons.circle }, { enabled: this.options.marker, handler: new L.Draw.Marker(t2, this.options.marker), title: L.drawLocal.draw.toolbar.buttons.marker }, { enabled: this.options.circlemarker, handler: new L.Draw.CircleMarker(t2, this.options.circlemarker), title: L.drawLocal.draw.toolbar.buttons.circlemarker }];
  }, getActions: function(t2) {
    return [{ enabled: t2.completeShape, title: L.drawLocal.draw.toolbar.finish.title, text: L.drawLocal.draw.toolbar.finish.text, callback: t2.completeShape, context: t2 }, { enabled: t2.deleteLastVertex, title: L.drawLocal.draw.toolbar.undo.title, text: L.drawLocal.draw.toolbar.undo.text, callback: t2.deleteLastVertex, context: t2 }, { title: L.drawLocal.draw.toolbar.actions.title, text: L.drawLocal.draw.toolbar.actions.text, callback: this.disable, context: this }];
  }, setOptions: function(t2) {
    L.setOptions(this, t2);
    for (var e2 in this._modes)
      this._modes.hasOwnProperty(e2) && t2.hasOwnProperty(e2) && this._modes[e2].handler.setOptions(t2[e2]);
  } }), L.EditToolbar = L.Toolbar.extend({ statics: { TYPE: "edit" }, options: { edit: { selectedPathOptions: { dashArray: "10, 10", fill: true, fillColor: "#fe57a1", fillOpacity: 0.1, maintainColor: false } }, remove: {}, poly: null, featureGroup: null }, initialize: function(t2) {
    t2.edit && (t2.edit.selectedPathOptions === void 0 && (t2.edit.selectedPathOptions = this.options.edit.selectedPathOptions), t2.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, t2.edit.selectedPathOptions)), t2.remove && (t2.remove = L.extend({}, this.options.remove, t2.remove)), t2.poly && (t2.poly = L.extend({}, this.options.poly, t2.poly)), this._toolbarClass = "leaflet-draw-edit", L.Toolbar.prototype.initialize.call(this, t2), this._selectedFeatureCount = 0;
  }, getModeHandlers: function(t2) {
    var e2 = this.options.featureGroup;
    return [{ enabled: this.options.edit, handler: new L.EditToolbar.Edit(t2, { featureGroup: e2, selectedPathOptions: this.options.edit.selectedPathOptions, poly: this.options.poly }), title: L.drawLocal.edit.toolbar.buttons.edit }, { enabled: this.options.remove, handler: new L.EditToolbar.Delete(t2, { featureGroup: e2 }), title: L.drawLocal.edit.toolbar.buttons.remove }];
  }, getActions: function(t2) {
    var e2 = [{ title: L.drawLocal.edit.toolbar.actions.save.title, text: L.drawLocal.edit.toolbar.actions.save.text, callback: this._save, context: this }, { title: L.drawLocal.edit.toolbar.actions.cancel.title, text: L.drawLocal.edit.toolbar.actions.cancel.text, callback: this.disable, context: this }];
    return t2.removeAllLayers && e2.push({ title: L.drawLocal.edit.toolbar.actions.clearAll.title, text: L.drawLocal.edit.toolbar.actions.clearAll.text, callback: this._clearAllLayers, context: this }), e2;
  }, addToolbar: function(t2) {
    var e2 = L.Toolbar.prototype.addToolbar.call(this, t2);
    return this._checkDisabled(), this.options.featureGroup.on("layeradd layerremove", this._checkDisabled, this), e2;
  }, removeToolbar: function() {
    this.options.featureGroup.off("layeradd layerremove", this._checkDisabled, this), L.Toolbar.prototype.removeToolbar.call(this);
  }, disable: function() {
    this.enabled() && (this._activeMode.handler.revertLayers(), L.Toolbar.prototype.disable.call(this));
  }, _save: function() {
    this._activeMode.handler.save(), this._activeMode && this._activeMode.handler.disable();
  }, _clearAllLayers: function() {
    this._activeMode.handler.removeAllLayers(), this._activeMode && this._activeMode.handler.disable();
  }, _checkDisabled: function() {
    var t2, e2 = this.options.featureGroup, i2 = e2.getLayers().length !== 0;
    this.options.edit && (t2 = this._modes[L.EditToolbar.Edit.TYPE].button, i2 ? L.DomUtil.removeClass(t2, "leaflet-disabled") : L.DomUtil.addClass(t2, "leaflet-disabled"), t2.setAttribute("title", i2 ? L.drawLocal.edit.toolbar.buttons.edit : L.drawLocal.edit.toolbar.buttons.editDisabled)), this.options.remove && (t2 = this._modes[L.EditToolbar.Delete.TYPE].button, i2 ? L.DomUtil.removeClass(t2, "leaflet-disabled") : L.DomUtil.addClass(t2, "leaflet-disabled"), t2.setAttribute("title", i2 ? L.drawLocal.edit.toolbar.buttons.remove : L.drawLocal.edit.toolbar.buttons.removeDisabled));
  } }), L.EditToolbar.Edit = L.Handler.extend({ statics: { TYPE: "edit" }, initialize: function(t2, e2) {
    if (L.Handler.prototype.initialize.call(this, t2), L.setOptions(this, e2), this._featureGroup = e2.featureGroup, !(this._featureGroup instanceof L.FeatureGroup))
      throw new Error("options.featureGroup must be a L.FeatureGroup");
    this._uneditedLayerProps = {}, this.type = L.EditToolbar.Edit.TYPE;
    var i2 = L.version.split(".");
    parseInt(i2[0], 10) === 1 && parseInt(i2[1], 10) >= 2 ? L.EditToolbar.Edit.include(L.Evented.prototype) : L.EditToolbar.Edit.include(L.Mixin.Events);
  }, enable: function() {
    !this._enabled && this._hasAvailableLayers() && (this.fire("enabled", { handler: this.type }), this._map.fire(L.Draw.Event.EDITSTART, { handler: this.type }), L.Handler.prototype.enable.call(this), this._featureGroup.on("layeradd", this._enableLayerEdit, this).on("layerremove", this._disableLayerEdit, this));
  }, disable: function() {
    this._enabled && (this._featureGroup.off("layeradd", this._enableLayerEdit, this).off("layerremove", this._disableLayerEdit, this), L.Handler.prototype.disable.call(this), this._map.fire(L.Draw.Event.EDITSTOP, { handler: this.type }), this.fire("disabled", { handler: this.type }));
  }, addHooks: function() {
    var t2 = this._map;
    t2 && (t2.getContainer().focus(), this._featureGroup.eachLayer(this._enableLayerEdit, this), this._tooltip = new L.Draw.Tooltip(this._map), this._tooltip.updateContent({ text: L.drawLocal.edit.handlers.edit.tooltip.text, subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext }), t2._editTooltip = this._tooltip, this._updateTooltip(), this._map.on("mousemove", this._onMouseMove, this).on("touchmove", this._onMouseMove, this).on("MSPointerMove", this._onMouseMove, this).on(L.Draw.Event.EDITVERTEX, this._updateTooltip, this));
  }, removeHooks: function() {
    this._map && (this._featureGroup.eachLayer(this._disableLayerEdit, this), this._uneditedLayerProps = {}, this._tooltip.dispose(), this._tooltip = null, this._map.off("mousemove", this._onMouseMove, this).off("touchmove", this._onMouseMove, this).off("MSPointerMove", this._onMouseMove, this).off(L.Draw.Event.EDITVERTEX, this._updateTooltip, this));
  }, revertLayers: function() {
    this._featureGroup.eachLayer(function(t2) {
      this._revertLayer(t2);
    }, this);
  }, save: function() {
    var t2 = new L.LayerGroup();
    this._featureGroup.eachLayer(function(e2) {
      e2.edited && (t2.addLayer(e2), e2.edited = false);
    }), this._map.fire(L.Draw.Event.EDITED, { layers: t2 });
  }, _backupLayer: function(t2) {
    var e2 = L.Util.stamp(t2);
    this._uneditedLayerProps[e2] || (t2 instanceof L.Polyline || t2 instanceof L.Polygon || t2 instanceof L.Rectangle ? this._uneditedLayerProps[e2] = { latlngs: L.LatLngUtil.cloneLatLngs(t2.getLatLngs()) } : t2 instanceof L.Circle ? this._uneditedLayerProps[e2] = { latlng: L.LatLngUtil.cloneLatLng(t2.getLatLng()), radius: t2.getRadius() } : (t2 instanceof L.Marker || t2 instanceof L.CircleMarker) && (this._uneditedLayerProps[e2] = { latlng: L.LatLngUtil.cloneLatLng(t2.getLatLng()) }));
  }, _getTooltipText: function() {
    return { text: L.drawLocal.edit.handlers.edit.tooltip.text, subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext };
  }, _updateTooltip: function() {
    this._tooltip.updateContent(this._getTooltipText());
  }, _revertLayer: function(t2) {
    var e2 = L.Util.stamp(t2);
    t2.edited = false, this._uneditedLayerProps.hasOwnProperty(e2) && (t2 instanceof L.Polyline || t2 instanceof L.Polygon || t2 instanceof L.Rectangle ? t2.setLatLngs(this._uneditedLayerProps[e2].latlngs) : t2 instanceof L.Circle ? (t2.setLatLng(this._uneditedLayerProps[e2].latlng), t2.setRadius(this._uneditedLayerProps[e2].radius)) : (t2 instanceof L.Marker || t2 instanceof L.CircleMarker) && t2.setLatLng(this._uneditedLayerProps[e2].latlng), t2.fire("revert-edited", { layer: t2 }));
  }, _enableLayerEdit: function(t2) {
    var e2, i2, o2 = t2.layer || t2.target || t2;
    this._backupLayer(o2), this.options.poly && (i2 = L.Util.extend({}, this.options.poly), o2.options.poly = i2), this.options.selectedPathOptions && (e2 = L.Util.extend({}, this.options.selectedPathOptions), e2.maintainColor && (e2.color = o2.options.color, e2.fillColor = o2.options.fillColor), o2.options.original = L.extend({}, o2.options), o2.options.editing = e2), o2 instanceof L.Marker ? (o2.editing && o2.editing.enable(), o2.dragging.enable(), o2.on("dragend", this._onMarkerDragEnd).on("touchmove", this._onTouchMove, this).on("MSPointerMove", this._onTouchMove, this).on("touchend", this._onMarkerDragEnd, this).on("MSPointerUp", this._onMarkerDragEnd, this)) : o2.editing.enable();
  }, _disableLayerEdit: function(t2) {
    var e2 = t2.layer || t2.target || t2;
    e2.edited = false, e2.editing && e2.editing.disable(), delete e2.options.editing, delete e2.options.original, this._selectedPathOptions && (e2 instanceof L.Marker ? this._toggleMarkerHighlight(e2) : (e2.setStyle(e2.options.previousOptions), delete e2.options.previousOptions)), e2 instanceof L.Marker ? (e2.dragging.disable(), e2.off("dragend", this._onMarkerDragEnd, this).off("touchmove", this._onTouchMove, this).off("MSPointerMove", this._onTouchMove, this).off("touchend", this._onMarkerDragEnd, this).off("MSPointerUp", this._onMarkerDragEnd, this)) : e2.editing.disable();
  }, _onMouseMove: function(t2) {
    this._tooltip.updatePosition(t2.latlng);
  }, _onMarkerDragEnd: function(t2) {
    var e2 = t2.target;
    e2.edited = true, this._map.fire(L.Draw.Event.EDITMOVE, { layer: e2 });
  }, _onTouchMove: function(t2) {
    var e2 = t2.originalEvent.changedTouches[0], i2 = this._map.mouseEventToLayerPoint(e2), o2 = this._map.layerPointToLatLng(i2);
    t2.target.setLatLng(o2);
  }, _hasAvailableLayers: function() {
    return this._featureGroup.getLayers().length !== 0;
  } }), L.EditToolbar.Delete = L.Handler.extend({ statics: { TYPE: "remove" }, initialize: function(t2, e2) {
    if (L.Handler.prototype.initialize.call(this, t2), L.Util.setOptions(this, e2), this._deletableLayers = this.options.featureGroup, !(this._deletableLayers instanceof L.FeatureGroup))
      throw new Error("options.featureGroup must be a L.FeatureGroup");
    this.type = L.EditToolbar.Delete.TYPE;
    var i2 = L.version.split(".");
    parseInt(i2[0], 10) === 1 && parseInt(i2[1], 10) >= 2 ? L.EditToolbar.Delete.include(L.Evented.prototype) : L.EditToolbar.Delete.include(L.Mixin.Events);
  }, enable: function() {
    !this._enabled && this._hasAvailableLayers() && (this.fire("enabled", { handler: this.type }), this._map.fire(L.Draw.Event.DELETESTART, { handler: this.type }), L.Handler.prototype.enable.call(this), this._deletableLayers.on("layeradd", this._enableLayerDelete, this).on("layerremove", this._disableLayerDelete, this));
  }, disable: function() {
    this._enabled && (this._deletableLayers.off("layeradd", this._enableLayerDelete, this).off("layerremove", this._disableLayerDelete, this), L.Handler.prototype.disable.call(this), this._map.fire(L.Draw.Event.DELETESTOP, { handler: this.type }), this.fire("disabled", { handler: this.type }));
  }, addHooks: function() {
    var t2 = this._map;
    t2 && (t2.getContainer().focus(), this._deletableLayers.eachLayer(this._enableLayerDelete, this), this._deletedLayers = new L.LayerGroup(), this._tooltip = new L.Draw.Tooltip(this._map), this._tooltip.updateContent({ text: L.drawLocal.edit.handlers.remove.tooltip.text }), this._map.on("mousemove", this._onMouseMove, this));
  }, removeHooks: function() {
    this._map && (this._deletableLayers.eachLayer(this._disableLayerDelete, this), this._deletedLayers = null, this._tooltip.dispose(), this._tooltip = null, this._map.off("mousemove", this._onMouseMove, this));
  }, revertLayers: function() {
    this._deletedLayers.eachLayer(function(t2) {
      this._deletableLayers.addLayer(t2), t2.fire("revert-deleted", { layer: t2 });
    }, this);
  }, save: function() {
    this._map.fire(L.Draw.Event.DELETED, { layers: this._deletedLayers });
  }, removeAllLayers: function() {
    this._deletableLayers.eachLayer(function(t2) {
      this._removeLayer({ layer: t2 });
    }, this), this.save();
  }, _enableLayerDelete: function(t2) {
    (t2.layer || t2.target || t2).on("click", this._removeLayer, this);
  }, _disableLayerDelete: function(t2) {
    var e2 = t2.layer || t2.target || t2;
    e2.off("click", this._removeLayer, this), this._deletedLayers.removeLayer(e2);
  }, _removeLayer: function(t2) {
    var e2 = t2.layer || t2.target || t2;
    this._deletableLayers.removeLayer(e2), this._deletedLayers.addLayer(e2), e2.fire("deleted");
  }, _onMouseMove: function(t2) {
    this._tooltip.updatePosition(t2.latlng);
  }, _hasAvailableLayers: function() {
    return this._deletableLayers.getLayers().length !== 0;
  } });
}(window, document);
var leaflet_draw = "";
(function(module, exports) {
  (function(global2, factory) {
    factory(leafletSrc.exports);
  })(commonjsGlobal, function(L$12) {
    L$12 = L$12 && L$12.hasOwnProperty("default") ? L$12["default"] : L$12;
    function pointDistance(ptA, ptB) {
      var x = ptB.x - ptA.x;
      var y = ptB.y - ptA.y;
      return Math.sqrt(x * x + y * y);
    }
    var computeSegmentHeading = function computeSegmentHeading2(a, b) {
      return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI + 90 + 360) % 360;
    };
    var asRatioToPathLength = function asRatioToPathLength2(_ref, totalPathLength) {
      var value = _ref.value, isInPixels = _ref.isInPixels;
      return isInPixels ? value / totalPathLength : value;
    };
    function parseRelativeOrAbsoluteValue(value) {
      if (typeof value === "string" && value.indexOf("%") !== -1) {
        return {
          value: parseFloat(value) / 100,
          isInPixels: false
        };
      }
      var parsedValue = value ? parseFloat(value) : 0;
      return {
        value: parsedValue,
        isInPixels: parsedValue > 0
      };
    }
    var pointsEqual = function pointsEqual2(a, b) {
      return a.x === b.x && a.y === b.y;
    };
    function pointsToSegments(pts) {
      return pts.reduce(function(segments, b, idx, points) {
        if (idx > 0 && !pointsEqual(b, points[idx - 1])) {
          var a = points[idx - 1];
          var distA = segments.length > 0 ? segments[segments.length - 1].distB : 0;
          var distAB = pointDistance(a, b);
          segments.push({
            a,
            b,
            distA,
            distB: distA + distAB,
            heading: computeSegmentHeading(a, b)
          });
        }
        return segments;
      }, []);
    }
    function projectPatternOnPointPath(pts, pattern) {
      var segments = pointsToSegments(pts);
      var nbSegments = segments.length;
      if (nbSegments === 0) {
        return [];
      }
      var totalPathLength = segments[nbSegments - 1].distB;
      var offset = asRatioToPathLength(pattern.offset, totalPathLength);
      var endOffset = asRatioToPathLength(pattern.endOffset, totalPathLength);
      var repeat = asRatioToPathLength(pattern.repeat, totalPathLength);
      var repeatIntervalPixels = totalPathLength * repeat;
      var startOffsetPixels = offset > 0 ? totalPathLength * offset : 0;
      var endOffsetPixels = endOffset > 0 ? totalPathLength * endOffset : 0;
      var positionOffsets = [];
      var positionOffset = startOffsetPixels;
      do {
        positionOffsets.push(positionOffset);
        positionOffset += repeatIntervalPixels;
      } while (repeatIntervalPixels > 0 && positionOffset < totalPathLength - endOffsetPixels);
      var segmentIndex = 0;
      var segment = segments[0];
      return positionOffsets.map(function(positionOffset2) {
        while (positionOffset2 > segment.distB && segmentIndex < nbSegments - 1) {
          segmentIndex++;
          segment = segments[segmentIndex];
        }
        var segmentRatio = (positionOffset2 - segment.distA) / (segment.distB - segment.distA);
        return {
          pt: interpolateBetweenPoints(segment.a, segment.b, segmentRatio),
          heading: segment.heading
        };
      });
    }
    function interpolateBetweenPoints(ptA, ptB, ratio) {
      if (ptB.x !== ptA.x) {
        return {
          x: ptA.x + ratio * (ptB.x - ptA.x),
          y: ptA.y + ratio * (ptB.y - ptA.y)
        };
      }
      return {
        x: ptA.x,
        y: ptA.y + (ptB.y - ptA.y) * ratio
      };
    }
    (function() {
      var proto_initIcon = L.Marker.prototype._initIcon;
      var proto_setPos = L.Marker.prototype._setPos;
      var oldIE = L.DomUtil.TRANSFORM === "msTransform";
      L.Marker.addInitHook(function() {
        var iconOptions = this.options.icon && this.options.icon.options;
        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;
        if (iconAnchor) {
          iconAnchor = iconAnchor[0] + "px " + iconAnchor[1] + "px";
        }
        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || "center bottom";
        this.options.rotationAngle = this.options.rotationAngle || 0;
        this.on("drag", function(e) {
          e.target._applyRotation();
        });
      });
      L.Marker.include({
        _initIcon: function() {
          proto_initIcon.call(this);
        },
        _setPos: function(pos) {
          proto_setPos.call(this, pos);
          this._applyRotation();
        },
        _applyRotation: function() {
          if (this.options.rotationAngle) {
            this._icon.style[L.DomUtil.TRANSFORM + "Origin"] = this.options.rotationOrigin;
            if (oldIE) {
              this._icon.style[L.DomUtil.TRANSFORM] = "rotate(" + this.options.rotationAngle + "deg)";
            } else {
              this._icon.style[L.DomUtil.TRANSFORM] += " rotateZ(" + this.options.rotationAngle + "deg)";
            }
          }
        },
        setRotationAngle: function(angle) {
          this.options.rotationAngle = angle;
          this.update();
          return this;
        },
        setRotationOrigin: function(origin) {
          this.options.rotationOrigin = origin;
          this.update();
          return this;
        }
      });
    })();
    L$12.Symbol = L$12.Symbol || {};
    L$12.Symbol.Dash = L$12.Class.extend({
      options: {
        pixelSize: 10,
        pathOptions: {}
      },
      initialize: function initialize(options) {
        L$12.Util.setOptions(this, options);
        this.options.pathOptions.clickable = false;
      },
      buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {
        var opts = this.options;
        var d2r = Math.PI / 180;
        if (opts.pixelSize <= 1) {
          return L$12.polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);
        }
        var midPoint = map.project(dirPoint.latLng);
        var angle = -(dirPoint.heading - 90) * d2r;
        var a = L$12.point(midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2, midPoint.y + opts.pixelSize * Math.sin(angle) / 2);
        var b = midPoint.add(midPoint.subtract(a));
        return L$12.polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);
      }
    });
    L$12.Symbol.dash = function(options) {
      return new L$12.Symbol.Dash(options);
    };
    L$12.Symbol.ArrowHead = L$12.Class.extend({
      options: {
        polygon: true,
        pixelSize: 10,
        headAngle: 60,
        pathOptions: {
          stroke: false,
          weight: 2
        }
      },
      initialize: function initialize(options) {
        L$12.Util.setOptions(this, options);
        this.options.pathOptions.clickable = false;
      },
      buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {
        return this.options.polygon ? L$12.polygon(this._buildArrowPath(dirPoint, map), this.options.pathOptions) : L$12.polyline(this._buildArrowPath(dirPoint, map), this.options.pathOptions);
      },
      _buildArrowPath: function _buildArrowPath(dirPoint, map) {
        var d2r = Math.PI / 180;
        var tipPoint = map.project(dirPoint.latLng);
        var direction = -(dirPoint.heading - 90) * d2r;
        var radianArrowAngle = this.options.headAngle / 2 * d2r;
        var headAngle1 = direction + radianArrowAngle;
        var headAngle2 = direction - radianArrowAngle;
        var arrowHead1 = L$12.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle1), tipPoint.y + this.options.pixelSize * Math.sin(headAngle1));
        var arrowHead2 = L$12.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle2), tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));
        return [map.unproject(arrowHead1), dirPoint.latLng, map.unproject(arrowHead2)];
      }
    });
    L$12.Symbol.arrowHead = function(options) {
      return new L$12.Symbol.ArrowHead(options);
    };
    L$12.Symbol.Marker = L$12.Class.extend({
      options: {
        markerOptions: {},
        rotate: false
      },
      initialize: function initialize(options) {
        L$12.Util.setOptions(this, options);
        this.options.markerOptions.clickable = false;
        this.options.markerOptions.draggable = false;
      },
      buildSymbol: function buildSymbol(directionPoint, latLngs, map, index, total) {
        if (this.options.rotate) {
          this.options.markerOptions.rotationAngle = directionPoint.heading + (this.options.angleCorrection || 0);
        }
        return L$12.marker(directionPoint.latLng, this.options.markerOptions);
      }
    });
    L$12.Symbol.marker = function(options) {
      return new L$12.Symbol.Marker(options);
    };
    var isCoord = function isCoord2(c) {
      return c instanceof L$12.LatLng || Array.isArray(c) && c.length === 2 && typeof c[0] === "number";
    };
    var isCoordArray = function isCoordArray2(ll) {
      return Array.isArray(ll) && isCoord(ll[0]);
    };
    L$12.PolylineDecorator = L$12.FeatureGroup.extend({
      options: {
        patterns: []
      },
      initialize: function initialize(paths, options) {
        L$12.FeatureGroup.prototype.initialize.call(this);
        L$12.Util.setOptions(this, options);
        this._map = null;
        this._paths = this._initPaths(paths);
        this._bounds = this._initBounds();
        this._patterns = this._initPatterns(this.options.patterns);
      },
      _initPaths: function _initPaths(input, isPolygon) {
        var _this = this;
        if (isCoordArray(input)) {
          var coords = isPolygon ? input.concat([input[0]]) : input;
          return [coords];
        }
        if (input instanceof L$12.Polyline) {
          return this._initPaths(input.getLatLngs(), input instanceof L$12.Polygon);
        }
        if (Array.isArray(input)) {
          return input.reduce(function(flatArray, p2) {
            return flatArray.concat(_this._initPaths(p2, isPolygon));
          }, []);
        }
        return [];
      },
      _initPatterns: function _initPatterns(patternDefs) {
        return patternDefs.map(this._parsePatternDef);
      },
      setPatterns: function setPatterns(patterns) {
        this.options.patterns = patterns;
        this._patterns = this._initPatterns(this.options.patterns);
        this.redraw();
      },
      setPaths: function setPaths(paths) {
        this._paths = this._initPaths(paths);
        this._bounds = this._initBounds();
        this.redraw();
      },
      _parsePatternDef: function _parsePatternDef(patternDef, latLngs) {
        return {
          symbolFactory: patternDef.symbol,
          offset: parseRelativeOrAbsoluteValue(patternDef.offset),
          endOffset: parseRelativeOrAbsoluteValue(patternDef.endOffset),
          repeat: parseRelativeOrAbsoluteValue(patternDef.repeat)
        };
      },
      onAdd: function onAdd(map) {
        this._map = map;
        this._draw();
        this._map.on("moveend", this.redraw, this);
      },
      onRemove: function onRemove(map) {
        this._map.off("moveend", this.redraw, this);
        this._map = null;
        L$12.FeatureGroup.prototype.onRemove.call(this, map);
      },
      _initBounds: function _initBounds() {
        var allPathCoords = this._paths.reduce(function(acc, path) {
          return acc.concat(path);
        }, []);
        return L$12.latLngBounds(allPathCoords);
      },
      getBounds: function getBounds() {
        return this._bounds;
      },
      _buildSymbols: function _buildSymbols(latLngs, symbolFactory, directionPoints) {
        var _this2 = this;
        return directionPoints.map(function(directionPoint, i) {
          return symbolFactory.buildSymbol(directionPoint, latLngs, _this2._map, i, directionPoints.length);
        });
      },
      _getDirectionPoints: function _getDirectionPoints(latLngs, pattern) {
        var _this3 = this;
        if (latLngs.length < 2) {
          return [];
        }
        var pathAsPoints = latLngs.map(function(latLng) {
          return _this3._map.project(latLng);
        });
        return projectPatternOnPointPath(pathAsPoints, pattern).map(function(point) {
          return {
            latLng: _this3._map.unproject(L$12.point(point.pt)),
            heading: point.heading
          };
        });
      },
      redraw: function redraw() {
        if (!this._map) {
          return;
        }
        this.clearLayers();
        this._draw();
      },
      _getPatternLayers: function _getPatternLayers(pattern) {
        var _this4 = this;
        var mapBounds = this._map.getBounds().pad(0.1);
        return this._paths.map(function(path) {
          var directionPoints = _this4._getDirectionPoints(path, pattern).filter(function(point) {
            return mapBounds.contains(point.latLng);
          });
          return L$12.featureGroup(_this4._buildSymbols(path, pattern.symbolFactory, directionPoints));
        });
      },
      _draw: function _draw() {
        var _this5 = this;
        this._patterns.map(function(pattern) {
          return _this5._getPatternLayers(pattern);
        }).forEach(function(layers) {
          _this5.addLayer(L$12.featureGroup(layers));
        });
      }
    });
    L$12.polylineDecorator = function(paths, options) {
      return new L$12.PolylineDecorator(paths, options);
    };
  });
})();
var leafletRuler$1 = { exports: {} };
(function(module, exports) {
  (function(factory, window2) {
    {
      module.exports = factory(leafletSrc.exports);
    }
    if (typeof window2 !== "undefined" && window2.L) {
      window2.L.Ruler = factory(L);
    }
  })(function(L2) {
    L2.Control.Ruler = L2.Control.extend({
      options: {
        position: "topright",
        circleMarker: {
          color: "red",
          radius: 2
        },
        lineStyle: {
          color: "red",
          dashArray: "1,6"
        },
        lengthUnit: {
          display: "km",
          decimal: 2,
          factor: null,
          label: "Distance:"
        },
        angleUnit: {
          display: "&deg;",
          decimal: 2,
          factor: null,
          label: "Bearing:"
        }
      },
      onAdd: function(map) {
        this._map = map;
        this._container = L2.DomUtil.create("div", "leaflet-bar");
        this._container.classList.add("leaflet-ruler");
        L2.DomEvent.disableClickPropagation(this._container);
        L2.DomEvent.on(this._container, "click", this._toggleMeasure, this);
        this._choice = false;
        this._defaultCursor = this._map._container.style.cursor;
        this._allLayers = L2.layerGroup();
        return this._container;
      },
      onRemove: function() {
        L2.DomEvent.off(this._container, "click", this._toggleMeasure, this);
      },
      _toggleMeasure: function() {
        this._choice = !this._choice;
        this._clickedLatLong = null;
        this._clickedPoints = [];
        this._totalLength = 0;
        if (this._choice) {
          this._map.doubleClickZoom.disable();
          L2.DomEvent.on(this._map._container, "keydown", this._escape, this);
          L2.DomEvent.on(this._map._container, "dblclick", this._closePath, this);
          this._container.classList.add("leaflet-ruler-clicked");
          this._clickCount = 0;
          this._tempLine = L2.featureGroup().addTo(this._allLayers);
          this._tempPoint = L2.featureGroup().addTo(this._allLayers);
          this._pointLayer = L2.featureGroup().addTo(this._allLayers);
          this._polylineLayer = L2.featureGroup().addTo(this._allLayers);
          this._allLayers.addTo(this._map);
          this._map._container.style.cursor = "crosshair";
          this._map.on("click", this._clicked, this);
          this._map.on("mousemove", this._moving, this);
        } else {
          this._map.doubleClickZoom.enable();
          L2.DomEvent.off(this._map._container, "keydown", this._escape, this);
          L2.DomEvent.off(this._map._container, "dblclick", this._closePath, this);
          this._container.classList.remove("leaflet-ruler-clicked");
          this._map.removeLayer(this._allLayers);
          this._allLayers = L2.layerGroup();
          this._map._container.style.cursor = this._defaultCursor;
          this._map.off("click", this._clicked, this);
          this._map.off("mousemove", this._moving, this);
        }
      },
      _clicked: function(e) {
        this._clickedLatLong = e.latlng;
        this._clickedPoints.push(this._clickedLatLong);
        L2.circleMarker(this._clickedLatLong, this.options.circleMarker).addTo(this._pointLayer);
        if (this._clickCount > 0 && !e.latlng.equals(this._clickedPoints[this._clickedPoints.length - 2])) {
          if (this._movingLatLong) {
            L2.polyline([this._clickedPoints[this._clickCount - 1], this._movingLatLong], this.options.lineStyle).addTo(this._polylineLayer);
          }
          var text2;
          this._totalLength += this._result.Distance;
          if (this._clickCount > 1) {
            text2 = "<b>" + this.options.angleUnit.label + "</b>&nbsp;" + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + "&nbsp;" + this.options.angleUnit.display + "<br><b>" + this.options.lengthUnit.label + "</b>&nbsp;" + this._totalLength.toFixed(this.options.lengthUnit.decimal) + "&nbsp;" + this.options.lengthUnit.display;
          } else {
            text2 = "<b>" + this.options.angleUnit.label + "</b>&nbsp;" + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + "&nbsp;" + this.options.angleUnit.display + "<br><b>" + this.options.lengthUnit.label + "</b>&nbsp;" + this._result.Distance.toFixed(this.options.lengthUnit.decimal) + "&nbsp;" + this.options.lengthUnit.display;
          }
          L2.circleMarker(this._clickedLatLong, this.options.circleMarker).bindTooltip(text2, { permanent: true, className: "result-tooltip" }).addTo(this._pointLayer).openTooltip();
        }
        this._clickCount++;
      },
      _moving: function(e) {
        if (this._clickedLatLong) {
          L2.DomEvent.off(this._container, "click", this._toggleMeasure, this);
          this._movingLatLong = e.latlng;
          if (this._tempLine) {
            this._map.removeLayer(this._tempLine);
            this._map.removeLayer(this._tempPoint);
          }
          var text2;
          this._addedLength = 0;
          this._tempLine = L2.featureGroup();
          this._tempPoint = L2.featureGroup();
          this._tempLine.addTo(this._map);
          this._tempPoint.addTo(this._map);
          this._calculateBearingAndDistance();
          this._addedLength = this._result.Distance + this._totalLength;
          L2.polyline([this._clickedLatLong, this._movingLatLong], this.options.lineStyle).addTo(this._tempLine);
          if (this._clickCount > 1) {
            text2 = "<b>" + this.options.angleUnit.label + "</b>&nbsp;" + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + "&nbsp;" + this.options.angleUnit.display + "<br><b>" + this.options.lengthUnit.label + "</b>&nbsp;" + this._addedLength.toFixed(this.options.lengthUnit.decimal) + "&nbsp;" + this.options.lengthUnit.display + '<br><div class="plus-length">(+' + this._result.Distance.toFixed(this.options.lengthUnit.decimal) + ")</div>";
          } else {
            text2 = "<b>" + this.options.angleUnit.label + "</b>&nbsp;" + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + "&nbsp;" + this.options.angleUnit.display + "<br><b>" + this.options.lengthUnit.label + "</b>&nbsp;" + this._result.Distance.toFixed(this.options.lengthUnit.decimal) + "&nbsp;" + this.options.lengthUnit.display;
          }
          L2.circleMarker(this._movingLatLong, this.options.circleMarker).bindTooltip(text2, { sticky: true, offset: L2.point(0, -40), className: "moving-tooltip" }).addTo(this._tempPoint).openTooltip();
        }
      },
      _escape: function(e) {
        if (e.keyCode === 27) {
          if (this._clickCount > 0) {
            this._closePath();
          } else {
            this._choice = true;
            this._toggleMeasure();
          }
        }
      },
      _calculateBearingAndDistance: function() {
        var f1 = this._clickedLatLong.lat, l1 = this._clickedLatLong.lng, f2 = this._movingLatLong.lat, l2 = this._movingLatLong.lng;
        var toRadian = Math.PI / 180;
        var y = Math.sin((l2 - l1) * toRadian) * Math.cos(f2 * toRadian);
        var x = Math.cos(f1 * toRadian) * Math.sin(f2 * toRadian) - Math.sin(f1 * toRadian) * Math.cos(f2 * toRadian) * Math.cos((l2 - l1) * toRadian);
        var brng = Math.atan2(y, x) * ((this.options.angleUnit.factor ? this.options.angleUnit.factor / 2 : 180) / Math.PI);
        brng += brng < 0 ? this.options.angleUnit.factor ? this.options.angleUnit.factor : 360 : 0;
        var R = this.options.lengthUnit.factor ? 6371 * this.options.lengthUnit.factor : 6371;
        var deltaF = (f2 - f1) * toRadian;
        var deltaL = (l2 - l1) * toRadian;
        var a = Math.sin(deltaF / 2) * Math.sin(deltaF / 2) + Math.cos(f1 * toRadian) * Math.cos(f2 * toRadian) * Math.sin(deltaL / 2) * Math.sin(deltaL / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var distance = R * c;
        this._result = {
          Bearing: brng,
          Distance: distance
        };
      },
      _closePath: function() {
        this._map.removeLayer(this._tempLine);
        this._map.removeLayer(this._tempPoint);
        if (this._clickCount <= 1)
          this._map.removeLayer(this._pointLayer);
        this._choice = false;
        L2.DomEvent.on(this._container, "click", this._toggleMeasure, this);
        this._toggleMeasure();
      }
    });
    L2.control.ruler = function(options) {
      return new L2.Control.Ruler(options);
    };
  }, window);
})(leafletRuler$1);
L.TrackSymbol = L.Path.extend({
  initialize: function(latlng, options) {
    L.setOptions(this, options);
    if (latlng === void 0) {
      throw Error("Please give a valid lat/lon-position");
    }
    options = options || {};
    this._id = options.trackId || 0;
    this._leaflet_id = this._id;
    this._latlng = L.latLng(latlng);
    this._size = options.size || 24;
    this._heading = options.heading;
    this._course = options.course;
    this._speed = options.speed;
    this._leaderTime = options.leaderTime || 60;
    this._minSilouetteZoom = options.minSilouetteZoom || 14;
    this.setGPSRefPos(options.gpsRefPos);
    this._triSymbol = options.defaultSymbol || [0.75, 0, -0.25, 0.3, -0.25, -0.3];
    this._diaSymbol = options.noHeadingSymbol || [0.3, 0, 0, 0.3, -0.3, 0, 0, -0.3];
    this._silSymbol = options.silouetteSymbol || [1, 0.5, 0.75, 1, 0, 1, 0, 0, 0.75, 0];
  },
  _project: function() {
  },
  _update: function() {
    this._setPath();
  },
  _setPath: function() {
    this._path.setAttribute("d", this.getPathString());
  },
  setDefaultSymbol: function(symbol) {
    this._triSymbol = symbol;
    return this.redraw();
  },
  setNoHeadingSymbol: function(symbol) {
    this._diaSymbol = symbol;
    return this.redraw();
  },
  setSilouetteSymbol: function(symbol) {
    this._silSymbol = symbol;
    return this.redraw();
  },
  setLatLng: function(latlng) {
    var oldLatLng = this._latlng;
    this._latlng = L.latLng(latlng);
    this.fire("move", { oldLatLng, latlng: this._latlng });
    return this.redraw();
  },
  setSpeed: function(speed) {
    this._speed = speed;
    return this.redraw();
  },
  setCourse: function(course) {
    this._course = course;
    return this.redraw();
  },
  setHeading: function(heading) {
    this._heading = heading;
    return this.redraw();
  },
  setLeaderTime: function(leaderTime) {
    this._leaderTime = leaderTime;
    return this.redraw();
  },
  setGPSRefPos: function(gpsRefPos) {
    if (gpsRefPos === void 0 || gpsRefPos.length < 4) {
      this._gpsRefPos = void 0;
    } else if (gpsRefPos[0] === 0 && gpsRefPos[1] === 0 && gpsRefPos[2] === 0 && gpsRefPos[3] === 0) {
      this._gpsRefPos = void 0;
    } else {
      this._gpsRefPos = gpsRefPos;
    }
    return this.redraw();
  },
  getTrackId: function() {
    return this._Id;
  },
  _getLatSize: function() {
    return this._getLatSizeOf(this._size);
  },
  _getLngSize: function() {
    return this._getLngSizeOf(this._size);
  },
  _getLatSizeOf: function(value) {
    return value / 40075017 * 360;
  },
  _getLngSizeOf: function(value) {
    return value / 40075017 * 360 / Math.cos(Math.PI / 180 * this._latlng.lat);
  },
  getBounds: function() {
    var lngSize = this._getLngSize() / 2;
    var latSize = this._getLatSize() / 2;
    var latlng = this._latlng;
    return new L.LatLngBounds([latlng.lat - latSize, latlng.lng - lngSize], [latlng.lat + latSize, latlng.lng + lngSize]);
  },
  getLatLng: function() {
    return this._latlng;
  },
  _rotate: function(point, angle) {
    var x = point[0];
    var y = point[1];
    var si_z = Math.sin(angle);
    var co_z = Math.cos(angle);
    var newX = x * co_z - y * si_z;
    var newY = x * si_z + y * co_z;
    return [newX, newY];
  },
  _rotateAllPoints: function(points, angle) {
    var result = [];
    for (var i = 0; i < points.length; i += 2) {
      var x = points[i + 0] * this._size;
      var y = points[i + 1] * this._size;
      var pt = this._rotate([x, y], angle);
      result.push(pt[0]);
      result.push(pt[1]);
    }
    return result;
  },
  _createLeaderViewPoints: function(angle) {
    var leaderLength = this._speed * this._leaderTime;
    var leaderEndLng = this._latlng.lng + this._getLngSizeOf(leaderLength * Math.cos(angle));
    var leaderEndLat = this._latlng.lat + this._getLatSizeOf(leaderLength * Math.sin(angle));
    var endPoint = this._map.latLngToLayerPoint(L.latLng([leaderEndLat, leaderEndLng]));
    var startPoint = this._map.latLngToLayerPoint(this._latlng);
    return [startPoint.x, startPoint.y, endPoint.x, endPoint.y];
  },
  _transformAllPointsToView: function(points) {
    var result = [];
    var symbolViewCenter = this._map.latLngToLayerPoint(this._latlng);
    for (var i = 0; i < points.length; i += 2) {
      var x = symbolViewCenter.x + points[i + 0];
      var y = symbolViewCenter.y - points[i + 1];
      result.push(x);
      result.push(y);
    }
    return result;
  },
  _createPathFromPoints: function(points) {
    var result;
    for (var i = 0; i < points.length; i += 2) {
      var x = points[i + 0];
      var y = points[i + 1];
      if (result === void 0)
        result = "M " + x + " " + y + " ";
      else
        result += "L " + x + " " + y + " ";
    }
    return result + " Z";
  },
  _getViewAngleFromModel: function(modelAngle) {
    return Math.PI / 2 - modelAngle;
  },
  _createNoHeadingSymbolPathString: function() {
    var viewPoints = this._transformAllPointsToView(this._rotateAllPoints(this._diaSymbol, 0));
    var viewPath = this._createPathFromPoints(viewPoints);
    if (this._course !== void 0 && this._speed !== void 0) {
      var courseAngle = this._getViewAngleFromModel(this._course);
      var leaderPoints = this._createLeaderViewPoints(courseAngle);
      viewPath += "" + this._createPathFromPoints(leaderPoints);
    }
    return viewPath;
  },
  _createWithHeadingSymbolPathString: function() {
    var headingAngle = this._getViewAngleFromModel(this._heading);
    var viewPoints = this._transformAllPointsToView(this._rotateAllPoints(this._triSymbol, headingAngle));
    var viewPath = this._createPathFromPoints(viewPoints);
    if (this._course !== void 0 && this._speed !== void 0) {
      var courseAngle = this._getViewAngleFromModel(this._course);
      var leaderPoints = this._createLeaderViewPoints(courseAngle);
      viewPath += "" + this._createPathFromPoints(leaderPoints);
    }
    return viewPath;
  },
  _resizeAndMovePoint: function(point, size, offset) {
    return [
      point[0] * size[0] + offset[0],
      point[1] * size[1] + offset[1]
    ];
  },
  _getSizeFromGPSRefPos: function() {
    return [
      this._gpsRefPos[0] + this._gpsRefPos[1],
      this._gpsRefPos[2] + this._gpsRefPos[3]
    ];
  },
  _getOffsetFromGPSRefPos: function() {
    return [
      -this._gpsRefPos[1],
      -this._gpsRefPos[3]
    ];
  },
  _transformSilouetteSymbol: function() {
    var headingAngle = this._getViewAngleFromModel(this._heading);
    var result = [];
    var size = this._getSizeFromGPSRefPos();
    var offset = this._getOffsetFromGPSRefPos();
    for (var i = 0; i < this._silSymbol.length; i += 2) {
      var pt = [
        this._silSymbol[i + 0],
        this._silSymbol[i + 1]
      ];
      pt = this._resizeAndMovePoint(pt, size, offset);
      pt = this._rotate(pt, headingAngle);
      var pointLng = this._latlng.lng + this._getLngSizeOf(pt[0]);
      var pointLat = this._latlng.lat + this._getLatSizeOf(pt[1]);
      var viewPoint = this._map.latLngToLayerPoint(L.latLng([pointLat, pointLng]));
      result.push(viewPoint.x);
      result.push(viewPoint.y);
    }
    return result;
  },
  _createSilouetteSymbolPathString: function() {
    var silouettePoints = this._transformSilouetteSymbol();
    var viewPath = this._createPathFromPoints(silouettePoints);
    if (this._course !== void 0 && this._speed !== void 0) {
      var courseAngle = this._getViewAngleFromModel(this._course);
      var leaderPoints = this._createLeaderViewPoints(courseAngle);
      viewPath += "" + this._createPathFromPoints(leaderPoints);
    }
    return viewPath;
  },
  getPathString: function() {
    if (this._heading === void 0) {
      return this._createNoHeadingSymbolPathString();
    } else {
      if (this._gpsRefPos === void 0 || this._map.getZoom() <= this._minSilouetteZoom) {
        return this._createWithHeadingSymbolPathString();
      } else {
        return this._createSilouetteSymbolPathString();
      }
    }
  }
});
L.trackSymbol = function(latlng, options) {
  return new L.TrackSymbol(latlng, options);
};
var leaflet = "";
var leafletRuler = "";
var bare = "";
var global$1 = "";
window.type = true;
L$1.Icon.Default.prototype.options.imagePath = "/arl-map-tool/images/";
new App({
  target: document.body
});
//# sourceMappingURL=index.c6647d5e.js.map
